// automatically generated file -- update by running:
// cargo build --features=spirv-parser-generator
//
// Copyright (c) 2014-2016 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and/or associated documentation files (the "Materials"),
// to deal in the Materials without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Materials, and to permit persons to whom the
// Materials are furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Materials.
//
// MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
// STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
// HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
// IN THE MATERIALS.
use alloc::borrow::Cow;
use alloc::string::FromUtf8Error;
use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use core::mem;
use core::ops::Deref;
use core::result;
use core::str::Utf8Error;
macro_rules! split_fn {
    ($body:expr) => {
        (|| $body)()
    };
}
trait SPIRVParse: Sized {
    fn spirv_parse<'a>(words: &'a [u32], parse_state: &mut ParseState)
        -> Result<(Self, &'a [u32])>;
}
trait SPIRVDisplay {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result;
}
impl<T: SPIRVParse> SPIRVParse for Option<T> {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        if words.is_empty() {
            Ok((None, words))
        } else {
            let (value, words) = T::spirv_parse(words, parse_state)?;
            Ok((Some(value), words))
        }
    }
}
impl<T: SPIRVDisplay> SPIRVDisplay for Option<T> {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Some(v) => v.spirv_display(f),
            None => Ok(()),
        }
    }
}
impl<T: SPIRVParse> SPIRVParse for Vec<T> {
    fn spirv_parse<'a>(
        mut words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let mut retval = Vec::new();
        while !words.is_empty() {
            let result = T::spirv_parse(words, parse_state)?;
            words = result.1;
            retval.push(result.0);
        }
        Ok((retval, words))
    }
}
impl<T: SPIRVDisplay> SPIRVDisplay for Vec<T> {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for i in self {
            i.spirv_display(f)?;
        }
        Ok(())
    }
}
impl<A: SPIRVParse, B: SPIRVParse> SPIRVParse for (A, B) {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (a, words) = A::spirv_parse(words, parse_state)?;
        let (b, words) = B::spirv_parse(words, parse_state)?;
        Ok(((a, b), words))
    }
}
impl<A: SPIRVDisplay, B: SPIRVDisplay> SPIRVDisplay for (A, B) {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)?;
        self.1.spirv_display(f)
    }
}
const BYTES_PER_WORD: usize = 4;
struct ByteIterator<'a> {
    current_word: [u8; BYTES_PER_WORD],
    current_word_index: usize,
    words: &'a [u32],
}
impl<'a> ByteIterator<'a> {
    fn new(words: &'a [u32]) -> Self {
        Self {
            current_word: [0; BYTES_PER_WORD],
            current_word_index: BYTES_PER_WORD,
            words,
        }
    }
    fn take_unread_words(&mut self) -> &'a [u32] {
        mem::replace(&mut self.words, &[])
    }
}
impl<'a> Iterator for ByteIterator<'a> {
    type Item = u8;
    fn next(&mut self) -> Option<u8> {
        if self.current_word_index >= BYTES_PER_WORD {
            let (&current_word, words) = self.words.split_first()?;
            self.words = words;
            self.current_word = unsafe { mem::transmute(current_word.to_le()) };
            self.current_word_index = 0;
        }
        let byte = self.current_word[self.current_word_index];
        self.current_word_index += 1;
        Some(byte)
    }
}
impl SPIRVParse for String {
    fn spirv_parse<'a>(
        words: &'a [u32],
        _parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let mut byte_count_excluding_null_terminator = None;
        for (index, byte) in ByteIterator::new(words).enumerate() {
            if byte == 0 {
                byte_count_excluding_null_terminator = Some(index);
                break;
            }
        }
        let byte_count_excluding_null_terminator =
            byte_count_excluding_null_terminator.ok_or(Error::InstructionPrematurelyEnded)?;
        let mut bytes = Vec::with_capacity(byte_count_excluding_null_terminator);
        let mut byte_iter = ByteIterator::new(words);
        for _ in 0..byte_count_excluding_null_terminator {
            let byte = byte_iter.next().unwrap();
            bytes.push(byte);
        }
        let _null_terminator = byte_iter.next().unwrap();
        let words = byte_iter.take_unread_words();
        for v in byte_iter {
            if v != 0 {
                return Err(Error::InvalidStringTermination);
            }
        }
        assert_eq!(bytes.len(), byte_count_excluding_null_terminator);
        Ok((String::from_utf8(bytes)?, words))
    }
}
impl SPIRVDisplay for String {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {:?}", self)
    }
}
impl SPIRVParse for u32 {
    fn spirv_parse<'a>(
        words: &'a [u32],
        _parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (&value, words) = words
            .split_first()
            .ok_or(Error::InstructionPrematurelyEnded)?;
        Ok((value, words))
    }
}
impl SPIRVDisplay for u32 {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {}", self)
    }
}
impl SPIRVParse for u64 {
    fn spirv_parse<'a>(
        words: &'a [u32],
        _parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (&low, words) = words
            .split_first()
            .ok_or(Error::InstructionPrematurelyEnded)?;
        let (&high, words) = words
            .split_first()
            .ok_or(Error::InstructionPrematurelyEnded)?;
        Ok(((u64::from(high) << 32) | u64::from(low), words))
    }
}
impl SPIRVDisplay for u64 {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {}", self)
    }
}
impl SPIRVParse for IdRef {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (value, words) = u32::spirv_parse(words, parse_state)?;
        if value == 0 || value as usize >= parse_state.id_states.len() {
            Err(Error::IdOutOfBounds(value))
        } else {
            Ok((IdRef(value), words))
        }
    }
}
impl SPIRVDisplay for IdRef {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {}", self)
    }
}
pub const MAGIC_NUMBER: u32 = 119734787u32;
pub const MAJOR_VERSION: u32 = 1u32;
pub const MINOR_VERSION: u32 = 5u32;
pub const REVISION: u32 = 1u32;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperands {
    pub bias: Option<ImageOperandsBias>,
    pub lod: Option<ImageOperandsLod>,
    pub grad: Option<ImageOperandsGrad>,
    pub const_offset: Option<ImageOperandsConstOffset>,
    pub offset: Option<ImageOperandsOffset>,
    pub const_offsets: Option<ImageOperandsConstOffsets>,
    pub sample: Option<ImageOperandsSample>,
    pub min_lod: Option<ImageOperandsMinLod>,
    pub make_texel_available: Option<ImageOperandsMakeTexelAvailable>,
    pub make_texel_available_khr: Option<ImageOperandsMakeTexelAvailableKHR>,
    pub make_texel_visible: Option<ImageOperandsMakeTexelVisible>,
    pub make_texel_visible_khr: Option<ImageOperandsMakeTexelVisibleKHR>,
    pub non_private_texel: Option<ImageOperandsNonPrivateTexel>,
    pub non_private_texel_khr: Option<ImageOperandsNonPrivateTexelKHR>,
    pub volatile_texel: Option<ImageOperandsVolatileTexel>,
    pub volatile_texel_khr: Option<ImageOperandsVolatileTexelKHR>,
    pub sign_extend: Option<ImageOperandsSignExtend>,
    pub zero_extend: Option<ImageOperandsZeroExtend>,
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsBias(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsLod(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsGrad(pub IdRef, pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsConstOffset(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsOffset(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsConstOffsets(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsSample(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMinLod(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelAvailable(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelAvailableKHR(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelVisible(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelVisibleKHR(pub IdScope);
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsNonPrivateTexel;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsNonPrivateTexelKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsVolatileTexel;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsVolatileTexelKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsSignExtend;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsZeroExtend;
impl SPIRVParse for ImageOperands {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (bias, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsBias(parameter_0)), words)
        } else {
            (None, words)
        };
        let (lod, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsLod(parameter_0)), words)
        } else {
            (None, words)
        };
        let (grad, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            let (parameter_1, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsGrad(parameter_0, parameter_1)), words)
        } else {
            (None, words)
        };
        let (const_offset, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsConstOffset(parameter_0)), words)
        } else {
            (None, words)
        };
        let (offset, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsOffset(parameter_0)), words)
        } else {
            (None, words)
        };
        let (const_offsets, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsConstOffsets(parameter_0)), words)
        } else {
            (None, words)
        };
        let (sample, words) = if (mask & 64u32) != 0 {
            mask &= !64u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsSample(parameter_0)), words)
        } else {
            (None, words)
        };
        let (min_lod, words) = if (mask & 128u32) != 0 {
            mask &= !128u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMinLod(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_available, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelAvailable(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_available_khr, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelAvailableKHR(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_visible, words) = if (mask & 512u32) != 0 {
            mask &= !512u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelVisible(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_visible_khr, words) = if (mask & 512u32) != 0 {
            mask &= !512u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelVisibleKHR(parameter_0)), words)
        } else {
            (None, words)
        };
        let (non_private_texel, words) = if (mask & 1024u32) != 0 {
            mask &= !1024u32;
            (Some(ImageOperandsNonPrivateTexel), words)
        } else {
            (None, words)
        };
        let (non_private_texel_khr, words) = if (mask & 1024u32) != 0 {
            mask &= !1024u32;
            (Some(ImageOperandsNonPrivateTexelKHR), words)
        } else {
            (None, words)
        };
        let (volatile_texel, words) = if (mask & 2048u32) != 0 {
            mask &= !2048u32;
            (Some(ImageOperandsVolatileTexel), words)
        } else {
            (None, words)
        };
        let (volatile_texel_khr, words) = if (mask & 2048u32) != 0 {
            mask &= !2048u32;
            (Some(ImageOperandsVolatileTexelKHR), words)
        } else {
            (None, words)
        };
        let (sign_extend, words) = if (mask & 4096u32) != 0 {
            mask &= !4096u32;
            (Some(ImageOperandsSignExtend), words)
        } else {
            (None, words)
        };
        let (zero_extend, words) = if (mask & 8192u32) != 0 {
            mask &= !8192u32;
            (Some(ImageOperandsZeroExtend), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    bias,
                    lod,
                    grad,
                    const_offset,
                    offset,
                    const_offsets,
                    sample,
                    min_lod,
                    make_texel_available,
                    make_texel_available_khr,
                    make_texel_visible,
                    make_texel_visible_khr,
                    non_private_texel,
                    non_private_texel_khr,
                    volatile_texel,
                    volatile_texel_khr,
                    sign_extend,
                    zero_extend,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for ImageOperands {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.bias.is_some() {
            if any_members {
                write!(f, "|{}", "Bias")?;
            } else {
                write!(f, " {}", "Bias")?;
                any_members = true;
            }
        }
        if self.lod.is_some() {
            if any_members {
                write!(f, "|{}", "Lod")?;
            } else {
                write!(f, " {}", "Lod")?;
                any_members = true;
            }
        }
        if self.grad.is_some() {
            if any_members {
                write!(f, "|{}", "Grad")?;
            } else {
                write!(f, " {}", "Grad")?;
                any_members = true;
            }
        }
        if self.const_offset.is_some() {
            if any_members {
                write!(f, "|{}", "ConstOffset")?;
            } else {
                write!(f, " {}", "ConstOffset")?;
                any_members = true;
            }
        }
        if self.offset.is_some() {
            if any_members {
                write!(f, "|{}", "Offset")?;
            } else {
                write!(f, " {}", "Offset")?;
                any_members = true;
            }
        }
        if self.const_offsets.is_some() {
            if any_members {
                write!(f, "|{}", "ConstOffsets")?;
            } else {
                write!(f, " {}", "ConstOffsets")?;
                any_members = true;
            }
        }
        if self.sample.is_some() {
            if any_members {
                write!(f, "|{}", "Sample")?;
            } else {
                write!(f, " {}", "Sample")?;
                any_members = true;
            }
        }
        if self.min_lod.is_some() {
            if any_members {
                write!(f, "|{}", "MinLod")?;
            } else {
                write!(f, " {}", "MinLod")?;
                any_members = true;
            }
        }
        if self.make_texel_available.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelAvailable")?;
            } else {
                write!(f, " {}", "MakeTexelAvailable")?;
                any_members = true;
            }
        }
        if self.make_texel_available_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelAvailableKHR")?;
            } else {
                write!(f, " {}", "MakeTexelAvailableKHR")?;
                any_members = true;
            }
        }
        if self.make_texel_visible.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelVisible")?;
            } else {
                write!(f, " {}", "MakeTexelVisible")?;
                any_members = true;
            }
        }
        if self.make_texel_visible_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelVisibleKHR")?;
            } else {
                write!(f, " {}", "MakeTexelVisibleKHR")?;
                any_members = true;
            }
        }
        if self.non_private_texel.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivateTexel")?;
            } else {
                write!(f, " {}", "NonPrivateTexel")?;
                any_members = true;
            }
        }
        if self.non_private_texel_khr.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivateTexelKHR")?;
            } else {
                write!(f, " {}", "NonPrivateTexelKHR")?;
                any_members = true;
            }
        }
        if self.volatile_texel.is_some() {
            if any_members {
                write!(f, "|{}", "VolatileTexel")?;
            } else {
                write!(f, " {}", "VolatileTexel")?;
                any_members = true;
            }
        }
        if self.volatile_texel_khr.is_some() {
            if any_members {
                write!(f, "|{}", "VolatileTexelKHR")?;
            } else {
                write!(f, " {}", "VolatileTexelKHR")?;
                any_members = true;
            }
        }
        if self.sign_extend.is_some() {
            if any_members {
                write!(f, "|{}", "SignExtend")?;
            } else {
                write!(f, " {}", "SignExtend")?;
                any_members = true;
            }
        }
        if self.zero_extend.is_some() {
            if any_members {
                write!(f, "|{}", "ZeroExtend")?;
            } else {
                write!(f, " {}", "ZeroExtend")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        if let Some(ImageOperandsBias(parameter_0)) = &self.bias {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsLod(parameter_0)) = &self.lod {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsGrad(parameter_0, parameter_1)) = &self.grad {
            parameter_0.spirv_display(f)?;
            parameter_1.spirv_display(f)?;
        }
        if let Some(ImageOperandsConstOffset(parameter_0)) = &self.const_offset {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsOffset(parameter_0)) = &self.offset {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsConstOffsets(parameter_0)) = &self.const_offsets {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsSample(parameter_0)) = &self.sample {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMinLod(parameter_0)) = &self.min_lod {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelAvailable(parameter_0)) = &self.make_texel_available {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelAvailableKHR(parameter_0)) =
            &self.make_texel_available_khr
        {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelVisible(parameter_0)) = &self.make_texel_visible {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelVisibleKHR(parameter_0)) = &self.make_texel_visible_khr {
            parameter_0.spirv_display(f)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathMode {
    pub not_nan: Option<FPFastMathModeNotNaN>,
    pub not_inf: Option<FPFastMathModeNotInf>,
    pub nsz: Option<FPFastMathModeNSZ>,
    pub allow_recip: Option<FPFastMathModeAllowRecip>,
    pub fast: Option<FPFastMathModeFast>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeNotNaN;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeNotInf;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeNSZ;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeAllowRecip;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeFast;
impl SPIRVParse for FPFastMathMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (not_nan, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(FPFastMathModeNotNaN), words)
        } else {
            (None, words)
        };
        let (not_inf, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(FPFastMathModeNotInf), words)
        } else {
            (None, words)
        };
        let (nsz, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(FPFastMathModeNSZ), words)
        } else {
            (None, words)
        };
        let (allow_recip, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            (Some(FPFastMathModeAllowRecip), words)
        } else {
            (None, words)
        };
        let (fast, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            (Some(FPFastMathModeFast), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    not_nan,
                    not_inf,
                    nsz,
                    allow_recip,
                    fast,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for FPFastMathMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.not_nan.is_some() {
            if any_members {
                write!(f, "|{}", "NotNaN")?;
            } else {
                write!(f, " {}", "NotNaN")?;
                any_members = true;
            }
        }
        if self.not_inf.is_some() {
            if any_members {
                write!(f, "|{}", "NotInf")?;
            } else {
                write!(f, " {}", "NotInf")?;
                any_members = true;
            }
        }
        if self.nsz.is_some() {
            if any_members {
                write!(f, "|{}", "NSZ")?;
            } else {
                write!(f, " {}", "NSZ")?;
                any_members = true;
            }
        }
        if self.allow_recip.is_some() {
            if any_members {
                write!(f, "|{}", "AllowRecip")?;
            } else {
                write!(f, " {}", "AllowRecip")?;
                any_members = true;
            }
        }
        if self.fast.is_some() {
            if any_members {
                write!(f, "|{}", "Fast")?;
            } else {
                write!(f, " {}", "Fast")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct SelectionControl {
    pub flatten: Option<SelectionControlFlatten>,
    pub dont_flatten: Option<SelectionControlDontFlatten>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct SelectionControlFlatten;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct SelectionControlDontFlatten;
impl SPIRVParse for SelectionControl {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (flatten, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(SelectionControlFlatten), words)
        } else {
            (None, words)
        };
        let (dont_flatten, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(SelectionControlDontFlatten), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    flatten,
                    dont_flatten,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for SelectionControl {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.flatten.is_some() {
            if any_members {
                write!(f, "|{}", "Flatten")?;
            } else {
                write!(f, " {}", "Flatten")?;
                any_members = true;
            }
        }
        if self.dont_flatten.is_some() {
            if any_members {
                write!(f, "|{}", "DontFlatten")?;
            } else {
                write!(f, " {}", "DontFlatten")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControl {
    pub unroll: Option<LoopControlUnroll>,
    pub dont_unroll: Option<LoopControlDontUnroll>,
    pub dependency_infinite: Option<LoopControlDependencyInfinite>,
    pub dependency_length: Option<LoopControlDependencyLength>,
    pub min_iterations: Option<LoopControlMinIterations>,
    pub max_iterations: Option<LoopControlMaxIterations>,
    pub iteration_multiple: Option<LoopControlIterationMultiple>,
    pub peel_count: Option<LoopControlPeelCount>,
    pub partial_count: Option<LoopControlPartialCount>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlUnroll;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlDontUnroll;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlDependencyInfinite;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlDependencyLength(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlMinIterations(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlMaxIterations(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlIterationMultiple(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlPeelCount(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlPartialCount(pub LiteralInteger32);
impl SPIRVParse for LoopControl {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (unroll, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(LoopControlUnroll), words)
        } else {
            (None, words)
        };
        let (dont_unroll, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(LoopControlDontUnroll), words)
        } else {
            (None, words)
        };
        let (dependency_infinite, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(LoopControlDependencyInfinite), words)
        } else {
            (None, words)
        };
        let (dependency_length, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlDependencyLength(parameter_0)), words)
        } else {
            (None, words)
        };
        let (min_iterations, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlMinIterations(parameter_0)), words)
        } else {
            (None, words)
        };
        let (max_iterations, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlMaxIterations(parameter_0)), words)
        } else {
            (None, words)
        };
        let (iteration_multiple, words) = if (mask & 64u32) != 0 {
            mask &= !64u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlIterationMultiple(parameter_0)), words)
        } else {
            (None, words)
        };
        let (peel_count, words) = if (mask & 128u32) != 0 {
            mask &= !128u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlPeelCount(parameter_0)), words)
        } else {
            (None, words)
        };
        let (partial_count, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlPartialCount(parameter_0)), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    unroll,
                    dont_unroll,
                    dependency_infinite,
                    dependency_length,
                    min_iterations,
                    max_iterations,
                    iteration_multiple,
                    peel_count,
                    partial_count,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for LoopControl {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.unroll.is_some() {
            if any_members {
                write!(f, "|{}", "Unroll")?;
            } else {
                write!(f, " {}", "Unroll")?;
                any_members = true;
            }
        }
        if self.dont_unroll.is_some() {
            if any_members {
                write!(f, "|{}", "DontUnroll")?;
            } else {
                write!(f, " {}", "DontUnroll")?;
                any_members = true;
            }
        }
        if self.dependency_infinite.is_some() {
            if any_members {
                write!(f, "|{}", "DependencyInfinite")?;
            } else {
                write!(f, " {}", "DependencyInfinite")?;
                any_members = true;
            }
        }
        if self.dependency_length.is_some() {
            if any_members {
                write!(f, "|{}", "DependencyLength")?;
            } else {
                write!(f, " {}", "DependencyLength")?;
                any_members = true;
            }
        }
        if self.min_iterations.is_some() {
            if any_members {
                write!(f, "|{}", "MinIterations")?;
            } else {
                write!(f, " {}", "MinIterations")?;
                any_members = true;
            }
        }
        if self.max_iterations.is_some() {
            if any_members {
                write!(f, "|{}", "MaxIterations")?;
            } else {
                write!(f, " {}", "MaxIterations")?;
                any_members = true;
            }
        }
        if self.iteration_multiple.is_some() {
            if any_members {
                write!(f, "|{}", "IterationMultiple")?;
            } else {
                write!(f, " {}", "IterationMultiple")?;
                any_members = true;
            }
        }
        if self.peel_count.is_some() {
            if any_members {
                write!(f, "|{}", "PeelCount")?;
            } else {
                write!(f, " {}", "PeelCount")?;
                any_members = true;
            }
        }
        if self.partial_count.is_some() {
            if any_members {
                write!(f, "|{}", "PartialCount")?;
            } else {
                write!(f, " {}", "PartialCount")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        if let Some(LoopControlDependencyLength(parameter_0)) = &self.dependency_length {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlMinIterations(parameter_0)) = &self.min_iterations {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlMaxIterations(parameter_0)) = &self.max_iterations {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlIterationMultiple(parameter_0)) = &self.iteration_multiple {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlPeelCount(parameter_0)) = &self.peel_count {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlPartialCount(parameter_0)) = &self.partial_count {
            parameter_0.spirv_display(f)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControl {
    pub inline: Option<FunctionControlInline>,
    pub dont_inline: Option<FunctionControlDontInline>,
    pub pure_: Option<FunctionControlPure>,
    pub const_: Option<FunctionControlConst>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlInline;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlDontInline;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlPure;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlConst;
impl SPIRVParse for FunctionControl {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (inline, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(FunctionControlInline), words)
        } else {
            (None, words)
        };
        let (dont_inline, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(FunctionControlDontInline), words)
        } else {
            (None, words)
        };
        let (pure_, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(FunctionControlPure), words)
        } else {
            (None, words)
        };
        let (const_, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            (Some(FunctionControlConst), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    inline,
                    dont_inline,
                    pure_,
                    const_,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for FunctionControl {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.inline.is_some() {
            if any_members {
                write!(f, "|{}", "Inline")?;
            } else {
                write!(f, " {}", "Inline")?;
                any_members = true;
            }
        }
        if self.dont_inline.is_some() {
            if any_members {
                write!(f, "|{}", "DontInline")?;
            } else {
                write!(f, " {}", "DontInline")?;
                any_members = true;
            }
        }
        if self.pure_.is_some() {
            if any_members {
                write!(f, "|{}", "Pure")?;
            } else {
                write!(f, " {}", "Pure")?;
                any_members = true;
            }
        }
        if self.const_.is_some() {
            if any_members {
                write!(f, "|{}", "Const")?;
            } else {
                write!(f, " {}", "Const")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemantics {
    pub acquire: Option<MemorySemanticsAcquire>,
    pub release: Option<MemorySemanticsRelease>,
    pub acquire_release: Option<MemorySemanticsAcquireRelease>,
    pub sequentially_consistent: Option<MemorySemanticsSequentiallyConsistent>,
    pub uniform_memory: Option<MemorySemanticsUniformMemory>,
    pub subgroup_memory: Option<MemorySemanticsSubgroupMemory>,
    pub workgroup_memory: Option<MemorySemanticsWorkgroupMemory>,
    pub cross_workgroup_memory: Option<MemorySemanticsCrossWorkgroupMemory>,
    pub atomic_counter_memory: Option<MemorySemanticsAtomicCounterMemory>,
    pub image_memory: Option<MemorySemanticsImageMemory>,
    pub output_memory: Option<MemorySemanticsOutputMemory>,
    pub output_memory_khr: Option<MemorySemanticsOutputMemoryKHR>,
    pub make_available: Option<MemorySemanticsMakeAvailable>,
    pub make_available_khr: Option<MemorySemanticsMakeAvailableKHR>,
    pub make_visible: Option<MemorySemanticsMakeVisible>,
    pub make_visible_khr: Option<MemorySemanticsMakeVisibleKHR>,
    pub volatile: Option<MemorySemanticsVolatile>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsAcquire;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsRelease;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsAcquireRelease;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsSequentiallyConsistent;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsUniformMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsSubgroupMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsWorkgroupMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsCrossWorkgroupMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsAtomicCounterMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsImageMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsOutputMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsOutputMemoryKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeAvailable;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeAvailableKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeVisible;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeVisibleKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsVolatile;
impl SPIRVParse for MemorySemantics {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (acquire, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(MemorySemanticsAcquire), words)
        } else {
            (None, words)
        };
        let (release, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(MemorySemanticsRelease), words)
        } else {
            (None, words)
        };
        let (acquire_release, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            (Some(MemorySemanticsAcquireRelease), words)
        } else {
            (None, words)
        };
        let (sequentially_consistent, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            (Some(MemorySemanticsSequentiallyConsistent), words)
        } else {
            (None, words)
        };
        let (uniform_memory, words) = if (mask & 64u32) != 0 {
            mask &= !64u32;
            (Some(MemorySemanticsUniformMemory), words)
        } else {
            (None, words)
        };
        let (subgroup_memory, words) = if (mask & 128u32) != 0 {
            mask &= !128u32;
            (Some(MemorySemanticsSubgroupMemory), words)
        } else {
            (None, words)
        };
        let (workgroup_memory, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            (Some(MemorySemanticsWorkgroupMemory), words)
        } else {
            (None, words)
        };
        let (cross_workgroup_memory, words) = if (mask & 512u32) != 0 {
            mask &= !512u32;
            (Some(MemorySemanticsCrossWorkgroupMemory), words)
        } else {
            (None, words)
        };
        let (atomic_counter_memory, words) = if (mask & 1024u32) != 0 {
            mask &= !1024u32;
            (Some(MemorySemanticsAtomicCounterMemory), words)
        } else {
            (None, words)
        };
        let (image_memory, words) = if (mask & 2048u32) != 0 {
            mask &= !2048u32;
            (Some(MemorySemanticsImageMemory), words)
        } else {
            (None, words)
        };
        let (output_memory, words) = if (mask & 4096u32) != 0 {
            mask &= !4096u32;
            (Some(MemorySemanticsOutputMemory), words)
        } else {
            (None, words)
        };
        let (output_memory_khr, words) = if (mask & 4096u32) != 0 {
            mask &= !4096u32;
            (Some(MemorySemanticsOutputMemoryKHR), words)
        } else {
            (None, words)
        };
        let (make_available, words) = if (mask & 8192u32) != 0 {
            mask &= !8192u32;
            (Some(MemorySemanticsMakeAvailable), words)
        } else {
            (None, words)
        };
        let (make_available_khr, words) = if (mask & 8192u32) != 0 {
            mask &= !8192u32;
            (Some(MemorySemanticsMakeAvailableKHR), words)
        } else {
            (None, words)
        };
        let (make_visible, words) = if (mask & 16384u32) != 0 {
            mask &= !16384u32;
            (Some(MemorySemanticsMakeVisible), words)
        } else {
            (None, words)
        };
        let (make_visible_khr, words) = if (mask & 16384u32) != 0 {
            mask &= !16384u32;
            (Some(MemorySemanticsMakeVisibleKHR), words)
        } else {
            (None, words)
        };
        let (volatile, words) = if (mask & 32768u32) != 0 {
            mask &= !32768u32;
            (Some(MemorySemanticsVolatile), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    acquire,
                    release,
                    acquire_release,
                    sequentially_consistent,
                    uniform_memory,
                    subgroup_memory,
                    workgroup_memory,
                    cross_workgroup_memory,
                    atomic_counter_memory,
                    image_memory,
                    output_memory,
                    output_memory_khr,
                    make_available,
                    make_available_khr,
                    make_visible,
                    make_visible_khr,
                    volatile,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for MemorySemantics {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.acquire.is_some() {
            if any_members {
                write!(f, "|{}", "Acquire")?;
            } else {
                write!(f, " {}", "Acquire")?;
                any_members = true;
            }
        }
        if self.release.is_some() {
            if any_members {
                write!(f, "|{}", "Release")?;
            } else {
                write!(f, " {}", "Release")?;
                any_members = true;
            }
        }
        if self.acquire_release.is_some() {
            if any_members {
                write!(f, "|{}", "AcquireRelease")?;
            } else {
                write!(f, " {}", "AcquireRelease")?;
                any_members = true;
            }
        }
        if self.sequentially_consistent.is_some() {
            if any_members {
                write!(f, "|{}", "SequentiallyConsistent")?;
            } else {
                write!(f, " {}", "SequentiallyConsistent")?;
                any_members = true;
            }
        }
        if self.uniform_memory.is_some() {
            if any_members {
                write!(f, "|{}", "UniformMemory")?;
            } else {
                write!(f, " {}", "UniformMemory")?;
                any_members = true;
            }
        }
        if self.subgroup_memory.is_some() {
            if any_members {
                write!(f, "|{}", "SubgroupMemory")?;
            } else {
                write!(f, " {}", "SubgroupMemory")?;
                any_members = true;
            }
        }
        if self.workgroup_memory.is_some() {
            if any_members {
                write!(f, "|{}", "WorkgroupMemory")?;
            } else {
                write!(f, " {}", "WorkgroupMemory")?;
                any_members = true;
            }
        }
        if self.cross_workgroup_memory.is_some() {
            if any_members {
                write!(f, "|{}", "CrossWorkgroupMemory")?;
            } else {
                write!(f, " {}", "CrossWorkgroupMemory")?;
                any_members = true;
            }
        }
        if self.atomic_counter_memory.is_some() {
            if any_members {
                write!(f, "|{}", "AtomicCounterMemory")?;
            } else {
                write!(f, " {}", "AtomicCounterMemory")?;
                any_members = true;
            }
        }
        if self.image_memory.is_some() {
            if any_members {
                write!(f, "|{}", "ImageMemory")?;
            } else {
                write!(f, " {}", "ImageMemory")?;
                any_members = true;
            }
        }
        if self.output_memory.is_some() {
            if any_members {
                write!(f, "|{}", "OutputMemory")?;
            } else {
                write!(f, " {}", "OutputMemory")?;
                any_members = true;
            }
        }
        if self.output_memory_khr.is_some() {
            if any_members {
                write!(f, "|{}", "OutputMemoryKHR")?;
            } else {
                write!(f, " {}", "OutputMemoryKHR")?;
                any_members = true;
            }
        }
        if self.make_available.is_some() {
            if any_members {
                write!(f, "|{}", "MakeAvailable")?;
            } else {
                write!(f, " {}", "MakeAvailable")?;
                any_members = true;
            }
        }
        if self.make_available_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeAvailableKHR")?;
            } else {
                write!(f, " {}", "MakeAvailableKHR")?;
                any_members = true;
            }
        }
        if self.make_visible.is_some() {
            if any_members {
                write!(f, "|{}", "MakeVisible")?;
            } else {
                write!(f, " {}", "MakeVisible")?;
                any_members = true;
            }
        }
        if self.make_visible_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeVisibleKHR")?;
            } else {
                write!(f, " {}", "MakeVisibleKHR")?;
                any_members = true;
            }
        }
        if self.volatile.is_some() {
            if any_members {
                write!(f, "|{}", "Volatile")?;
            } else {
                write!(f, " {}", "Volatile")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccess {
    pub volatile: Option<MemoryAccessVolatile>,
    pub aligned: Option<MemoryAccessAligned>,
    pub nontemporal: Option<MemoryAccessNontemporal>,
    pub make_pointer_available: Option<MemoryAccessMakePointerAvailable>,
    pub make_pointer_available_khr: Option<MemoryAccessMakePointerAvailableKHR>,
    pub make_pointer_visible: Option<MemoryAccessMakePointerVisible>,
    pub make_pointer_visible_khr: Option<MemoryAccessMakePointerVisibleKHR>,
    pub non_private_pointer: Option<MemoryAccessNonPrivatePointer>,
    pub non_private_pointer_khr: Option<MemoryAccessNonPrivatePointerKHR>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessVolatile;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessAligned(pub LiteralInteger32);
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessNontemporal;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerAvailable(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerAvailableKHR(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerVisible(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerVisibleKHR(pub IdScope);
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessNonPrivatePointer;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessNonPrivatePointerKHR;
impl SPIRVParse for MemoryAccess {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (volatile, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(MemoryAccessVolatile), words)
        } else {
            (None, words)
        };
        let (aligned, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessAligned(parameter_0)), words)
        } else {
            (None, words)
        };
        let (nontemporal, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(MemoryAccessNontemporal), words)
        } else {
            (None, words)
        };
        let (make_pointer_available, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessMakePointerAvailable(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_pointer_available_khr, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (
                Some(MemoryAccessMakePointerAvailableKHR(parameter_0)),
                words,
            )
        } else {
            (None, words)
        };
        let (make_pointer_visible, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessMakePointerVisible(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_pointer_visible_khr, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessMakePointerVisibleKHR(parameter_0)), words)
        } else {
            (None, words)
        };
        let (non_private_pointer, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            (Some(MemoryAccessNonPrivatePointer), words)
        } else {
            (None, words)
        };
        let (non_private_pointer_khr, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            (Some(MemoryAccessNonPrivatePointerKHR), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    volatile,
                    aligned,
                    nontemporal,
                    make_pointer_available,
                    make_pointer_available_khr,
                    make_pointer_visible,
                    make_pointer_visible_khr,
                    non_private_pointer,
                    non_private_pointer_khr,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for MemoryAccess {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.volatile.is_some() {
            if any_members {
                write!(f, "|{}", "Volatile")?;
            } else {
                write!(f, " {}", "Volatile")?;
                any_members = true;
            }
        }
        if self.aligned.is_some() {
            if any_members {
                write!(f, "|{}", "Aligned")?;
            } else {
                write!(f, " {}", "Aligned")?;
                any_members = true;
            }
        }
        if self.nontemporal.is_some() {
            if any_members {
                write!(f, "|{}", "Nontemporal")?;
            } else {
                write!(f, " {}", "Nontemporal")?;
                any_members = true;
            }
        }
        if self.make_pointer_available.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerAvailable")?;
            } else {
                write!(f, " {}", "MakePointerAvailable")?;
                any_members = true;
            }
        }
        if self.make_pointer_available_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerAvailableKHR")?;
            } else {
                write!(f, " {}", "MakePointerAvailableKHR")?;
                any_members = true;
            }
        }
        if self.make_pointer_visible.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerVisible")?;
            } else {
                write!(f, " {}", "MakePointerVisible")?;
                any_members = true;
            }
        }
        if self.make_pointer_visible_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerVisibleKHR")?;
            } else {
                write!(f, " {}", "MakePointerVisibleKHR")?;
                any_members = true;
            }
        }
        if self.non_private_pointer.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivatePointer")?;
            } else {
                write!(f, " {}", "NonPrivatePointer")?;
                any_members = true;
            }
        }
        if self.non_private_pointer_khr.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivatePointerKHR")?;
            } else {
                write!(f, " {}", "NonPrivatePointerKHR")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        if let Some(MemoryAccessAligned(parameter_0)) = &self.aligned {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerAvailable(parameter_0)) = &self.make_pointer_available {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerAvailableKHR(parameter_0)) =
            &self.make_pointer_available_khr
        {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerVisible(parameter_0)) = &self.make_pointer_visible {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerVisibleKHR(parameter_0)) = &self.make_pointer_visible_khr
        {
            parameter_0.spirv_display(f)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct KernelProfilingInfo {
    pub cmd_exec_time: Option<KernelProfilingInfoCmdExecTime>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct KernelProfilingInfoCmdExecTime;
impl SPIRVParse for KernelProfilingInfo {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (cmd_exec_time, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(KernelProfilingInfoCmdExecTime), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((Self { cmd_exec_time }, words))
        }
    }
}
impl SPIRVDisplay for KernelProfilingInfo {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.cmd_exec_time.is_some() {
            if any_members {
                write!(f, "|{}", "CmdExecTime")?;
            } else {
                write!(f, " {}", "CmdExecTime")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SourceLanguageUnknown;
impl From<SourceLanguageUnknown> for SourceLanguage {
    fn from(v: SourceLanguageUnknown) -> Self {
        Self::Unknown(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SourceLanguageESSL;
impl From<SourceLanguageESSL> for SourceLanguage {
    fn from(v: SourceLanguageESSL) -> Self {
        Self::ESSL(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SourceLanguageGLSL;
impl From<SourceLanguageGLSL> for SourceLanguage {
    fn from(v: SourceLanguageGLSL) -> Self {
        Self::GLSL(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SourceLanguageOpenCLC;
impl From<SourceLanguageOpenCLC> for SourceLanguage {
    fn from(v: SourceLanguageOpenCLC) -> Self {
        Self::OpenCLC(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SourceLanguageOpenCLCPP;
impl From<SourceLanguageOpenCLCPP> for SourceLanguage {
    fn from(v: SourceLanguageOpenCLCPP) -> Self {
        Self::OpenCLCPP(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SourceLanguageHLSL;
impl From<SourceLanguageHLSL> for SourceLanguage {
    fn from(v: SourceLanguageHLSL) -> Self {
        Self::HLSL(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum SourceLanguage {
    Unknown(SourceLanguageUnknown),
    ESSL(SourceLanguageESSL),
    GLSL(SourceLanguageGLSL),
    OpenCLC(SourceLanguageOpenCLC),
    OpenCLCPP(SourceLanguageOpenCLCPP),
    HLSL(SourceLanguageHLSL),
}
impl SPIRVParse for SourceLanguage {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((SourceLanguage::Unknown(SourceLanguageUnknown), words)),
            1u32 => Ok((SourceLanguage::ESSL(SourceLanguageESSL), words)),
            2u32 => Ok((SourceLanguage::GLSL(SourceLanguageGLSL), words)),
            3u32 => Ok((SourceLanguage::OpenCLC(SourceLanguageOpenCLC), words)),
            4u32 => Ok((SourceLanguage::OpenCLCPP(SourceLanguageOpenCLCPP), words)),
            5u32 => Ok((SourceLanguage::HLSL(SourceLanguageHLSL), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for SourceLanguage {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SourceLanguage::Unknown(_) => write!(f, " {}", "Unknown"),
            SourceLanguage::ESSL(_) => write!(f, " {}", "ESSL"),
            SourceLanguage::GLSL(_) => write!(f, " {}", "GLSL"),
            SourceLanguage::OpenCLC(_) => write!(f, " {}", "OpenCL_C"),
            SourceLanguage::OpenCLCPP(_) => write!(f, " {}", "OpenCL_CPP"),
            SourceLanguage::HLSL(_) => write!(f, " {}", "HLSL"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelVertex;
impl From<ExecutionModelVertex> for ExecutionModel {
    fn from(v: ExecutionModelVertex) -> Self {
        Self::Vertex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelTessellationControl;
impl From<ExecutionModelTessellationControl> for ExecutionModel {
    fn from(v: ExecutionModelTessellationControl) -> Self {
        Self::TessellationControl(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelTessellationEvaluation;
impl From<ExecutionModelTessellationEvaluation> for ExecutionModel {
    fn from(v: ExecutionModelTessellationEvaluation) -> Self {
        Self::TessellationEvaluation(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelGeometry;
impl From<ExecutionModelGeometry> for ExecutionModel {
    fn from(v: ExecutionModelGeometry) -> Self {
        Self::Geometry(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelFragment;
impl From<ExecutionModelFragment> for ExecutionModel {
    fn from(v: ExecutionModelFragment) -> Self {
        Self::Fragment(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelGLCompute;
impl From<ExecutionModelGLCompute> for ExecutionModel {
    fn from(v: ExecutionModelGLCompute) -> Self {
        Self::GLCompute(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModelKernel;
impl From<ExecutionModelKernel> for ExecutionModel {
    fn from(v: ExecutionModelKernel) -> Self {
        Self::Kernel(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ExecutionModel {
    Vertex(ExecutionModelVertex),
    TessellationControl(ExecutionModelTessellationControl),
    TessellationEvaluation(ExecutionModelTessellationEvaluation),
    Geometry(ExecutionModelGeometry),
    Fragment(ExecutionModelFragment),
    GLCompute(ExecutionModelGLCompute),
    Kernel(ExecutionModelKernel),
}
impl SPIRVParse for ExecutionModel {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ExecutionModel::Vertex(ExecutionModelVertex), words)),
            1u32 => Ok((
                ExecutionModel::TessellationControl(ExecutionModelTessellationControl),
                words,
            )),
            2u32 => Ok((
                ExecutionModel::TessellationEvaluation(ExecutionModelTessellationEvaluation),
                words,
            )),
            3u32 => Ok((ExecutionModel::Geometry(ExecutionModelGeometry), words)),
            4u32 => Ok((ExecutionModel::Fragment(ExecutionModelFragment), words)),
            5u32 => Ok((ExecutionModel::GLCompute(ExecutionModelGLCompute), words)),
            6u32 => Ok((ExecutionModel::Kernel(ExecutionModelKernel), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ExecutionModel {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ExecutionModel::Vertex(_) => write!(f, " {}", "Vertex"),
            ExecutionModel::TessellationControl(_) => write!(f, " {}", "TessellationControl"),
            ExecutionModel::TessellationEvaluation(_) => write!(f, " {}", "TessellationEvaluation"),
            ExecutionModel::Geometry(_) => write!(f, " {}", "Geometry"),
            ExecutionModel::Fragment(_) => write!(f, " {}", "Fragment"),
            ExecutionModel::GLCompute(_) => write!(f, " {}", "GLCompute"),
            ExecutionModel::Kernel(_) => write!(f, " {}", "Kernel"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AddressingModelLogical;
impl From<AddressingModelLogical> for AddressingModel {
    fn from(v: AddressingModelLogical) -> Self {
        Self::Logical(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AddressingModelPhysical32;
impl From<AddressingModelPhysical32> for AddressingModel {
    fn from(v: AddressingModelPhysical32) -> Self {
        Self::Physical32(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AddressingModelPhysical64;
impl From<AddressingModelPhysical64> for AddressingModel {
    fn from(v: AddressingModelPhysical64) -> Self {
        Self::Physical64(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AddressingModelPhysicalStorageBuffer64;
impl From<AddressingModelPhysicalStorageBuffer64> for AddressingModel {
    fn from(v: AddressingModelPhysicalStorageBuffer64) -> Self {
        Self::PhysicalStorageBuffer64(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum AddressingModel {
    Logical(AddressingModelLogical),
    Physical32(AddressingModelPhysical32),
    Physical64(AddressingModelPhysical64),
    PhysicalStorageBuffer64(AddressingModelPhysicalStorageBuffer64),
}
impl SPIRVParse for AddressingModel {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((AddressingModel::Logical(AddressingModelLogical), words)),
            1u32 => Ok((
                AddressingModel::Physical32(AddressingModelPhysical32),
                words,
            )),
            2u32 => Ok((
                AddressingModel::Physical64(AddressingModelPhysical64),
                words,
            )),
            5348u32 => Ok((
                AddressingModel::PhysicalStorageBuffer64(AddressingModelPhysicalStorageBuffer64),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for AddressingModel {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AddressingModel::Logical(_) => write!(f, " {}", "Logical"),
            AddressingModel::Physical32(_) => write!(f, " {}", "Physical32"),
            AddressingModel::Physical64(_) => write!(f, " {}", "Physical64"),
            AddressingModel::PhysicalStorageBuffer64(_) => {
                write!(f, " {}", "PhysicalStorageBuffer64")
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct MemoryModelSimple;
impl From<MemoryModelSimple> for MemoryModel {
    fn from(v: MemoryModelSimple) -> Self {
        Self::Simple(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct MemoryModelGLSL450;
impl From<MemoryModelGLSL450> for MemoryModel {
    fn from(v: MemoryModelGLSL450) -> Self {
        Self::GLSL450(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct MemoryModelOpenCL;
impl From<MemoryModelOpenCL> for MemoryModel {
    fn from(v: MemoryModelOpenCL) -> Self {
        Self::OpenCL(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct MemoryModelVulkan;
impl From<MemoryModelVulkan> for MemoryModel {
    fn from(v: MemoryModelVulkan) -> Self {
        Self::Vulkan(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum MemoryModel {
    Simple(MemoryModelSimple),
    GLSL450(MemoryModelGLSL450),
    OpenCL(MemoryModelOpenCL),
    Vulkan(MemoryModelVulkan),
}
impl SPIRVParse for MemoryModel {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((MemoryModel::Simple(MemoryModelSimple), words)),
            1u32 => Ok((MemoryModel::GLSL450(MemoryModelGLSL450), words)),
            2u32 => Ok((MemoryModel::OpenCL(MemoryModelOpenCL), words)),
            3u32 => Ok((MemoryModel::Vulkan(MemoryModelVulkan), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for MemoryModel {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MemoryModel::Simple(_) => write!(f, " {}", "Simple"),
            MemoryModel::GLSL450(_) => write!(f, " {}", "GLSL450"),
            MemoryModel::OpenCL(_) => write!(f, " {}", "OpenCL"),
            MemoryModel::Vulkan(_) => write!(f, " {}", "Vulkan"),
        }
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeInvocations {
    pub number_of_invocation_invocations: LiteralInteger32,
}
impl From<ExecutionModeInvocations> for ExecutionMode {
    fn from(v: ExecutionModeInvocations) -> Self {
        Self::Invocations(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeSpacingEqual;
impl From<ExecutionModeSpacingEqual> for ExecutionMode {
    fn from(v: ExecutionModeSpacingEqual) -> Self {
        Self::SpacingEqual(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeSpacingFractionalEven;
impl From<ExecutionModeSpacingFractionalEven> for ExecutionMode {
    fn from(v: ExecutionModeSpacingFractionalEven) -> Self {
        Self::SpacingFractionalEven(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeSpacingFractionalOdd;
impl From<ExecutionModeSpacingFractionalOdd> for ExecutionMode {
    fn from(v: ExecutionModeSpacingFractionalOdd) -> Self {
        Self::SpacingFractionalOdd(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeVertexOrderCw;
impl From<ExecutionModeVertexOrderCw> for ExecutionMode {
    fn from(v: ExecutionModeVertexOrderCw) -> Self {
        Self::VertexOrderCw(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeVertexOrderCcw;
impl From<ExecutionModeVertexOrderCcw> for ExecutionMode {
    fn from(v: ExecutionModeVertexOrderCcw) -> Self {
        Self::VertexOrderCcw(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModePixelCenterInteger;
impl From<ExecutionModePixelCenterInteger> for ExecutionMode {
    fn from(v: ExecutionModePixelCenterInteger) -> Self {
        Self::PixelCenterInteger(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeOriginUpperLeft;
impl From<ExecutionModeOriginUpperLeft> for ExecutionMode {
    fn from(v: ExecutionModeOriginUpperLeft) -> Self {
        Self::OriginUpperLeft(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeOriginLowerLeft;
impl From<ExecutionModeOriginLowerLeft> for ExecutionMode {
    fn from(v: ExecutionModeOriginLowerLeft) -> Self {
        Self::OriginLowerLeft(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeEarlyFragmentTests;
impl From<ExecutionModeEarlyFragmentTests> for ExecutionMode {
    fn from(v: ExecutionModeEarlyFragmentTests) -> Self {
        Self::EarlyFragmentTests(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModePointMode;
impl From<ExecutionModePointMode> for ExecutionMode {
    fn from(v: ExecutionModePointMode) -> Self {
        Self::PointMode(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeXfb;
impl From<ExecutionModeXfb> for ExecutionMode {
    fn from(v: ExecutionModeXfb) -> Self {
        Self::Xfb(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeDepthReplacing;
impl From<ExecutionModeDepthReplacing> for ExecutionMode {
    fn from(v: ExecutionModeDepthReplacing) -> Self {
        Self::DepthReplacing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeDepthGreater;
impl From<ExecutionModeDepthGreater> for ExecutionMode {
    fn from(v: ExecutionModeDepthGreater) -> Self {
        Self::DepthGreater(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeDepthLess;
impl From<ExecutionModeDepthLess> for ExecutionMode {
    fn from(v: ExecutionModeDepthLess) -> Self {
        Self::DepthLess(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeDepthUnchanged;
impl From<ExecutionModeDepthUnchanged> for ExecutionMode {
    fn from(v: ExecutionModeDepthUnchanged) -> Self {
        Self::DepthUnchanged(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeLocalSize {
    pub x_size: LiteralInteger32,
    pub y_size: LiteralInteger32,
    pub z_size: LiteralInteger32,
}
impl From<ExecutionModeLocalSize> for ExecutionMode {
    fn from(v: ExecutionModeLocalSize) -> Self {
        Self::LocalSize(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeLocalSizeHint {
    pub x_size: LiteralInteger32,
    pub y_size: LiteralInteger32,
    pub z_size: LiteralInteger32,
}
impl From<ExecutionModeLocalSizeHint> for ExecutionMode {
    fn from(v: ExecutionModeLocalSizeHint) -> Self {
        Self::LocalSizeHint(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeInputPoints;
impl From<ExecutionModeInputPoints> for ExecutionMode {
    fn from(v: ExecutionModeInputPoints) -> Self {
        Self::InputPoints(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeInputLines;
impl From<ExecutionModeInputLines> for ExecutionMode {
    fn from(v: ExecutionModeInputLines) -> Self {
        Self::InputLines(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeInputLinesAdjacency;
impl From<ExecutionModeInputLinesAdjacency> for ExecutionMode {
    fn from(v: ExecutionModeInputLinesAdjacency) -> Self {
        Self::InputLinesAdjacency(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeTriangles;
impl From<ExecutionModeTriangles> for ExecutionMode {
    fn from(v: ExecutionModeTriangles) -> Self {
        Self::Triangles(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeInputTrianglesAdjacency;
impl From<ExecutionModeInputTrianglesAdjacency> for ExecutionMode {
    fn from(v: ExecutionModeInputTrianglesAdjacency) -> Self {
        Self::InputTrianglesAdjacency(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeQuads;
impl From<ExecutionModeQuads> for ExecutionMode {
    fn from(v: ExecutionModeQuads) -> Self {
        Self::Quads(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeIsolines;
impl From<ExecutionModeIsolines> for ExecutionMode {
    fn from(v: ExecutionModeIsolines) -> Self {
        Self::Isolines(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeOutputVertices {
    pub vertex_count: LiteralInteger32,
}
impl From<ExecutionModeOutputVertices> for ExecutionMode {
    fn from(v: ExecutionModeOutputVertices) -> Self {
        Self::OutputVertices(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeOutputPoints;
impl From<ExecutionModeOutputPoints> for ExecutionMode {
    fn from(v: ExecutionModeOutputPoints) -> Self {
        Self::OutputPoints(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeOutputLineStrip;
impl From<ExecutionModeOutputLineStrip> for ExecutionMode {
    fn from(v: ExecutionModeOutputLineStrip) -> Self {
        Self::OutputLineStrip(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeOutputTriangleStrip;
impl From<ExecutionModeOutputTriangleStrip> for ExecutionMode {
    fn from(v: ExecutionModeOutputTriangleStrip) -> Self {
        Self::OutputTriangleStrip(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeVecTypeHint {
    pub vector_type: LiteralInteger32,
}
impl From<ExecutionModeVecTypeHint> for ExecutionMode {
    fn from(v: ExecutionModeVecTypeHint) -> Self {
        Self::VecTypeHint(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeContractionOff;
impl From<ExecutionModeContractionOff> for ExecutionMode {
    fn from(v: ExecutionModeContractionOff) -> Self {
        Self::ContractionOff(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeInitializer;
impl From<ExecutionModeInitializer> for ExecutionMode {
    fn from(v: ExecutionModeInitializer) -> Self {
        Self::Initializer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ExecutionModeFinalizer;
impl From<ExecutionModeFinalizer> for ExecutionMode {
    fn from(v: ExecutionModeFinalizer) -> Self {
        Self::Finalizer(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeSubgroupSize {
    pub subgroup_size: LiteralInteger32,
}
impl From<ExecutionModeSubgroupSize> for ExecutionMode {
    fn from(v: ExecutionModeSubgroupSize) -> Self {
        Self::SubgroupSize(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeSubgroupsPerWorkgroup {
    pub subgroups_per_workgroup: LiteralInteger32,
}
impl From<ExecutionModeSubgroupsPerWorkgroup> for ExecutionMode {
    fn from(v: ExecutionModeSubgroupsPerWorkgroup) -> Self {
        Self::SubgroupsPerWorkgroup(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeSubgroupsPerWorkgroupId {
    pub subgroups_per_workgroup: IdRef,
}
impl From<ExecutionModeSubgroupsPerWorkgroupId> for ExecutionMode {
    fn from(v: ExecutionModeSubgroupsPerWorkgroupId) -> Self {
        Self::SubgroupsPerWorkgroupId(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeLocalSizeId {
    pub x_size: IdRef,
    pub y_size: IdRef,
    pub z_size: IdRef,
}
impl From<ExecutionModeLocalSizeId> for ExecutionMode {
    fn from(v: ExecutionModeLocalSizeId) -> Self {
        Self::LocalSizeId(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeLocalSizeHintId {
    pub local_size_hint: IdRef,
}
impl From<ExecutionModeLocalSizeHintId> for ExecutionMode {
    fn from(v: ExecutionModeLocalSizeHintId) -> Self {
        Self::LocalSizeHintId(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeDenormPreserve {
    pub target_width: LiteralInteger32,
}
impl From<ExecutionModeDenormPreserve> for ExecutionMode {
    fn from(v: ExecutionModeDenormPreserve) -> Self {
        Self::DenormPreserve(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeDenormFlushToZero {
    pub target_width: LiteralInteger32,
}
impl From<ExecutionModeDenormFlushToZero> for ExecutionMode {
    fn from(v: ExecutionModeDenormFlushToZero) -> Self {
        Self::DenormFlushToZero(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeSignedZeroInfNanPreserve {
    pub target_width: LiteralInteger32,
}
impl From<ExecutionModeSignedZeroInfNanPreserve> for ExecutionMode {
    fn from(v: ExecutionModeSignedZeroInfNanPreserve) -> Self {
        Self::SignedZeroInfNanPreserve(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeRoundingModeRTE {
    pub target_width: LiteralInteger32,
}
impl From<ExecutionModeRoundingModeRTE> for ExecutionMode {
    fn from(v: ExecutionModeRoundingModeRTE) -> Self {
        Self::RoundingModeRTE(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct ExecutionModeRoundingModeRTZ {
    pub target_width: LiteralInteger32,
}
impl From<ExecutionModeRoundingModeRTZ> for ExecutionMode {
    fn from(v: ExecutionModeRoundingModeRTZ) -> Self {
        Self::RoundingModeRTZ(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub enum ExecutionMode {
    Invocations(ExecutionModeInvocations),
    SpacingEqual(ExecutionModeSpacingEqual),
    SpacingFractionalEven(ExecutionModeSpacingFractionalEven),
    SpacingFractionalOdd(ExecutionModeSpacingFractionalOdd),
    VertexOrderCw(ExecutionModeVertexOrderCw),
    VertexOrderCcw(ExecutionModeVertexOrderCcw),
    PixelCenterInteger(ExecutionModePixelCenterInteger),
    OriginUpperLeft(ExecutionModeOriginUpperLeft),
    OriginLowerLeft(ExecutionModeOriginLowerLeft),
    EarlyFragmentTests(ExecutionModeEarlyFragmentTests),
    PointMode(ExecutionModePointMode),
    Xfb(ExecutionModeXfb),
    DepthReplacing(ExecutionModeDepthReplacing),
    DepthGreater(ExecutionModeDepthGreater),
    DepthLess(ExecutionModeDepthLess),
    DepthUnchanged(ExecutionModeDepthUnchanged),
    LocalSize(ExecutionModeLocalSize),
    LocalSizeHint(ExecutionModeLocalSizeHint),
    InputPoints(ExecutionModeInputPoints),
    InputLines(ExecutionModeInputLines),
    InputLinesAdjacency(ExecutionModeInputLinesAdjacency),
    Triangles(ExecutionModeTriangles),
    InputTrianglesAdjacency(ExecutionModeInputTrianglesAdjacency),
    Quads(ExecutionModeQuads),
    Isolines(ExecutionModeIsolines),
    OutputVertices(ExecutionModeOutputVertices),
    OutputPoints(ExecutionModeOutputPoints),
    OutputLineStrip(ExecutionModeOutputLineStrip),
    OutputTriangleStrip(ExecutionModeOutputTriangleStrip),
    VecTypeHint(ExecutionModeVecTypeHint),
    ContractionOff(ExecutionModeContractionOff),
    Initializer(ExecutionModeInitializer),
    Finalizer(ExecutionModeFinalizer),
    SubgroupSize(ExecutionModeSubgroupSize),
    SubgroupsPerWorkgroup(ExecutionModeSubgroupsPerWorkgroup),
    SubgroupsPerWorkgroupId(ExecutionModeSubgroupsPerWorkgroupId),
    LocalSizeId(ExecutionModeLocalSizeId),
    LocalSizeHintId(ExecutionModeLocalSizeHintId),
    DenormPreserve(ExecutionModeDenormPreserve),
    DenormFlushToZero(ExecutionModeDenormFlushToZero),
    SignedZeroInfNanPreserve(ExecutionModeSignedZeroInfNanPreserve),
    RoundingModeRTE(ExecutionModeRoundingModeRTE),
    RoundingModeRTZ(ExecutionModeRoundingModeRTZ),
}
impl SPIRVParse for ExecutionMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => {
                let (number_of_invocation_invocations, words) =
                    LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::Invocations(ExecutionModeInvocations {
                        number_of_invocation_invocations,
                    }),
                    words,
                ))
            }
            1u32 => Ok((
                ExecutionMode::SpacingEqual(ExecutionModeSpacingEqual),
                words,
            )),
            2u32 => Ok((
                ExecutionMode::SpacingFractionalEven(ExecutionModeSpacingFractionalEven),
                words,
            )),
            3u32 => Ok((
                ExecutionMode::SpacingFractionalOdd(ExecutionModeSpacingFractionalOdd),
                words,
            )),
            4u32 => Ok((
                ExecutionMode::VertexOrderCw(ExecutionModeVertexOrderCw),
                words,
            )),
            5u32 => Ok((
                ExecutionMode::VertexOrderCcw(ExecutionModeVertexOrderCcw),
                words,
            )),
            6u32 => Ok((
                ExecutionMode::PixelCenterInteger(ExecutionModePixelCenterInteger),
                words,
            )),
            7u32 => Ok((
                ExecutionMode::OriginUpperLeft(ExecutionModeOriginUpperLeft),
                words,
            )),
            8u32 => Ok((
                ExecutionMode::OriginLowerLeft(ExecutionModeOriginLowerLeft),
                words,
            )),
            9u32 => Ok((
                ExecutionMode::EarlyFragmentTests(ExecutionModeEarlyFragmentTests),
                words,
            )),
            10u32 => Ok((ExecutionMode::PointMode(ExecutionModePointMode), words)),
            11u32 => Ok((ExecutionMode::Xfb(ExecutionModeXfb), words)),
            12u32 => Ok((
                ExecutionMode::DepthReplacing(ExecutionModeDepthReplacing),
                words,
            )),
            14u32 => Ok((
                ExecutionMode::DepthGreater(ExecutionModeDepthGreater),
                words,
            )),
            15u32 => Ok((ExecutionMode::DepthLess(ExecutionModeDepthLess), words)),
            16u32 => Ok((
                ExecutionMode::DepthUnchanged(ExecutionModeDepthUnchanged),
                words,
            )),
            17u32 => {
                let (x_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (y_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (z_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSize(ExecutionModeLocalSize {
                        x_size,
                        y_size,
                        z_size,
                    }),
                    words,
                ))
            }
            18u32 => {
                let (x_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (y_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (z_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSizeHint(ExecutionModeLocalSizeHint {
                        x_size,
                        y_size,
                        z_size,
                    }),
                    words,
                ))
            }
            19u32 => Ok((ExecutionMode::InputPoints(ExecutionModeInputPoints), words)),
            20u32 => Ok((ExecutionMode::InputLines(ExecutionModeInputLines), words)),
            21u32 => Ok((
                ExecutionMode::InputLinesAdjacency(ExecutionModeInputLinesAdjacency),
                words,
            )),
            22u32 => Ok((ExecutionMode::Triangles(ExecutionModeTriangles), words)),
            23u32 => Ok((
                ExecutionMode::InputTrianglesAdjacency(ExecutionModeInputTrianglesAdjacency),
                words,
            )),
            24u32 => Ok((ExecutionMode::Quads(ExecutionModeQuads), words)),
            25u32 => Ok((ExecutionMode::Isolines(ExecutionModeIsolines), words)),
            26u32 => {
                let (vertex_count, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::OutputVertices(ExecutionModeOutputVertices { vertex_count }),
                    words,
                ))
            }
            27u32 => Ok((
                ExecutionMode::OutputPoints(ExecutionModeOutputPoints),
                words,
            )),
            28u32 => Ok((
                ExecutionMode::OutputLineStrip(ExecutionModeOutputLineStrip),
                words,
            )),
            29u32 => Ok((
                ExecutionMode::OutputTriangleStrip(ExecutionModeOutputTriangleStrip),
                words,
            )),
            30u32 => {
                let (vector_type, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::VecTypeHint(ExecutionModeVecTypeHint { vector_type }),
                    words,
                ))
            }
            31u32 => Ok((
                ExecutionMode::ContractionOff(ExecutionModeContractionOff),
                words,
            )),
            33u32 => Ok((ExecutionMode::Initializer(ExecutionModeInitializer), words)),
            34u32 => Ok((ExecutionMode::Finalizer(ExecutionModeFinalizer), words)),
            35u32 => {
                let (subgroup_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SubgroupSize(ExecutionModeSubgroupSize { subgroup_size }),
                    words,
                ))
            }
            36u32 => {
                let (subgroups_per_workgroup, words) =
                    LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SubgroupsPerWorkgroup(ExecutionModeSubgroupsPerWorkgroup {
                        subgroups_per_workgroup,
                    }),
                    words,
                ))
            }
            37u32 => {
                let (subgroups_per_workgroup, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SubgroupsPerWorkgroupId(ExecutionModeSubgroupsPerWorkgroupId {
                        subgroups_per_workgroup,
                    }),
                    words,
                ))
            }
            38u32 => {
                let (x_size, words) = IdRef::spirv_parse(words, parse_state)?;
                let (y_size, words) = IdRef::spirv_parse(words, parse_state)?;
                let (z_size, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSizeId(ExecutionModeLocalSizeId {
                        x_size,
                        y_size,
                        z_size,
                    }),
                    words,
                ))
            }
            39u32 => {
                let (local_size_hint, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSizeHintId(ExecutionModeLocalSizeHintId {
                        local_size_hint,
                    }),
                    words,
                ))
            }
            4459u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::DenormPreserve(ExecutionModeDenormPreserve { target_width }),
                    words,
                ))
            }
            4460u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::DenormFlushToZero(ExecutionModeDenormFlushToZero {
                        target_width,
                    }),
                    words,
                ))
            }
            4461u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SignedZeroInfNanPreserve(
                        ExecutionModeSignedZeroInfNanPreserve { target_width },
                    ),
                    words,
                ))
            }
            4462u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::RoundingModeRTE(ExecutionModeRoundingModeRTE { target_width }),
                    words,
                ))
            }
            4463u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::RoundingModeRTZ(ExecutionModeRoundingModeRTZ { target_width }),
                    words,
                ))
            }
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ExecutionMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ExecutionMode::Invocations(ExecutionModeInvocations {
                number_of_invocation_invocations,
            }) => {
                write!(f, " {}", "Invocations")?;
                number_of_invocation_invocations.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SpacingEqual(_) => write!(f, " {}", "SpacingEqual"),
            ExecutionMode::SpacingFractionalEven(_) => write!(f, " {}", "SpacingFractionalEven"),
            ExecutionMode::SpacingFractionalOdd(_) => write!(f, " {}", "SpacingFractionalOdd"),
            ExecutionMode::VertexOrderCw(_) => write!(f, " {}", "VertexOrderCw"),
            ExecutionMode::VertexOrderCcw(_) => write!(f, " {}", "VertexOrderCcw"),
            ExecutionMode::PixelCenterInteger(_) => write!(f, " {}", "PixelCenterInteger"),
            ExecutionMode::OriginUpperLeft(_) => write!(f, " {}", "OriginUpperLeft"),
            ExecutionMode::OriginLowerLeft(_) => write!(f, " {}", "OriginLowerLeft"),
            ExecutionMode::EarlyFragmentTests(_) => write!(f, " {}", "EarlyFragmentTests"),
            ExecutionMode::PointMode(_) => write!(f, " {}", "PointMode"),
            ExecutionMode::Xfb(_) => write!(f, " {}", "Xfb"),
            ExecutionMode::DepthReplacing(_) => write!(f, " {}", "DepthReplacing"),
            ExecutionMode::DepthGreater(_) => write!(f, " {}", "DepthGreater"),
            ExecutionMode::DepthLess(_) => write!(f, " {}", "DepthLess"),
            ExecutionMode::DepthUnchanged(_) => write!(f, " {}", "DepthUnchanged"),
            ExecutionMode::LocalSize(ExecutionModeLocalSize {
                x_size,
                y_size,
                z_size,
            }) => {
                write!(f, " {}", "LocalSize")?;
                x_size.spirv_display(f)?;
                y_size.spirv_display(f)?;
                z_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::LocalSizeHint(ExecutionModeLocalSizeHint {
                x_size,
                y_size,
                z_size,
            }) => {
                write!(f, " {}", "LocalSizeHint")?;
                x_size.spirv_display(f)?;
                y_size.spirv_display(f)?;
                z_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::InputPoints(_) => write!(f, " {}", "InputPoints"),
            ExecutionMode::InputLines(_) => write!(f, " {}", "InputLines"),
            ExecutionMode::InputLinesAdjacency(_) => write!(f, " {}", "InputLinesAdjacency"),
            ExecutionMode::Triangles(_) => write!(f, " {}", "Triangles"),
            ExecutionMode::InputTrianglesAdjacency(_) => {
                write!(f, " {}", "InputTrianglesAdjacency")
            }
            ExecutionMode::Quads(_) => write!(f, " {}", "Quads"),
            ExecutionMode::Isolines(_) => write!(f, " {}", "Isolines"),
            ExecutionMode::OutputVertices(ExecutionModeOutputVertices { vertex_count }) => {
                write!(f, " {}", "OutputVertices")?;
                vertex_count.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::OutputPoints(_) => write!(f, " {}", "OutputPoints"),
            ExecutionMode::OutputLineStrip(_) => write!(f, " {}", "OutputLineStrip"),
            ExecutionMode::OutputTriangleStrip(_) => write!(f, " {}", "OutputTriangleStrip"),
            ExecutionMode::VecTypeHint(ExecutionModeVecTypeHint { vector_type }) => {
                write!(f, " {}", "VecTypeHint")?;
                vector_type.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::ContractionOff(_) => write!(f, " {}", "ContractionOff"),
            ExecutionMode::Initializer(_) => write!(f, " {}", "Initializer"),
            ExecutionMode::Finalizer(_) => write!(f, " {}", "Finalizer"),
            ExecutionMode::SubgroupSize(ExecutionModeSubgroupSize { subgroup_size }) => {
                write!(f, " {}", "SubgroupSize")?;
                subgroup_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SubgroupsPerWorkgroup(ExecutionModeSubgroupsPerWorkgroup {
                subgroups_per_workgroup,
            }) => {
                write!(f, " {}", "SubgroupsPerWorkgroup")?;
                subgroups_per_workgroup.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SubgroupsPerWorkgroupId(ExecutionModeSubgroupsPerWorkgroupId {
                subgroups_per_workgroup,
            }) => {
                write!(f, " {}", "SubgroupsPerWorkgroupId")?;
                subgroups_per_workgroup.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::LocalSizeId(ExecutionModeLocalSizeId {
                x_size,
                y_size,
                z_size,
            }) => {
                write!(f, " {}", "LocalSizeId")?;
                x_size.spirv_display(f)?;
                y_size.spirv_display(f)?;
                z_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::LocalSizeHintId(ExecutionModeLocalSizeHintId { local_size_hint }) => {
                write!(f, " {}", "LocalSizeHintId")?;
                local_size_hint.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::DenormPreserve(ExecutionModeDenormPreserve { target_width }) => {
                write!(f, " {}", "DenormPreserve")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::DenormFlushToZero(ExecutionModeDenormFlushToZero { target_width }) => {
                write!(f, " {}", "DenormFlushToZero")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SignedZeroInfNanPreserve(ExecutionModeSignedZeroInfNanPreserve {
                target_width,
            }) => {
                write!(f, " {}", "SignedZeroInfNanPreserve")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::RoundingModeRTE(ExecutionModeRoundingModeRTE { target_width }) => {
                write!(f, " {}", "RoundingModeRTE")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::RoundingModeRTZ(ExecutionModeRoundingModeRTZ { target_width }) => {
                write!(f, " {}", "RoundingModeRTZ")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassUniformConstant;
impl From<StorageClassUniformConstant> for StorageClass {
    fn from(v: StorageClassUniformConstant) -> Self {
        Self::UniformConstant(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassInput;
impl From<StorageClassInput> for StorageClass {
    fn from(v: StorageClassInput) -> Self {
        Self::Input(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassUniform;
impl From<StorageClassUniform> for StorageClass {
    fn from(v: StorageClassUniform) -> Self {
        Self::Uniform(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassOutput;
impl From<StorageClassOutput> for StorageClass {
    fn from(v: StorageClassOutput) -> Self {
        Self::Output(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassWorkgroup;
impl From<StorageClassWorkgroup> for StorageClass {
    fn from(v: StorageClassWorkgroup) -> Self {
        Self::Workgroup(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassCrossWorkgroup;
impl From<StorageClassCrossWorkgroup> for StorageClass {
    fn from(v: StorageClassCrossWorkgroup) -> Self {
        Self::CrossWorkgroup(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassPrivate;
impl From<StorageClassPrivate> for StorageClass {
    fn from(v: StorageClassPrivate) -> Self {
        Self::Private(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassFunction;
impl From<StorageClassFunction> for StorageClass {
    fn from(v: StorageClassFunction) -> Self {
        Self::Function(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassGeneric;
impl From<StorageClassGeneric> for StorageClass {
    fn from(v: StorageClassGeneric) -> Self {
        Self::Generic(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassPushConstant;
impl From<StorageClassPushConstant> for StorageClass {
    fn from(v: StorageClassPushConstant) -> Self {
        Self::PushConstant(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassAtomicCounter;
impl From<StorageClassAtomicCounter> for StorageClass {
    fn from(v: StorageClassAtomicCounter) -> Self {
        Self::AtomicCounter(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassImage;
impl From<StorageClassImage> for StorageClass {
    fn from(v: StorageClassImage) -> Self {
        Self::Image(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassStorageBuffer;
impl From<StorageClassStorageBuffer> for StorageClass {
    fn from(v: StorageClassStorageBuffer) -> Self {
        Self::StorageBuffer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct StorageClassPhysicalStorageBuffer;
impl From<StorageClassPhysicalStorageBuffer> for StorageClass {
    fn from(v: StorageClassPhysicalStorageBuffer) -> Self {
        Self::PhysicalStorageBuffer(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum StorageClass {
    UniformConstant(StorageClassUniformConstant),
    Input(StorageClassInput),
    Uniform(StorageClassUniform),
    Output(StorageClassOutput),
    Workgroup(StorageClassWorkgroup),
    CrossWorkgroup(StorageClassCrossWorkgroup),
    Private(StorageClassPrivate),
    Function(StorageClassFunction),
    Generic(StorageClassGeneric),
    PushConstant(StorageClassPushConstant),
    AtomicCounter(StorageClassAtomicCounter),
    Image(StorageClassImage),
    StorageBuffer(StorageClassStorageBuffer),
    PhysicalStorageBuffer(StorageClassPhysicalStorageBuffer),
}
impl SPIRVParse for StorageClass {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((
                StorageClass::UniformConstant(StorageClassUniformConstant),
                words,
            )),
            1u32 => Ok((StorageClass::Input(StorageClassInput), words)),
            2u32 => Ok((StorageClass::Uniform(StorageClassUniform), words)),
            3u32 => Ok((StorageClass::Output(StorageClassOutput), words)),
            4u32 => Ok((StorageClass::Workgroup(StorageClassWorkgroup), words)),
            5u32 => Ok((
                StorageClass::CrossWorkgroup(StorageClassCrossWorkgroup),
                words,
            )),
            6u32 => Ok((StorageClass::Private(StorageClassPrivate), words)),
            7u32 => Ok((StorageClass::Function(StorageClassFunction), words)),
            8u32 => Ok((StorageClass::Generic(StorageClassGeneric), words)),
            9u32 => Ok((StorageClass::PushConstant(StorageClassPushConstant), words)),
            10u32 => Ok((
                StorageClass::AtomicCounter(StorageClassAtomicCounter),
                words,
            )),
            11u32 => Ok((StorageClass::Image(StorageClassImage), words)),
            12u32 => Ok((
                StorageClass::StorageBuffer(StorageClassStorageBuffer),
                words,
            )),
            5349u32 => Ok((
                StorageClass::PhysicalStorageBuffer(StorageClassPhysicalStorageBuffer),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for StorageClass {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            StorageClass::UniformConstant(_) => write!(f, " {}", "UniformConstant"),
            StorageClass::Input(_) => write!(f, " {}", "Input"),
            StorageClass::Uniform(_) => write!(f, " {}", "Uniform"),
            StorageClass::Output(_) => write!(f, " {}", "Output"),
            StorageClass::Workgroup(_) => write!(f, " {}", "Workgroup"),
            StorageClass::CrossWorkgroup(_) => write!(f, " {}", "CrossWorkgroup"),
            StorageClass::Private(_) => write!(f, " {}", "Private"),
            StorageClass::Function(_) => write!(f, " {}", "Function"),
            StorageClass::Generic(_) => write!(f, " {}", "Generic"),
            StorageClass::PushConstant(_) => write!(f, " {}", "PushConstant"),
            StorageClass::AtomicCounter(_) => write!(f, " {}", "AtomicCounter"),
            StorageClass::Image(_) => write!(f, " {}", "Image"),
            StorageClass::StorageBuffer(_) => write!(f, " {}", "StorageBuffer"),
            StorageClass::PhysicalStorageBuffer(_) => write!(f, " {}", "PhysicalStorageBuffer"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct Dim1D;
impl From<Dim1D> for Dim {
    fn from(v: Dim1D) -> Self {
        Self::Dim1D(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct Dim2D;
impl From<Dim2D> for Dim {
    fn from(v: Dim2D) -> Self {
        Self::Dim2D(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct Dim3D;
impl From<Dim3D> for Dim {
    fn from(v: Dim3D) -> Self {
        Self::Dim3D(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DimCube;
impl From<DimCube> for Dim {
    fn from(v: DimCube) -> Self {
        Self::Cube(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DimRect;
impl From<DimRect> for Dim {
    fn from(v: DimRect) -> Self {
        Self::Rect(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DimBuffer;
impl From<DimBuffer> for Dim {
    fn from(v: DimBuffer) -> Self {
        Self::Buffer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DimSubpassData;
impl From<DimSubpassData> for Dim {
    fn from(v: DimSubpassData) -> Self {
        Self::SubpassData(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum Dim {
    Dim1D(Dim1D),
    Dim2D(Dim2D),
    Dim3D(Dim3D),
    Cube(DimCube),
    Rect(DimRect),
    Buffer(DimBuffer),
    SubpassData(DimSubpassData),
}
impl SPIRVParse for Dim {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Dim::Dim1D(Dim1D), words)),
            1u32 => Ok((Dim::Dim2D(Dim2D), words)),
            2u32 => Ok((Dim::Dim3D(Dim3D), words)),
            3u32 => Ok((Dim::Cube(DimCube), words)),
            4u32 => Ok((Dim::Rect(DimRect), words)),
            5u32 => Ok((Dim::Buffer(DimBuffer), words)),
            6u32 => Ok((Dim::SubpassData(DimSubpassData), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Dim {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Dim::Dim1D(_) => write!(f, " {}", "1D"),
            Dim::Dim2D(_) => write!(f, " {}", "2D"),
            Dim::Dim3D(_) => write!(f, " {}", "3D"),
            Dim::Cube(_) => write!(f, " {}", "Cube"),
            Dim::Rect(_) => write!(f, " {}", "Rect"),
            Dim::Buffer(_) => write!(f, " {}", "Buffer"),
            Dim::SubpassData(_) => write!(f, " {}", "SubpassData"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerAddressingModeNone;
impl From<SamplerAddressingModeNone> for SamplerAddressingMode {
    fn from(v: SamplerAddressingModeNone) -> Self {
        Self::None(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerAddressingModeClampToEdge;
impl From<SamplerAddressingModeClampToEdge> for SamplerAddressingMode {
    fn from(v: SamplerAddressingModeClampToEdge) -> Self {
        Self::ClampToEdge(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerAddressingModeClamp;
impl From<SamplerAddressingModeClamp> for SamplerAddressingMode {
    fn from(v: SamplerAddressingModeClamp) -> Self {
        Self::Clamp(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerAddressingModeRepeat;
impl From<SamplerAddressingModeRepeat> for SamplerAddressingMode {
    fn from(v: SamplerAddressingModeRepeat) -> Self {
        Self::Repeat(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerAddressingModeRepeatMirrored;
impl From<SamplerAddressingModeRepeatMirrored> for SamplerAddressingMode {
    fn from(v: SamplerAddressingModeRepeatMirrored) -> Self {
        Self::RepeatMirrored(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum SamplerAddressingMode {
    None(SamplerAddressingModeNone),
    ClampToEdge(SamplerAddressingModeClampToEdge),
    Clamp(SamplerAddressingModeClamp),
    Repeat(SamplerAddressingModeRepeat),
    RepeatMirrored(SamplerAddressingModeRepeatMirrored),
}
impl SPIRVParse for SamplerAddressingMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((
                SamplerAddressingMode::None(SamplerAddressingModeNone),
                words,
            )),
            1u32 => Ok((
                SamplerAddressingMode::ClampToEdge(SamplerAddressingModeClampToEdge),
                words,
            )),
            2u32 => Ok((
                SamplerAddressingMode::Clamp(SamplerAddressingModeClamp),
                words,
            )),
            3u32 => Ok((
                SamplerAddressingMode::Repeat(SamplerAddressingModeRepeat),
                words,
            )),
            4u32 => Ok((
                SamplerAddressingMode::RepeatMirrored(SamplerAddressingModeRepeatMirrored),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for SamplerAddressingMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SamplerAddressingMode::None(_) => write!(f, " {}", "None"),
            SamplerAddressingMode::ClampToEdge(_) => write!(f, " {}", "ClampToEdge"),
            SamplerAddressingMode::Clamp(_) => write!(f, " {}", "Clamp"),
            SamplerAddressingMode::Repeat(_) => write!(f, " {}", "Repeat"),
            SamplerAddressingMode::RepeatMirrored(_) => write!(f, " {}", "RepeatMirrored"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerFilterModeNearest;
impl From<SamplerFilterModeNearest> for SamplerFilterMode {
    fn from(v: SamplerFilterModeNearest) -> Self {
        Self::Nearest(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct SamplerFilterModeLinear;
impl From<SamplerFilterModeLinear> for SamplerFilterMode {
    fn from(v: SamplerFilterModeLinear) -> Self {
        Self::Linear(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum SamplerFilterMode {
    Nearest(SamplerFilterModeNearest),
    Linear(SamplerFilterModeLinear),
}
impl SPIRVParse for SamplerFilterMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((SamplerFilterMode::Nearest(SamplerFilterModeNearest), words)),
            1u32 => Ok((SamplerFilterMode::Linear(SamplerFilterModeLinear), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for SamplerFilterMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SamplerFilterMode::Nearest(_) => write!(f, " {}", "Nearest"),
            SamplerFilterMode::Linear(_) => write!(f, " {}", "Linear"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatUnknown;
impl From<ImageFormatUnknown> for ImageFormat {
    fn from(v: ImageFormatUnknown) -> Self {
        Self::Unknown(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba32f;
impl From<ImageFormatRgba32f> for ImageFormat {
    fn from(v: ImageFormatRgba32f) -> Self {
        Self::Rgba32f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba16f;
impl From<ImageFormatRgba16f> for ImageFormat {
    fn from(v: ImageFormatRgba16f) -> Self {
        Self::Rgba16f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR32f;
impl From<ImageFormatR32f> for ImageFormat {
    fn from(v: ImageFormatR32f) -> Self {
        Self::R32f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba8;
impl From<ImageFormatRgba8> for ImageFormat {
    fn from(v: ImageFormatRgba8) -> Self {
        Self::Rgba8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba8Snorm;
impl From<ImageFormatRgba8Snorm> for ImageFormat {
    fn from(v: ImageFormatRgba8Snorm) -> Self {
        Self::Rgba8Snorm(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg32f;
impl From<ImageFormatRg32f> for ImageFormat {
    fn from(v: ImageFormatRg32f) -> Self {
        Self::Rg32f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg16f;
impl From<ImageFormatRg16f> for ImageFormat {
    fn from(v: ImageFormatRg16f) -> Self {
        Self::Rg16f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR11fG11fB10f;
impl From<ImageFormatR11fG11fB10f> for ImageFormat {
    fn from(v: ImageFormatR11fG11fB10f) -> Self {
        Self::R11fG11fB10f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR16f;
impl From<ImageFormatR16f> for ImageFormat {
    fn from(v: ImageFormatR16f) -> Self {
        Self::R16f(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba16;
impl From<ImageFormatRgba16> for ImageFormat {
    fn from(v: ImageFormatRgba16) -> Self {
        Self::Rgba16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgb10A2;
impl From<ImageFormatRgb10A2> for ImageFormat {
    fn from(v: ImageFormatRgb10A2) -> Self {
        Self::Rgb10A2(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg16;
impl From<ImageFormatRg16> for ImageFormat {
    fn from(v: ImageFormatRg16) -> Self {
        Self::Rg16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg8;
impl From<ImageFormatRg8> for ImageFormat {
    fn from(v: ImageFormatRg8) -> Self {
        Self::Rg8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR16;
impl From<ImageFormatR16> for ImageFormat {
    fn from(v: ImageFormatR16) -> Self {
        Self::R16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR8;
impl From<ImageFormatR8> for ImageFormat {
    fn from(v: ImageFormatR8) -> Self {
        Self::R8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba16Snorm;
impl From<ImageFormatRgba16Snorm> for ImageFormat {
    fn from(v: ImageFormatRgba16Snorm) -> Self {
        Self::Rgba16Snorm(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg16Snorm;
impl From<ImageFormatRg16Snorm> for ImageFormat {
    fn from(v: ImageFormatRg16Snorm) -> Self {
        Self::Rg16Snorm(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg8Snorm;
impl From<ImageFormatRg8Snorm> for ImageFormat {
    fn from(v: ImageFormatRg8Snorm) -> Self {
        Self::Rg8Snorm(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR16Snorm;
impl From<ImageFormatR16Snorm> for ImageFormat {
    fn from(v: ImageFormatR16Snorm) -> Self {
        Self::R16Snorm(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR8Snorm;
impl From<ImageFormatR8Snorm> for ImageFormat {
    fn from(v: ImageFormatR8Snorm) -> Self {
        Self::R8Snorm(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba32i;
impl From<ImageFormatRgba32i> for ImageFormat {
    fn from(v: ImageFormatRgba32i) -> Self {
        Self::Rgba32i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba16i;
impl From<ImageFormatRgba16i> for ImageFormat {
    fn from(v: ImageFormatRgba16i) -> Self {
        Self::Rgba16i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba8i;
impl From<ImageFormatRgba8i> for ImageFormat {
    fn from(v: ImageFormatRgba8i) -> Self {
        Self::Rgba8i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR32i;
impl From<ImageFormatR32i> for ImageFormat {
    fn from(v: ImageFormatR32i) -> Self {
        Self::R32i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg32i;
impl From<ImageFormatRg32i> for ImageFormat {
    fn from(v: ImageFormatRg32i) -> Self {
        Self::Rg32i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg16i;
impl From<ImageFormatRg16i> for ImageFormat {
    fn from(v: ImageFormatRg16i) -> Self {
        Self::Rg16i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg8i;
impl From<ImageFormatRg8i> for ImageFormat {
    fn from(v: ImageFormatRg8i) -> Self {
        Self::Rg8i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR16i;
impl From<ImageFormatR16i> for ImageFormat {
    fn from(v: ImageFormatR16i) -> Self {
        Self::R16i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR8i;
impl From<ImageFormatR8i> for ImageFormat {
    fn from(v: ImageFormatR8i) -> Self {
        Self::R8i(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba32ui;
impl From<ImageFormatRgba32ui> for ImageFormat {
    fn from(v: ImageFormatRgba32ui) -> Self {
        Self::Rgba32ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba16ui;
impl From<ImageFormatRgba16ui> for ImageFormat {
    fn from(v: ImageFormatRgba16ui) -> Self {
        Self::Rgba16ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgba8ui;
impl From<ImageFormatRgba8ui> for ImageFormat {
    fn from(v: ImageFormatRgba8ui) -> Self {
        Self::Rgba8ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR32ui;
impl From<ImageFormatR32ui> for ImageFormat {
    fn from(v: ImageFormatR32ui) -> Self {
        Self::R32ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRgb10a2ui;
impl From<ImageFormatRgb10a2ui> for ImageFormat {
    fn from(v: ImageFormatRgb10a2ui) -> Self {
        Self::Rgb10a2ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg32ui;
impl From<ImageFormatRg32ui> for ImageFormat {
    fn from(v: ImageFormatRg32ui) -> Self {
        Self::Rg32ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg16ui;
impl From<ImageFormatRg16ui> for ImageFormat {
    fn from(v: ImageFormatRg16ui) -> Self {
        Self::Rg16ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatRg8ui;
impl From<ImageFormatRg8ui> for ImageFormat {
    fn from(v: ImageFormatRg8ui) -> Self {
        Self::Rg8ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR16ui;
impl From<ImageFormatR16ui> for ImageFormat {
    fn from(v: ImageFormatR16ui) -> Self {
        Self::R16ui(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageFormatR8ui;
impl From<ImageFormatR8ui> for ImageFormat {
    fn from(v: ImageFormatR8ui) -> Self {
        Self::R8ui(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ImageFormat {
    Unknown(ImageFormatUnknown),
    Rgba32f(ImageFormatRgba32f),
    Rgba16f(ImageFormatRgba16f),
    R32f(ImageFormatR32f),
    Rgba8(ImageFormatRgba8),
    Rgba8Snorm(ImageFormatRgba8Snorm),
    Rg32f(ImageFormatRg32f),
    Rg16f(ImageFormatRg16f),
    R11fG11fB10f(ImageFormatR11fG11fB10f),
    R16f(ImageFormatR16f),
    Rgba16(ImageFormatRgba16),
    Rgb10A2(ImageFormatRgb10A2),
    Rg16(ImageFormatRg16),
    Rg8(ImageFormatRg8),
    R16(ImageFormatR16),
    R8(ImageFormatR8),
    Rgba16Snorm(ImageFormatRgba16Snorm),
    Rg16Snorm(ImageFormatRg16Snorm),
    Rg8Snorm(ImageFormatRg8Snorm),
    R16Snorm(ImageFormatR16Snorm),
    R8Snorm(ImageFormatR8Snorm),
    Rgba32i(ImageFormatRgba32i),
    Rgba16i(ImageFormatRgba16i),
    Rgba8i(ImageFormatRgba8i),
    R32i(ImageFormatR32i),
    Rg32i(ImageFormatRg32i),
    Rg16i(ImageFormatRg16i),
    Rg8i(ImageFormatRg8i),
    R16i(ImageFormatR16i),
    R8i(ImageFormatR8i),
    Rgba32ui(ImageFormatRgba32ui),
    Rgba16ui(ImageFormatRgba16ui),
    Rgba8ui(ImageFormatRgba8ui),
    R32ui(ImageFormatR32ui),
    Rgb10a2ui(ImageFormatRgb10a2ui),
    Rg32ui(ImageFormatRg32ui),
    Rg16ui(ImageFormatRg16ui),
    Rg8ui(ImageFormatRg8ui),
    R16ui(ImageFormatR16ui),
    R8ui(ImageFormatR8ui),
}
impl SPIRVParse for ImageFormat {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ImageFormat::Unknown(ImageFormatUnknown), words)),
            1u32 => Ok((ImageFormat::Rgba32f(ImageFormatRgba32f), words)),
            2u32 => Ok((ImageFormat::Rgba16f(ImageFormatRgba16f), words)),
            3u32 => Ok((ImageFormat::R32f(ImageFormatR32f), words)),
            4u32 => Ok((ImageFormat::Rgba8(ImageFormatRgba8), words)),
            5u32 => Ok((ImageFormat::Rgba8Snorm(ImageFormatRgba8Snorm), words)),
            6u32 => Ok((ImageFormat::Rg32f(ImageFormatRg32f), words)),
            7u32 => Ok((ImageFormat::Rg16f(ImageFormatRg16f), words)),
            8u32 => Ok((ImageFormat::R11fG11fB10f(ImageFormatR11fG11fB10f), words)),
            9u32 => Ok((ImageFormat::R16f(ImageFormatR16f), words)),
            10u32 => Ok((ImageFormat::Rgba16(ImageFormatRgba16), words)),
            11u32 => Ok((ImageFormat::Rgb10A2(ImageFormatRgb10A2), words)),
            12u32 => Ok((ImageFormat::Rg16(ImageFormatRg16), words)),
            13u32 => Ok((ImageFormat::Rg8(ImageFormatRg8), words)),
            14u32 => Ok((ImageFormat::R16(ImageFormatR16), words)),
            15u32 => Ok((ImageFormat::R8(ImageFormatR8), words)),
            16u32 => Ok((ImageFormat::Rgba16Snorm(ImageFormatRgba16Snorm), words)),
            17u32 => Ok((ImageFormat::Rg16Snorm(ImageFormatRg16Snorm), words)),
            18u32 => Ok((ImageFormat::Rg8Snorm(ImageFormatRg8Snorm), words)),
            19u32 => Ok((ImageFormat::R16Snorm(ImageFormatR16Snorm), words)),
            20u32 => Ok((ImageFormat::R8Snorm(ImageFormatR8Snorm), words)),
            21u32 => Ok((ImageFormat::Rgba32i(ImageFormatRgba32i), words)),
            22u32 => Ok((ImageFormat::Rgba16i(ImageFormatRgba16i), words)),
            23u32 => Ok((ImageFormat::Rgba8i(ImageFormatRgba8i), words)),
            24u32 => Ok((ImageFormat::R32i(ImageFormatR32i), words)),
            25u32 => Ok((ImageFormat::Rg32i(ImageFormatRg32i), words)),
            26u32 => Ok((ImageFormat::Rg16i(ImageFormatRg16i), words)),
            27u32 => Ok((ImageFormat::Rg8i(ImageFormatRg8i), words)),
            28u32 => Ok((ImageFormat::R16i(ImageFormatR16i), words)),
            29u32 => Ok((ImageFormat::R8i(ImageFormatR8i), words)),
            30u32 => Ok((ImageFormat::Rgba32ui(ImageFormatRgba32ui), words)),
            31u32 => Ok((ImageFormat::Rgba16ui(ImageFormatRgba16ui), words)),
            32u32 => Ok((ImageFormat::Rgba8ui(ImageFormatRgba8ui), words)),
            33u32 => Ok((ImageFormat::R32ui(ImageFormatR32ui), words)),
            34u32 => Ok((ImageFormat::Rgb10a2ui(ImageFormatRgb10a2ui), words)),
            35u32 => Ok((ImageFormat::Rg32ui(ImageFormatRg32ui), words)),
            36u32 => Ok((ImageFormat::Rg16ui(ImageFormatRg16ui), words)),
            37u32 => Ok((ImageFormat::Rg8ui(ImageFormatRg8ui), words)),
            38u32 => Ok((ImageFormat::R16ui(ImageFormatR16ui), words)),
            39u32 => Ok((ImageFormat::R8ui(ImageFormatR8ui), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ImageFormat {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ImageFormat::Unknown(_) => write!(f, " {}", "Unknown"),
            ImageFormat::Rgba32f(_) => write!(f, " {}", "Rgba32f"),
            ImageFormat::Rgba16f(_) => write!(f, " {}", "Rgba16f"),
            ImageFormat::R32f(_) => write!(f, " {}", "R32f"),
            ImageFormat::Rgba8(_) => write!(f, " {}", "Rgba8"),
            ImageFormat::Rgba8Snorm(_) => write!(f, " {}", "Rgba8Snorm"),
            ImageFormat::Rg32f(_) => write!(f, " {}", "Rg32f"),
            ImageFormat::Rg16f(_) => write!(f, " {}", "Rg16f"),
            ImageFormat::R11fG11fB10f(_) => write!(f, " {}", "R11fG11fB10f"),
            ImageFormat::R16f(_) => write!(f, " {}", "R16f"),
            ImageFormat::Rgba16(_) => write!(f, " {}", "Rgba16"),
            ImageFormat::Rgb10A2(_) => write!(f, " {}", "Rgb10A2"),
            ImageFormat::Rg16(_) => write!(f, " {}", "Rg16"),
            ImageFormat::Rg8(_) => write!(f, " {}", "Rg8"),
            ImageFormat::R16(_) => write!(f, " {}", "R16"),
            ImageFormat::R8(_) => write!(f, " {}", "R8"),
            ImageFormat::Rgba16Snorm(_) => write!(f, " {}", "Rgba16Snorm"),
            ImageFormat::Rg16Snorm(_) => write!(f, " {}", "Rg16Snorm"),
            ImageFormat::Rg8Snorm(_) => write!(f, " {}", "Rg8Snorm"),
            ImageFormat::R16Snorm(_) => write!(f, " {}", "R16Snorm"),
            ImageFormat::R8Snorm(_) => write!(f, " {}", "R8Snorm"),
            ImageFormat::Rgba32i(_) => write!(f, " {}", "Rgba32i"),
            ImageFormat::Rgba16i(_) => write!(f, " {}", "Rgba16i"),
            ImageFormat::Rgba8i(_) => write!(f, " {}", "Rgba8i"),
            ImageFormat::R32i(_) => write!(f, " {}", "R32i"),
            ImageFormat::Rg32i(_) => write!(f, " {}", "Rg32i"),
            ImageFormat::Rg16i(_) => write!(f, " {}", "Rg16i"),
            ImageFormat::Rg8i(_) => write!(f, " {}", "Rg8i"),
            ImageFormat::R16i(_) => write!(f, " {}", "R16i"),
            ImageFormat::R8i(_) => write!(f, " {}", "R8i"),
            ImageFormat::Rgba32ui(_) => write!(f, " {}", "Rgba32ui"),
            ImageFormat::Rgba16ui(_) => write!(f, " {}", "Rgba16ui"),
            ImageFormat::Rgba8ui(_) => write!(f, " {}", "Rgba8ui"),
            ImageFormat::R32ui(_) => write!(f, " {}", "R32ui"),
            ImageFormat::Rgb10a2ui(_) => write!(f, " {}", "Rgb10a2ui"),
            ImageFormat::Rg32ui(_) => write!(f, " {}", "Rg32ui"),
            ImageFormat::Rg16ui(_) => write!(f, " {}", "Rg16ui"),
            ImageFormat::Rg8ui(_) => write!(f, " {}", "Rg8ui"),
            ImageFormat::R16ui(_) => write!(f, " {}", "R16ui"),
            ImageFormat::R8ui(_) => write!(f, " {}", "R8ui"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderR;
impl From<ImageChannelOrderR> for ImageChannelOrder {
    fn from(v: ImageChannelOrderR) -> Self {
        Self::R(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderA;
impl From<ImageChannelOrderA> for ImageChannelOrder {
    fn from(v: ImageChannelOrderA) -> Self {
        Self::A(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRG;
impl From<ImageChannelOrderRG> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRG) -> Self {
        Self::RG(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRA;
impl From<ImageChannelOrderRA> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRA) -> Self {
        Self::RA(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRGB;
impl From<ImageChannelOrderRGB> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRGB) -> Self {
        Self::RGB(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRGBA;
impl From<ImageChannelOrderRGBA> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRGBA) -> Self {
        Self::RGBA(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderBGRA;
impl From<ImageChannelOrderBGRA> for ImageChannelOrder {
    fn from(v: ImageChannelOrderBGRA) -> Self {
        Self::BGRA(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderARGB;
impl From<ImageChannelOrderARGB> for ImageChannelOrder {
    fn from(v: ImageChannelOrderARGB) -> Self {
        Self::ARGB(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderIntensity;
impl From<ImageChannelOrderIntensity> for ImageChannelOrder {
    fn from(v: ImageChannelOrderIntensity) -> Self {
        Self::Intensity(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderLuminance;
impl From<ImageChannelOrderLuminance> for ImageChannelOrder {
    fn from(v: ImageChannelOrderLuminance) -> Self {
        Self::Luminance(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRx;
impl From<ImageChannelOrderRx> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRx) -> Self {
        Self::Rx(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRGx;
impl From<ImageChannelOrderRGx> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRGx) -> Self {
        Self::RGx(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderRGBx;
impl From<ImageChannelOrderRGBx> for ImageChannelOrder {
    fn from(v: ImageChannelOrderRGBx) -> Self {
        Self::RGBx(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderDepth;
impl From<ImageChannelOrderDepth> for ImageChannelOrder {
    fn from(v: ImageChannelOrderDepth) -> Self {
        Self::Depth(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderDepthStencil;
impl From<ImageChannelOrderDepthStencil> for ImageChannelOrder {
    fn from(v: ImageChannelOrderDepthStencil) -> Self {
        Self::DepthStencil(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderSRGB;
impl From<ImageChannelOrderSRGB> for ImageChannelOrder {
    fn from(v: ImageChannelOrderSRGB) -> Self {
        Self::SRGB(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderSRGBx;
impl From<ImageChannelOrderSRGBx> for ImageChannelOrder {
    fn from(v: ImageChannelOrderSRGBx) -> Self {
        Self::SRGBx(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderSRGBA;
impl From<ImageChannelOrderSRGBA> for ImageChannelOrder {
    fn from(v: ImageChannelOrderSRGBA) -> Self {
        Self::SRGBA(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderSBGRA;
impl From<ImageChannelOrderSBGRA> for ImageChannelOrder {
    fn from(v: ImageChannelOrderSBGRA) -> Self {
        Self::SBGRA(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelOrderABGR;
impl From<ImageChannelOrderABGR> for ImageChannelOrder {
    fn from(v: ImageChannelOrderABGR) -> Self {
        Self::ABGR(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ImageChannelOrder {
    R(ImageChannelOrderR),
    A(ImageChannelOrderA),
    RG(ImageChannelOrderRG),
    RA(ImageChannelOrderRA),
    RGB(ImageChannelOrderRGB),
    RGBA(ImageChannelOrderRGBA),
    BGRA(ImageChannelOrderBGRA),
    ARGB(ImageChannelOrderARGB),
    Intensity(ImageChannelOrderIntensity),
    Luminance(ImageChannelOrderLuminance),
    Rx(ImageChannelOrderRx),
    RGx(ImageChannelOrderRGx),
    RGBx(ImageChannelOrderRGBx),
    Depth(ImageChannelOrderDepth),
    DepthStencil(ImageChannelOrderDepthStencil),
    SRGB(ImageChannelOrderSRGB),
    SRGBx(ImageChannelOrderSRGBx),
    SRGBA(ImageChannelOrderSRGBA),
    SBGRA(ImageChannelOrderSBGRA),
    ABGR(ImageChannelOrderABGR),
}
impl SPIRVParse for ImageChannelOrder {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ImageChannelOrder::R(ImageChannelOrderR), words)),
            1u32 => Ok((ImageChannelOrder::A(ImageChannelOrderA), words)),
            2u32 => Ok((ImageChannelOrder::RG(ImageChannelOrderRG), words)),
            3u32 => Ok((ImageChannelOrder::RA(ImageChannelOrderRA), words)),
            4u32 => Ok((ImageChannelOrder::RGB(ImageChannelOrderRGB), words)),
            5u32 => Ok((ImageChannelOrder::RGBA(ImageChannelOrderRGBA), words)),
            6u32 => Ok((ImageChannelOrder::BGRA(ImageChannelOrderBGRA), words)),
            7u32 => Ok((ImageChannelOrder::ARGB(ImageChannelOrderARGB), words)),
            8u32 => Ok((
                ImageChannelOrder::Intensity(ImageChannelOrderIntensity),
                words,
            )),
            9u32 => Ok((
                ImageChannelOrder::Luminance(ImageChannelOrderLuminance),
                words,
            )),
            10u32 => Ok((ImageChannelOrder::Rx(ImageChannelOrderRx), words)),
            11u32 => Ok((ImageChannelOrder::RGx(ImageChannelOrderRGx), words)),
            12u32 => Ok((ImageChannelOrder::RGBx(ImageChannelOrderRGBx), words)),
            13u32 => Ok((ImageChannelOrder::Depth(ImageChannelOrderDepth), words)),
            14u32 => Ok((
                ImageChannelOrder::DepthStencil(ImageChannelOrderDepthStencil),
                words,
            )),
            15u32 => Ok((ImageChannelOrder::SRGB(ImageChannelOrderSRGB), words)),
            16u32 => Ok((ImageChannelOrder::SRGBx(ImageChannelOrderSRGBx), words)),
            17u32 => Ok((ImageChannelOrder::SRGBA(ImageChannelOrderSRGBA), words)),
            18u32 => Ok((ImageChannelOrder::SBGRA(ImageChannelOrderSBGRA), words)),
            19u32 => Ok((ImageChannelOrder::ABGR(ImageChannelOrderABGR), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ImageChannelOrder {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ImageChannelOrder::R(_) => write!(f, " {}", "R"),
            ImageChannelOrder::A(_) => write!(f, " {}", "A"),
            ImageChannelOrder::RG(_) => write!(f, " {}", "RG"),
            ImageChannelOrder::RA(_) => write!(f, " {}", "RA"),
            ImageChannelOrder::RGB(_) => write!(f, " {}", "RGB"),
            ImageChannelOrder::RGBA(_) => write!(f, " {}", "RGBA"),
            ImageChannelOrder::BGRA(_) => write!(f, " {}", "BGRA"),
            ImageChannelOrder::ARGB(_) => write!(f, " {}", "ARGB"),
            ImageChannelOrder::Intensity(_) => write!(f, " {}", "Intensity"),
            ImageChannelOrder::Luminance(_) => write!(f, " {}", "Luminance"),
            ImageChannelOrder::Rx(_) => write!(f, " {}", "Rx"),
            ImageChannelOrder::RGx(_) => write!(f, " {}", "RGx"),
            ImageChannelOrder::RGBx(_) => write!(f, " {}", "RGBx"),
            ImageChannelOrder::Depth(_) => write!(f, " {}", "Depth"),
            ImageChannelOrder::DepthStencil(_) => write!(f, " {}", "DepthStencil"),
            ImageChannelOrder::SRGB(_) => write!(f, " {}", "sRGB"),
            ImageChannelOrder::SRGBx(_) => write!(f, " {}", "sRGBx"),
            ImageChannelOrder::SRGBA(_) => write!(f, " {}", "sRGBA"),
            ImageChannelOrder::SBGRA(_) => write!(f, " {}", "sBGRA"),
            ImageChannelOrder::ABGR(_) => write!(f, " {}", "ABGR"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeSnormInt8;
impl From<ImageChannelDataTypeSnormInt8> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeSnormInt8) -> Self {
        Self::SnormInt8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeSnormInt16;
impl From<ImageChannelDataTypeSnormInt16> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeSnormInt16) -> Self {
        Self::SnormInt16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormInt8;
impl From<ImageChannelDataTypeUnormInt8> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormInt8) -> Self {
        Self::UnormInt8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormInt16;
impl From<ImageChannelDataTypeUnormInt16> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormInt16) -> Self {
        Self::UnormInt16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormShort565;
impl From<ImageChannelDataTypeUnormShort565> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormShort565) -> Self {
        Self::UnormShort565(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormShort555;
impl From<ImageChannelDataTypeUnormShort555> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormShort555) -> Self {
        Self::UnormShort555(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormInt101010;
impl From<ImageChannelDataTypeUnormInt101010> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormInt101010) -> Self {
        Self::UnormInt101010(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeSignedInt8;
impl From<ImageChannelDataTypeSignedInt8> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeSignedInt8) -> Self {
        Self::SignedInt8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeSignedInt16;
impl From<ImageChannelDataTypeSignedInt16> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeSignedInt16) -> Self {
        Self::SignedInt16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeSignedInt32;
impl From<ImageChannelDataTypeSignedInt32> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeSignedInt32) -> Self {
        Self::SignedInt32(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnsignedInt8;
impl From<ImageChannelDataTypeUnsignedInt8> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnsignedInt8) -> Self {
        Self::UnsignedInt8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnsignedInt16;
impl From<ImageChannelDataTypeUnsignedInt16> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnsignedInt16) -> Self {
        Self::UnsignedInt16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnsignedInt32;
impl From<ImageChannelDataTypeUnsignedInt32> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnsignedInt32) -> Self {
        Self::UnsignedInt32(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeHalfFloat;
impl From<ImageChannelDataTypeHalfFloat> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeHalfFloat) -> Self {
        Self::HalfFloat(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeFloat;
impl From<ImageChannelDataTypeFloat> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeFloat) -> Self {
        Self::Float(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormInt24;
impl From<ImageChannelDataTypeUnormInt24> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormInt24) -> Self {
        Self::UnormInt24(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ImageChannelDataTypeUnormInt1010102;
impl From<ImageChannelDataTypeUnormInt1010102> for ImageChannelDataType {
    fn from(v: ImageChannelDataTypeUnormInt1010102) -> Self {
        Self::UnormInt1010102(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ImageChannelDataType {
    SnormInt8(ImageChannelDataTypeSnormInt8),
    SnormInt16(ImageChannelDataTypeSnormInt16),
    UnormInt8(ImageChannelDataTypeUnormInt8),
    UnormInt16(ImageChannelDataTypeUnormInt16),
    UnormShort565(ImageChannelDataTypeUnormShort565),
    UnormShort555(ImageChannelDataTypeUnormShort555),
    UnormInt101010(ImageChannelDataTypeUnormInt101010),
    SignedInt8(ImageChannelDataTypeSignedInt8),
    SignedInt16(ImageChannelDataTypeSignedInt16),
    SignedInt32(ImageChannelDataTypeSignedInt32),
    UnsignedInt8(ImageChannelDataTypeUnsignedInt8),
    UnsignedInt16(ImageChannelDataTypeUnsignedInt16),
    UnsignedInt32(ImageChannelDataTypeUnsignedInt32),
    HalfFloat(ImageChannelDataTypeHalfFloat),
    Float(ImageChannelDataTypeFloat),
    UnormInt24(ImageChannelDataTypeUnormInt24),
    UnormInt1010102(ImageChannelDataTypeUnormInt1010102),
}
impl SPIRVParse for ImageChannelDataType {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((
                ImageChannelDataType::SnormInt8(ImageChannelDataTypeSnormInt8),
                words,
            )),
            1u32 => Ok((
                ImageChannelDataType::SnormInt16(ImageChannelDataTypeSnormInt16),
                words,
            )),
            2u32 => Ok((
                ImageChannelDataType::UnormInt8(ImageChannelDataTypeUnormInt8),
                words,
            )),
            3u32 => Ok((
                ImageChannelDataType::UnormInt16(ImageChannelDataTypeUnormInt16),
                words,
            )),
            4u32 => Ok((
                ImageChannelDataType::UnormShort565(ImageChannelDataTypeUnormShort565),
                words,
            )),
            5u32 => Ok((
                ImageChannelDataType::UnormShort555(ImageChannelDataTypeUnormShort555),
                words,
            )),
            6u32 => Ok((
                ImageChannelDataType::UnormInt101010(ImageChannelDataTypeUnormInt101010),
                words,
            )),
            7u32 => Ok((
                ImageChannelDataType::SignedInt8(ImageChannelDataTypeSignedInt8),
                words,
            )),
            8u32 => Ok((
                ImageChannelDataType::SignedInt16(ImageChannelDataTypeSignedInt16),
                words,
            )),
            9u32 => Ok((
                ImageChannelDataType::SignedInt32(ImageChannelDataTypeSignedInt32),
                words,
            )),
            10u32 => Ok((
                ImageChannelDataType::UnsignedInt8(ImageChannelDataTypeUnsignedInt8),
                words,
            )),
            11u32 => Ok((
                ImageChannelDataType::UnsignedInt16(ImageChannelDataTypeUnsignedInt16),
                words,
            )),
            12u32 => Ok((
                ImageChannelDataType::UnsignedInt32(ImageChannelDataTypeUnsignedInt32),
                words,
            )),
            13u32 => Ok((
                ImageChannelDataType::HalfFloat(ImageChannelDataTypeHalfFloat),
                words,
            )),
            14u32 => Ok((
                ImageChannelDataType::Float(ImageChannelDataTypeFloat),
                words,
            )),
            15u32 => Ok((
                ImageChannelDataType::UnormInt24(ImageChannelDataTypeUnormInt24),
                words,
            )),
            16u32 => Ok((
                ImageChannelDataType::UnormInt1010102(ImageChannelDataTypeUnormInt1010102),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ImageChannelDataType {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ImageChannelDataType::SnormInt8(_) => write!(f, " {}", "SnormInt8"),
            ImageChannelDataType::SnormInt16(_) => write!(f, " {}", "SnormInt16"),
            ImageChannelDataType::UnormInt8(_) => write!(f, " {}", "UnormInt8"),
            ImageChannelDataType::UnormInt16(_) => write!(f, " {}", "UnormInt16"),
            ImageChannelDataType::UnormShort565(_) => write!(f, " {}", "UnormShort565"),
            ImageChannelDataType::UnormShort555(_) => write!(f, " {}", "UnormShort555"),
            ImageChannelDataType::UnormInt101010(_) => write!(f, " {}", "UnormInt101010"),
            ImageChannelDataType::SignedInt8(_) => write!(f, " {}", "SignedInt8"),
            ImageChannelDataType::SignedInt16(_) => write!(f, " {}", "SignedInt16"),
            ImageChannelDataType::SignedInt32(_) => write!(f, " {}", "SignedInt32"),
            ImageChannelDataType::UnsignedInt8(_) => write!(f, " {}", "UnsignedInt8"),
            ImageChannelDataType::UnsignedInt16(_) => write!(f, " {}", "UnsignedInt16"),
            ImageChannelDataType::UnsignedInt32(_) => write!(f, " {}", "UnsignedInt32"),
            ImageChannelDataType::HalfFloat(_) => write!(f, " {}", "HalfFloat"),
            ImageChannelDataType::Float(_) => write!(f, " {}", "Float"),
            ImageChannelDataType::UnormInt24(_) => write!(f, " {}", "UnormInt24"),
            ImageChannelDataType::UnormInt1010102(_) => write!(f, " {}", "UnormInt101010_2"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FPRoundingModeRTE;
impl From<FPRoundingModeRTE> for FPRoundingMode {
    fn from(v: FPRoundingModeRTE) -> Self {
        Self::RTE(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FPRoundingModeRTZ;
impl From<FPRoundingModeRTZ> for FPRoundingMode {
    fn from(v: FPRoundingModeRTZ) -> Self {
        Self::RTZ(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FPRoundingModeRTP;
impl From<FPRoundingModeRTP> for FPRoundingMode {
    fn from(v: FPRoundingModeRTP) -> Self {
        Self::RTP(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FPRoundingModeRTN;
impl From<FPRoundingModeRTN> for FPRoundingMode {
    fn from(v: FPRoundingModeRTN) -> Self {
        Self::RTN(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum FPRoundingMode {
    RTE(FPRoundingModeRTE),
    RTZ(FPRoundingModeRTZ),
    RTP(FPRoundingModeRTP),
    RTN(FPRoundingModeRTN),
}
impl SPIRVParse for FPRoundingMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((FPRoundingMode::RTE(FPRoundingModeRTE), words)),
            1u32 => Ok((FPRoundingMode::RTZ(FPRoundingModeRTZ), words)),
            2u32 => Ok((FPRoundingMode::RTP(FPRoundingModeRTP), words)),
            3u32 => Ok((FPRoundingMode::RTN(FPRoundingModeRTN), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for FPRoundingMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FPRoundingMode::RTE(_) => write!(f, " {}", "RTE"),
            FPRoundingMode::RTZ(_) => write!(f, " {}", "RTZ"),
            FPRoundingMode::RTP(_) => write!(f, " {}", "RTP"),
            FPRoundingMode::RTN(_) => write!(f, " {}", "RTN"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct LinkageTypeExport;
impl From<LinkageTypeExport> for LinkageType {
    fn from(v: LinkageTypeExport) -> Self {
        Self::Export(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct LinkageTypeImport;
impl From<LinkageTypeImport> for LinkageType {
    fn from(v: LinkageTypeImport) -> Self {
        Self::Import(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum LinkageType {
    Export(LinkageTypeExport),
    Import(LinkageTypeImport),
}
impl SPIRVParse for LinkageType {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((LinkageType::Export(LinkageTypeExport), words)),
            1u32 => Ok((LinkageType::Import(LinkageTypeImport), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for LinkageType {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            LinkageType::Export(_) => write!(f, " {}", "Export"),
            LinkageType::Import(_) => write!(f, " {}", "Import"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AccessQualifierReadOnly;
impl From<AccessQualifierReadOnly> for AccessQualifier {
    fn from(v: AccessQualifierReadOnly) -> Self {
        Self::ReadOnly(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AccessQualifierWriteOnly;
impl From<AccessQualifierWriteOnly> for AccessQualifier {
    fn from(v: AccessQualifierWriteOnly) -> Self {
        Self::WriteOnly(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct AccessQualifierReadWrite;
impl From<AccessQualifierReadWrite> for AccessQualifier {
    fn from(v: AccessQualifierReadWrite) -> Self {
        Self::ReadWrite(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum AccessQualifier {
    ReadOnly(AccessQualifierReadOnly),
    WriteOnly(AccessQualifierWriteOnly),
    ReadWrite(AccessQualifierReadWrite),
}
impl SPIRVParse for AccessQualifier {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((AccessQualifier::ReadOnly(AccessQualifierReadOnly), words)),
            1u32 => Ok((AccessQualifier::WriteOnly(AccessQualifierWriteOnly), words)),
            2u32 => Ok((AccessQualifier::ReadWrite(AccessQualifierReadWrite), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for AccessQualifier {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AccessQualifier::ReadOnly(_) => write!(f, " {}", "ReadOnly"),
            AccessQualifier::WriteOnly(_) => write!(f, " {}", "WriteOnly"),
            AccessQualifier::ReadWrite(_) => write!(f, " {}", "ReadWrite"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeZext;
impl From<FunctionParameterAttributeZext> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeZext) -> Self {
        Self::Zext(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeSext;
impl From<FunctionParameterAttributeSext> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeSext) -> Self {
        Self::Sext(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeByVal;
impl From<FunctionParameterAttributeByVal> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeByVal) -> Self {
        Self::ByVal(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeSret;
impl From<FunctionParameterAttributeSret> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeSret) -> Self {
        Self::Sret(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeNoAlias;
impl From<FunctionParameterAttributeNoAlias> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeNoAlias) -> Self {
        Self::NoAlias(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeNoCapture;
impl From<FunctionParameterAttributeNoCapture> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeNoCapture) -> Self {
        Self::NoCapture(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeNoWrite;
impl From<FunctionParameterAttributeNoWrite> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeNoWrite) -> Self {
        Self::NoWrite(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct FunctionParameterAttributeNoReadWrite;
impl From<FunctionParameterAttributeNoReadWrite> for FunctionParameterAttribute {
    fn from(v: FunctionParameterAttributeNoReadWrite) -> Self {
        Self::NoReadWrite(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum FunctionParameterAttribute {
    Zext(FunctionParameterAttributeZext),
    Sext(FunctionParameterAttributeSext),
    ByVal(FunctionParameterAttributeByVal),
    Sret(FunctionParameterAttributeSret),
    NoAlias(FunctionParameterAttributeNoAlias),
    NoCapture(FunctionParameterAttributeNoCapture),
    NoWrite(FunctionParameterAttributeNoWrite),
    NoReadWrite(FunctionParameterAttributeNoReadWrite),
}
impl SPIRVParse for FunctionParameterAttribute {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((
                FunctionParameterAttribute::Zext(FunctionParameterAttributeZext),
                words,
            )),
            1u32 => Ok((
                FunctionParameterAttribute::Sext(FunctionParameterAttributeSext),
                words,
            )),
            2u32 => Ok((
                FunctionParameterAttribute::ByVal(FunctionParameterAttributeByVal),
                words,
            )),
            3u32 => Ok((
                FunctionParameterAttribute::Sret(FunctionParameterAttributeSret),
                words,
            )),
            4u32 => Ok((
                FunctionParameterAttribute::NoAlias(FunctionParameterAttributeNoAlias),
                words,
            )),
            5u32 => Ok((
                FunctionParameterAttribute::NoCapture(FunctionParameterAttributeNoCapture),
                words,
            )),
            6u32 => Ok((
                FunctionParameterAttribute::NoWrite(FunctionParameterAttributeNoWrite),
                words,
            )),
            7u32 => Ok((
                FunctionParameterAttribute::NoReadWrite(FunctionParameterAttributeNoReadWrite),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for FunctionParameterAttribute {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FunctionParameterAttribute::Zext(_) => write!(f, " {}", "Zext"),
            FunctionParameterAttribute::Sext(_) => write!(f, " {}", "Sext"),
            FunctionParameterAttribute::ByVal(_) => write!(f, " {}", "ByVal"),
            FunctionParameterAttribute::Sret(_) => write!(f, " {}", "Sret"),
            FunctionParameterAttribute::NoAlias(_) => write!(f, " {}", "NoAlias"),
            FunctionParameterAttribute::NoCapture(_) => write!(f, " {}", "NoCapture"),
            FunctionParameterAttribute::NoWrite(_) => write!(f, " {}", "NoWrite"),
            FunctionParameterAttribute::NoReadWrite(_) => write!(f, " {}", "NoReadWrite"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationRelaxedPrecision;
impl From<DecorationRelaxedPrecision> for Decoration {
    fn from(v: DecorationRelaxedPrecision) -> Self {
        Self::RelaxedPrecision(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationSpecId {
    pub specialization_constant_id: LiteralInteger32,
}
impl From<DecorationSpecId> for Decoration {
    fn from(v: DecorationSpecId) -> Self {
        Self::SpecId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationBlock;
impl From<DecorationBlock> for Decoration {
    fn from(v: DecorationBlock) -> Self {
        Self::Block(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationBufferBlock;
impl From<DecorationBufferBlock> for Decoration {
    fn from(v: DecorationBufferBlock) -> Self {
        Self::BufferBlock(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationRowMajor;
impl From<DecorationRowMajor> for Decoration {
    fn from(v: DecorationRowMajor) -> Self {
        Self::RowMajor(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationColMajor;
impl From<DecorationColMajor> for Decoration {
    fn from(v: DecorationColMajor) -> Self {
        Self::ColMajor(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationArrayStride {
    pub array_stride: LiteralInteger32,
}
impl From<DecorationArrayStride> for Decoration {
    fn from(v: DecorationArrayStride) -> Self {
        Self::ArrayStride(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationMatrixStride {
    pub matrix_stride: LiteralInteger32,
}
impl From<DecorationMatrixStride> for Decoration {
    fn from(v: DecorationMatrixStride) -> Self {
        Self::MatrixStride(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationGLSLShared;
impl From<DecorationGLSLShared> for Decoration {
    fn from(v: DecorationGLSLShared) -> Self {
        Self::GLSLShared(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationGLSLPacked;
impl From<DecorationGLSLPacked> for Decoration {
    fn from(v: DecorationGLSLPacked) -> Self {
        Self::GLSLPacked(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationCPacked;
impl From<DecorationCPacked> for Decoration {
    fn from(v: DecorationCPacked) -> Self {
        Self::CPacked(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationBuiltIn {
    pub built_in: BuiltIn,
}
impl From<DecorationBuiltIn> for Decoration {
    fn from(v: DecorationBuiltIn) -> Self {
        Self::BuiltIn(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNoPerspective;
impl From<DecorationNoPerspective> for Decoration {
    fn from(v: DecorationNoPerspective) -> Self {
        Self::NoPerspective(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationFlat;
impl From<DecorationFlat> for Decoration {
    fn from(v: DecorationFlat) -> Self {
        Self::Flat(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationPatch;
impl From<DecorationPatch> for Decoration {
    fn from(v: DecorationPatch) -> Self {
        Self::Patch(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationCentroid;
impl From<DecorationCentroid> for Decoration {
    fn from(v: DecorationCentroid) -> Self {
        Self::Centroid(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationSample;
impl From<DecorationSample> for Decoration {
    fn from(v: DecorationSample) -> Self {
        Self::Sample(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationInvariant;
impl From<DecorationInvariant> for Decoration {
    fn from(v: DecorationInvariant) -> Self {
        Self::Invariant(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationRestrict;
impl From<DecorationRestrict> for Decoration {
    fn from(v: DecorationRestrict) -> Self {
        Self::Restrict(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationAliased;
impl From<DecorationAliased> for Decoration {
    fn from(v: DecorationAliased) -> Self {
        Self::Aliased(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationVolatile;
impl From<DecorationVolatile> for Decoration {
    fn from(v: DecorationVolatile) -> Self {
        Self::Volatile(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationConstant;
impl From<DecorationConstant> for Decoration {
    fn from(v: DecorationConstant) -> Self {
        Self::Constant(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationCoherent;
impl From<DecorationCoherent> for Decoration {
    fn from(v: DecorationCoherent) -> Self {
        Self::Coherent(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNonWritable;
impl From<DecorationNonWritable> for Decoration {
    fn from(v: DecorationNonWritable) -> Self {
        Self::NonWritable(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNonReadable;
impl From<DecorationNonReadable> for Decoration {
    fn from(v: DecorationNonReadable) -> Self {
        Self::NonReadable(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationUniform;
impl From<DecorationUniform> for Decoration {
    fn from(v: DecorationUniform) -> Self {
        Self::Uniform(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationUniformId {
    pub execution: IdScope,
}
impl From<DecorationUniformId> for Decoration {
    fn from(v: DecorationUniformId) -> Self {
        Self::UniformId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationSaturatedConversion;
impl From<DecorationSaturatedConversion> for Decoration {
    fn from(v: DecorationSaturatedConversion) -> Self {
        Self::SaturatedConversion(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationStream {
    pub stream_number: LiteralInteger32,
}
impl From<DecorationStream> for Decoration {
    fn from(v: DecorationStream) -> Self {
        Self::Stream(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationLocation {
    pub location: LiteralInteger32,
}
impl From<DecorationLocation> for Decoration {
    fn from(v: DecorationLocation) -> Self {
        Self::Location(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationComponent {
    pub component: LiteralInteger32,
}
impl From<DecorationComponent> for Decoration {
    fn from(v: DecorationComponent) -> Self {
        Self::Component(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationIndex {
    pub index: LiteralInteger32,
}
impl From<DecorationIndex> for Decoration {
    fn from(v: DecorationIndex) -> Self {
        Self::Index(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationBinding {
    pub binding_point: LiteralInteger32,
}
impl From<DecorationBinding> for Decoration {
    fn from(v: DecorationBinding) -> Self {
        Self::Binding(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationDescriptorSet {
    pub descriptor_set: LiteralInteger32,
}
impl From<DecorationDescriptorSet> for Decoration {
    fn from(v: DecorationDescriptorSet) -> Self {
        Self::DescriptorSet(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationOffset {
    pub byte_offset: LiteralInteger32,
}
impl From<DecorationOffset> for Decoration {
    fn from(v: DecorationOffset) -> Self {
        Self::Offset(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationXfbBuffer {
    pub xfb_buffer_number: LiteralInteger32,
}
impl From<DecorationXfbBuffer> for Decoration {
    fn from(v: DecorationXfbBuffer) -> Self {
        Self::XfbBuffer(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationXfbStride {
    pub xfb_stride: LiteralInteger32,
}
impl From<DecorationXfbStride> for Decoration {
    fn from(v: DecorationXfbStride) -> Self {
        Self::XfbStride(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationFuncParamAttr {
    pub function_parameter_attribute: FunctionParameterAttribute,
}
impl From<DecorationFuncParamAttr> for Decoration {
    fn from(v: DecorationFuncParamAttr) -> Self {
        Self::FuncParamAttr(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationFPRoundingMode {
    pub floating_point_rounding_mode: FPRoundingMode,
}
impl From<DecorationFPRoundingMode> for Decoration {
    fn from(v: DecorationFPRoundingMode) -> Self {
        Self::FPRoundingMode(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationFPFastMathMode {
    pub fast_math_mode: FPFastMathMode,
}
impl From<DecorationFPFastMathMode> for Decoration {
    fn from(v: DecorationFPFastMathMode) -> Self {
        Self::FPFastMathMode(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationLinkageAttributes {
    pub name: LiteralString,
    pub linkage_type: LinkageType,
}
impl From<DecorationLinkageAttributes> for Decoration {
    fn from(v: DecorationLinkageAttributes) -> Self {
        Self::LinkageAttributes(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNoContraction;
impl From<DecorationNoContraction> for Decoration {
    fn from(v: DecorationNoContraction) -> Self {
        Self::NoContraction(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationInputAttachmentIndex {
    pub attachment_index: LiteralInteger32,
}
impl From<DecorationInputAttachmentIndex> for Decoration {
    fn from(v: DecorationInputAttachmentIndex) -> Self {
        Self::InputAttachmentIndex(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationAlignment {
    pub alignment: LiteralInteger32,
}
impl From<DecorationAlignment> for Decoration {
    fn from(v: DecorationAlignment) -> Self {
        Self::Alignment(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationMaxByteOffset {
    pub max_byte_offset: LiteralInteger32,
}
impl From<DecorationMaxByteOffset> for Decoration {
    fn from(v: DecorationMaxByteOffset) -> Self {
        Self::MaxByteOffset(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationAlignmentId {
    pub alignment: IdRef,
}
impl From<DecorationAlignmentId> for Decoration {
    fn from(v: DecorationAlignmentId) -> Self {
        Self::AlignmentId(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationMaxByteOffsetId {
    pub max_byte_offset: IdRef,
}
impl From<DecorationMaxByteOffsetId> for Decoration {
    fn from(v: DecorationMaxByteOffsetId) -> Self {
        Self::MaxByteOffsetId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNoSignedWrap;
impl From<DecorationNoSignedWrap> for Decoration {
    fn from(v: DecorationNoSignedWrap) -> Self {
        Self::NoSignedWrap(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNoUnsignedWrap;
impl From<DecorationNoUnsignedWrap> for Decoration {
    fn from(v: DecorationNoUnsignedWrap) -> Self {
        Self::NoUnsignedWrap(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationNonUniform;
impl From<DecorationNonUniform> for Decoration {
    fn from(v: DecorationNonUniform) -> Self {
        Self::NonUniform(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationRestrictPointer;
impl From<DecorationRestrictPointer> for Decoration {
    fn from(v: DecorationRestrictPointer) -> Self {
        Self::RestrictPointer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct DecorationAliasedPointer;
impl From<DecorationAliasedPointer> for Decoration {
    fn from(v: DecorationAliasedPointer) -> Self {
        Self::AliasedPointer(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationCounterBuffer {
    pub counter_buffer: IdRef,
}
impl From<DecorationCounterBuffer> for Decoration {
    fn from(v: DecorationCounterBuffer) -> Self {
        Self::CounterBuffer(v)
    }
}
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct DecorationUserSemantic {
    pub semantic: LiteralString,
}
impl From<DecorationUserSemantic> for Decoration {
    fn from(v: DecorationUserSemantic) -> Self {
        Self::UserSemantic(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub enum Decoration {
    RelaxedPrecision(DecorationRelaxedPrecision),
    SpecId(DecorationSpecId),
    Block(DecorationBlock),
    BufferBlock(DecorationBufferBlock),
    RowMajor(DecorationRowMajor),
    ColMajor(DecorationColMajor),
    ArrayStride(DecorationArrayStride),
    MatrixStride(DecorationMatrixStride),
    GLSLShared(DecorationGLSLShared),
    GLSLPacked(DecorationGLSLPacked),
    CPacked(DecorationCPacked),
    BuiltIn(DecorationBuiltIn),
    NoPerspective(DecorationNoPerspective),
    Flat(DecorationFlat),
    Patch(DecorationPatch),
    Centroid(DecorationCentroid),
    Sample(DecorationSample),
    Invariant(DecorationInvariant),
    Restrict(DecorationRestrict),
    Aliased(DecorationAliased),
    Volatile(DecorationVolatile),
    Constant(DecorationConstant),
    Coherent(DecorationCoherent),
    NonWritable(DecorationNonWritable),
    NonReadable(DecorationNonReadable),
    Uniform(DecorationUniform),
    UniformId(DecorationUniformId),
    SaturatedConversion(DecorationSaturatedConversion),
    Stream(DecorationStream),
    Location(DecorationLocation),
    Component(DecorationComponent),
    Index(DecorationIndex),
    Binding(DecorationBinding),
    DescriptorSet(DecorationDescriptorSet),
    Offset(DecorationOffset),
    XfbBuffer(DecorationXfbBuffer),
    XfbStride(DecorationXfbStride),
    FuncParamAttr(DecorationFuncParamAttr),
    FPRoundingMode(DecorationFPRoundingMode),
    FPFastMathMode(DecorationFPFastMathMode),
    LinkageAttributes(DecorationLinkageAttributes),
    NoContraction(DecorationNoContraction),
    InputAttachmentIndex(DecorationInputAttachmentIndex),
    Alignment(DecorationAlignment),
    MaxByteOffset(DecorationMaxByteOffset),
    AlignmentId(DecorationAlignmentId),
    MaxByteOffsetId(DecorationMaxByteOffsetId),
    NoSignedWrap(DecorationNoSignedWrap),
    NoUnsignedWrap(DecorationNoUnsignedWrap),
    NonUniform(DecorationNonUniform),
    RestrictPointer(DecorationRestrictPointer),
    AliasedPointer(DecorationAliasedPointer),
    CounterBuffer(DecorationCounterBuffer),
    UserSemantic(DecorationUserSemantic),
}
impl SPIRVParse for Decoration {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((
                Decoration::RelaxedPrecision(DecorationRelaxedPrecision),
                words,
            )),
            1u32 => {
                let (specialization_constant_id, words) =
                    LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::SpecId(DecorationSpecId {
                        specialization_constant_id,
                    }),
                    words,
                ))
            }
            2u32 => Ok((Decoration::Block(DecorationBlock), words)),
            3u32 => Ok((Decoration::BufferBlock(DecorationBufferBlock), words)),
            4u32 => Ok((Decoration::RowMajor(DecorationRowMajor), words)),
            5u32 => Ok((Decoration::ColMajor(DecorationColMajor), words)),
            6u32 => {
                let (array_stride, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::ArrayStride(DecorationArrayStride { array_stride }),
                    words,
                ))
            }
            7u32 => {
                let (matrix_stride, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::MatrixStride(DecorationMatrixStride { matrix_stride }),
                    words,
                ))
            }
            8u32 => Ok((Decoration::GLSLShared(DecorationGLSLShared), words)),
            9u32 => Ok((Decoration::GLSLPacked(DecorationGLSLPacked), words)),
            10u32 => Ok((Decoration::CPacked(DecorationCPacked), words)),
            11u32 => {
                let (built_in, words) = BuiltIn::spirv_parse(words, parse_state)?;
                Ok((Decoration::BuiltIn(DecorationBuiltIn { built_in }), words))
            }
            13u32 => Ok((Decoration::NoPerspective(DecorationNoPerspective), words)),
            14u32 => Ok((Decoration::Flat(DecorationFlat), words)),
            15u32 => Ok((Decoration::Patch(DecorationPatch), words)),
            16u32 => Ok((Decoration::Centroid(DecorationCentroid), words)),
            17u32 => Ok((Decoration::Sample(DecorationSample), words)),
            18u32 => Ok((Decoration::Invariant(DecorationInvariant), words)),
            19u32 => Ok((Decoration::Restrict(DecorationRestrict), words)),
            20u32 => Ok((Decoration::Aliased(DecorationAliased), words)),
            21u32 => Ok((Decoration::Volatile(DecorationVolatile), words)),
            22u32 => Ok((Decoration::Constant(DecorationConstant), words)),
            23u32 => Ok((Decoration::Coherent(DecorationCoherent), words)),
            24u32 => Ok((Decoration::NonWritable(DecorationNonWritable), words)),
            25u32 => Ok((Decoration::NonReadable(DecorationNonReadable), words)),
            26u32 => Ok((Decoration::Uniform(DecorationUniform), words)),
            27u32 => {
                let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::UniformId(DecorationUniformId { execution }),
                    words,
                ))
            }
            28u32 => Ok((
                Decoration::SaturatedConversion(DecorationSaturatedConversion),
                words,
            )),
            29u32 => {
                let (stream_number, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::Stream(DecorationStream { stream_number }),
                    words,
                ))
            }
            30u32 => {
                let (location, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Location(DecorationLocation { location }), words))
            }
            31u32 => {
                let (component, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::Component(DecorationComponent { component }),
                    words,
                ))
            }
            32u32 => {
                let (index, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Index(DecorationIndex { index }), words))
            }
            33u32 => {
                let (binding_point, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::Binding(DecorationBinding { binding_point }),
                    words,
                ))
            }
            34u32 => {
                let (descriptor_set, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::DescriptorSet(DecorationDescriptorSet { descriptor_set }),
                    words,
                ))
            }
            35u32 => {
                let (byte_offset, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Offset(DecorationOffset { byte_offset }), words))
            }
            36u32 => {
                let (xfb_buffer_number, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::XfbBuffer(DecorationXfbBuffer { xfb_buffer_number }),
                    words,
                ))
            }
            37u32 => {
                let (xfb_stride, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::XfbStride(DecorationXfbStride { xfb_stride }),
                    words,
                ))
            }
            38u32 => {
                let (function_parameter_attribute, words) =
                    FunctionParameterAttribute::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::FuncParamAttr(DecorationFuncParamAttr {
                        function_parameter_attribute,
                    }),
                    words,
                ))
            }
            39u32 => {
                let (floating_point_rounding_mode, words) =
                    FPRoundingMode::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::FPRoundingMode(DecorationFPRoundingMode {
                        floating_point_rounding_mode,
                    }),
                    words,
                ))
            }
            40u32 => {
                let (fast_math_mode, words) = FPFastMathMode::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::FPFastMathMode(DecorationFPFastMathMode { fast_math_mode }),
                    words,
                ))
            }
            41u32 => {
                let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
                let (linkage_type, words) = LinkageType::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::LinkageAttributes(DecorationLinkageAttributes {
                        name,
                        linkage_type,
                    }),
                    words,
                ))
            }
            42u32 => Ok((Decoration::NoContraction(DecorationNoContraction), words)),
            43u32 => {
                let (attachment_index, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::InputAttachmentIndex(DecorationInputAttachmentIndex {
                        attachment_index,
                    }),
                    words,
                ))
            }
            44u32 => {
                let (alignment, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::Alignment(DecorationAlignment { alignment }),
                    words,
                ))
            }
            45u32 => {
                let (max_byte_offset, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::MaxByteOffset(DecorationMaxByteOffset { max_byte_offset }),
                    words,
                ))
            }
            46u32 => {
                let (alignment, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::AlignmentId(DecorationAlignmentId { alignment }),
                    words,
                ))
            }
            47u32 => {
                let (max_byte_offset, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::MaxByteOffsetId(DecorationMaxByteOffsetId { max_byte_offset }),
                    words,
                ))
            }
            4469u32 => Ok((Decoration::NoSignedWrap(DecorationNoSignedWrap), words)),
            4470u32 => Ok((Decoration::NoUnsignedWrap(DecorationNoUnsignedWrap), words)),
            5300u32 => Ok((Decoration::NonUniform(DecorationNonUniform), words)),
            5355u32 => Ok((
                Decoration::RestrictPointer(DecorationRestrictPointer),
                words,
            )),
            5356u32 => Ok((Decoration::AliasedPointer(DecorationAliasedPointer), words)),
            5634u32 => {
                let (counter_buffer, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::CounterBuffer(DecorationCounterBuffer { counter_buffer }),
                    words,
                ))
            }
            5635u32 => {
                let (semantic, words) = LiteralString::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::UserSemantic(DecorationUserSemantic { semantic }),
                    words,
                ))
            }
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Decoration {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Decoration::RelaxedPrecision(_) => write!(f, " {}", "RelaxedPrecision"),
            Decoration::SpecId(DecorationSpecId {
                specialization_constant_id,
            }) => {
                write!(f, " {}", "SpecId")?;
                specialization_constant_id.spirv_display(f)?;
                Ok(())
            }
            Decoration::Block(_) => write!(f, " {}", "Block"),
            Decoration::BufferBlock(_) => write!(f, " {}", "BufferBlock"),
            Decoration::RowMajor(_) => write!(f, " {}", "RowMajor"),
            Decoration::ColMajor(_) => write!(f, " {}", "ColMajor"),
            Decoration::ArrayStride(DecorationArrayStride { array_stride }) => {
                write!(f, " {}", "ArrayStride")?;
                array_stride.spirv_display(f)?;
                Ok(())
            }
            Decoration::MatrixStride(DecorationMatrixStride { matrix_stride }) => {
                write!(f, " {}", "MatrixStride")?;
                matrix_stride.spirv_display(f)?;
                Ok(())
            }
            Decoration::GLSLShared(_) => write!(f, " {}", "GLSLShared"),
            Decoration::GLSLPacked(_) => write!(f, " {}", "GLSLPacked"),
            Decoration::CPacked(_) => write!(f, " {}", "CPacked"),
            Decoration::BuiltIn(DecorationBuiltIn { built_in }) => {
                write!(f, " {}", "BuiltIn")?;
                built_in.spirv_display(f)?;
                Ok(())
            }
            Decoration::NoPerspective(_) => write!(f, " {}", "NoPerspective"),
            Decoration::Flat(_) => write!(f, " {}", "Flat"),
            Decoration::Patch(_) => write!(f, " {}", "Patch"),
            Decoration::Centroid(_) => write!(f, " {}", "Centroid"),
            Decoration::Sample(_) => write!(f, " {}", "Sample"),
            Decoration::Invariant(_) => write!(f, " {}", "Invariant"),
            Decoration::Restrict(_) => write!(f, " {}", "Restrict"),
            Decoration::Aliased(_) => write!(f, " {}", "Aliased"),
            Decoration::Volatile(_) => write!(f, " {}", "Volatile"),
            Decoration::Constant(_) => write!(f, " {}", "Constant"),
            Decoration::Coherent(_) => write!(f, " {}", "Coherent"),
            Decoration::NonWritable(_) => write!(f, " {}", "NonWritable"),
            Decoration::NonReadable(_) => write!(f, " {}", "NonReadable"),
            Decoration::Uniform(_) => write!(f, " {}", "Uniform"),
            Decoration::UniformId(DecorationUniformId { execution }) => {
                write!(f, " {}", "UniformId")?;
                execution.spirv_display(f)?;
                Ok(())
            }
            Decoration::SaturatedConversion(_) => write!(f, " {}", "SaturatedConversion"),
            Decoration::Stream(DecorationStream { stream_number }) => {
                write!(f, " {}", "Stream")?;
                stream_number.spirv_display(f)?;
                Ok(())
            }
            Decoration::Location(DecorationLocation { location }) => {
                write!(f, " {}", "Location")?;
                location.spirv_display(f)?;
                Ok(())
            }
            Decoration::Component(DecorationComponent { component }) => {
                write!(f, " {}", "Component")?;
                component.spirv_display(f)?;
                Ok(())
            }
            Decoration::Index(DecorationIndex { index }) => {
                write!(f, " {}", "Index")?;
                index.spirv_display(f)?;
                Ok(())
            }
            Decoration::Binding(DecorationBinding { binding_point }) => {
                write!(f, " {}", "Binding")?;
                binding_point.spirv_display(f)?;
                Ok(())
            }
            Decoration::DescriptorSet(DecorationDescriptorSet { descriptor_set }) => {
                write!(f, " {}", "DescriptorSet")?;
                descriptor_set.spirv_display(f)?;
                Ok(())
            }
            Decoration::Offset(DecorationOffset { byte_offset }) => {
                write!(f, " {}", "Offset")?;
                byte_offset.spirv_display(f)?;
                Ok(())
            }
            Decoration::XfbBuffer(DecorationXfbBuffer { xfb_buffer_number }) => {
                write!(f, " {}", "XfbBuffer")?;
                xfb_buffer_number.spirv_display(f)?;
                Ok(())
            }
            Decoration::XfbStride(DecorationXfbStride { xfb_stride }) => {
                write!(f, " {}", "XfbStride")?;
                xfb_stride.spirv_display(f)?;
                Ok(())
            }
            Decoration::FuncParamAttr(DecorationFuncParamAttr {
                function_parameter_attribute,
            }) => {
                write!(f, " {}", "FuncParamAttr")?;
                function_parameter_attribute.spirv_display(f)?;
                Ok(())
            }
            Decoration::FPRoundingMode(DecorationFPRoundingMode {
                floating_point_rounding_mode,
            }) => {
                write!(f, " {}", "FPRoundingMode")?;
                floating_point_rounding_mode.spirv_display(f)?;
                Ok(())
            }
            Decoration::FPFastMathMode(DecorationFPFastMathMode { fast_math_mode }) => {
                write!(f, " {}", "FPFastMathMode")?;
                fast_math_mode.spirv_display(f)?;
                Ok(())
            }
            Decoration::LinkageAttributes(DecorationLinkageAttributes { name, linkage_type }) => {
                write!(f, " {}", "LinkageAttributes")?;
                name.spirv_display(f)?;
                linkage_type.spirv_display(f)?;
                Ok(())
            }
            Decoration::NoContraction(_) => write!(f, " {}", "NoContraction"),
            Decoration::InputAttachmentIndex(DecorationInputAttachmentIndex {
                attachment_index,
            }) => {
                write!(f, " {}", "InputAttachmentIndex")?;
                attachment_index.spirv_display(f)?;
                Ok(())
            }
            Decoration::Alignment(DecorationAlignment { alignment }) => {
                write!(f, " {}", "Alignment")?;
                alignment.spirv_display(f)?;
                Ok(())
            }
            Decoration::MaxByteOffset(DecorationMaxByteOffset { max_byte_offset }) => {
                write!(f, " {}", "MaxByteOffset")?;
                max_byte_offset.spirv_display(f)?;
                Ok(())
            }
            Decoration::AlignmentId(DecorationAlignmentId { alignment }) => {
                write!(f, " {}", "AlignmentId")?;
                alignment.spirv_display(f)?;
                Ok(())
            }
            Decoration::MaxByteOffsetId(DecorationMaxByteOffsetId { max_byte_offset }) => {
                write!(f, " {}", "MaxByteOffsetId")?;
                max_byte_offset.spirv_display(f)?;
                Ok(())
            }
            Decoration::NoSignedWrap(_) => write!(f, " {}", "NoSignedWrap"),
            Decoration::NoUnsignedWrap(_) => write!(f, " {}", "NoUnsignedWrap"),
            Decoration::NonUniform(_) => write!(f, " {}", "NonUniform"),
            Decoration::RestrictPointer(_) => write!(f, " {}", "RestrictPointer"),
            Decoration::AliasedPointer(_) => write!(f, " {}", "AliasedPointer"),
            Decoration::CounterBuffer(DecorationCounterBuffer { counter_buffer }) => {
                write!(f, " {}", "CounterBuffer")?;
                counter_buffer.spirv_display(f)?;
                Ok(())
            }
            Decoration::UserSemantic(DecorationUserSemantic { semantic }) => {
                write!(f, " {}", "UserSemantic")?;
                semantic.spirv_display(f)?;
                Ok(())
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInPosition;
impl From<BuiltInPosition> for BuiltIn {
    fn from(v: BuiltInPosition) -> Self {
        Self::Position(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInPointSize;
impl From<BuiltInPointSize> for BuiltIn {
    fn from(v: BuiltInPointSize) -> Self {
        Self::PointSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInClipDistance;
impl From<BuiltInClipDistance> for BuiltIn {
    fn from(v: BuiltInClipDistance) -> Self {
        Self::ClipDistance(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInCullDistance;
impl From<BuiltInCullDistance> for BuiltIn {
    fn from(v: BuiltInCullDistance) -> Self {
        Self::CullDistance(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInVertexId;
impl From<BuiltInVertexId> for BuiltIn {
    fn from(v: BuiltInVertexId) -> Self {
        Self::VertexId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInInstanceId;
impl From<BuiltInInstanceId> for BuiltIn {
    fn from(v: BuiltInInstanceId) -> Self {
        Self::InstanceId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInPrimitiveId;
impl From<BuiltInPrimitiveId> for BuiltIn {
    fn from(v: BuiltInPrimitiveId) -> Self {
        Self::PrimitiveId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInInvocationId;
impl From<BuiltInInvocationId> for BuiltIn {
    fn from(v: BuiltInInvocationId) -> Self {
        Self::InvocationId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInLayer;
impl From<BuiltInLayer> for BuiltIn {
    fn from(v: BuiltInLayer) -> Self {
        Self::Layer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInViewportIndex;
impl From<BuiltInViewportIndex> for BuiltIn {
    fn from(v: BuiltInViewportIndex) -> Self {
        Self::ViewportIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInTessLevelOuter;
impl From<BuiltInTessLevelOuter> for BuiltIn {
    fn from(v: BuiltInTessLevelOuter) -> Self {
        Self::TessLevelOuter(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInTessLevelInner;
impl From<BuiltInTessLevelInner> for BuiltIn {
    fn from(v: BuiltInTessLevelInner) -> Self {
        Self::TessLevelInner(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInTessCoord;
impl From<BuiltInTessCoord> for BuiltIn {
    fn from(v: BuiltInTessCoord) -> Self {
        Self::TessCoord(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInPatchVertices;
impl From<BuiltInPatchVertices> for BuiltIn {
    fn from(v: BuiltInPatchVertices) -> Self {
        Self::PatchVertices(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInFragCoord;
impl From<BuiltInFragCoord> for BuiltIn {
    fn from(v: BuiltInFragCoord) -> Self {
        Self::FragCoord(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInPointCoord;
impl From<BuiltInPointCoord> for BuiltIn {
    fn from(v: BuiltInPointCoord) -> Self {
        Self::PointCoord(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInFrontFacing;
impl From<BuiltInFrontFacing> for BuiltIn {
    fn from(v: BuiltInFrontFacing) -> Self {
        Self::FrontFacing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSampleId;
impl From<BuiltInSampleId> for BuiltIn {
    fn from(v: BuiltInSampleId) -> Self {
        Self::SampleId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSamplePosition;
impl From<BuiltInSamplePosition> for BuiltIn {
    fn from(v: BuiltInSamplePosition) -> Self {
        Self::SamplePosition(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSampleMask;
impl From<BuiltInSampleMask> for BuiltIn {
    fn from(v: BuiltInSampleMask) -> Self {
        Self::SampleMask(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInFragDepth;
impl From<BuiltInFragDepth> for BuiltIn {
    fn from(v: BuiltInFragDepth) -> Self {
        Self::FragDepth(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInHelperInvocation;
impl From<BuiltInHelperInvocation> for BuiltIn {
    fn from(v: BuiltInHelperInvocation) -> Self {
        Self::HelperInvocation(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInNumWorkgroups;
impl From<BuiltInNumWorkgroups> for BuiltIn {
    fn from(v: BuiltInNumWorkgroups) -> Self {
        Self::NumWorkgroups(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInWorkgroupSize;
impl From<BuiltInWorkgroupSize> for BuiltIn {
    fn from(v: BuiltInWorkgroupSize) -> Self {
        Self::WorkgroupSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInWorkgroupId;
impl From<BuiltInWorkgroupId> for BuiltIn {
    fn from(v: BuiltInWorkgroupId) -> Self {
        Self::WorkgroupId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInLocalInvocationId;
impl From<BuiltInLocalInvocationId> for BuiltIn {
    fn from(v: BuiltInLocalInvocationId) -> Self {
        Self::LocalInvocationId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInGlobalInvocationId;
impl From<BuiltInGlobalInvocationId> for BuiltIn {
    fn from(v: BuiltInGlobalInvocationId) -> Self {
        Self::GlobalInvocationId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInLocalInvocationIndex;
impl From<BuiltInLocalInvocationIndex> for BuiltIn {
    fn from(v: BuiltInLocalInvocationIndex) -> Self {
        Self::LocalInvocationIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInWorkDim;
impl From<BuiltInWorkDim> for BuiltIn {
    fn from(v: BuiltInWorkDim) -> Self {
        Self::WorkDim(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInGlobalSize;
impl From<BuiltInGlobalSize> for BuiltIn {
    fn from(v: BuiltInGlobalSize) -> Self {
        Self::GlobalSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInEnqueuedWorkgroupSize;
impl From<BuiltInEnqueuedWorkgroupSize> for BuiltIn {
    fn from(v: BuiltInEnqueuedWorkgroupSize) -> Self {
        Self::EnqueuedWorkgroupSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInGlobalOffset;
impl From<BuiltInGlobalOffset> for BuiltIn {
    fn from(v: BuiltInGlobalOffset) -> Self {
        Self::GlobalOffset(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInGlobalLinearId;
impl From<BuiltInGlobalLinearId> for BuiltIn {
    fn from(v: BuiltInGlobalLinearId) -> Self {
        Self::GlobalLinearId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupSize;
impl From<BuiltInSubgroupSize> for BuiltIn {
    fn from(v: BuiltInSubgroupSize) -> Self {
        Self::SubgroupSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupMaxSize;
impl From<BuiltInSubgroupMaxSize> for BuiltIn {
    fn from(v: BuiltInSubgroupMaxSize) -> Self {
        Self::SubgroupMaxSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInNumSubgroups;
impl From<BuiltInNumSubgroups> for BuiltIn {
    fn from(v: BuiltInNumSubgroups) -> Self {
        Self::NumSubgroups(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInNumEnqueuedSubgroups;
impl From<BuiltInNumEnqueuedSubgroups> for BuiltIn {
    fn from(v: BuiltInNumEnqueuedSubgroups) -> Self {
        Self::NumEnqueuedSubgroups(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupId;
impl From<BuiltInSubgroupId> for BuiltIn {
    fn from(v: BuiltInSubgroupId) -> Self {
        Self::SubgroupId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupLocalInvocationId;
impl From<BuiltInSubgroupLocalInvocationId> for BuiltIn {
    fn from(v: BuiltInSubgroupLocalInvocationId) -> Self {
        Self::SubgroupLocalInvocationId(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInVertexIndex;
impl From<BuiltInVertexIndex> for BuiltIn {
    fn from(v: BuiltInVertexIndex) -> Self {
        Self::VertexIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInInstanceIndex;
impl From<BuiltInInstanceIndex> for BuiltIn {
    fn from(v: BuiltInInstanceIndex) -> Self {
        Self::InstanceIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupEqMask;
impl From<BuiltInSubgroupEqMask> for BuiltIn {
    fn from(v: BuiltInSubgroupEqMask) -> Self {
        Self::SubgroupEqMask(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupGeMask;
impl From<BuiltInSubgroupGeMask> for BuiltIn {
    fn from(v: BuiltInSubgroupGeMask) -> Self {
        Self::SubgroupGeMask(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupGtMask;
impl From<BuiltInSubgroupGtMask> for BuiltIn {
    fn from(v: BuiltInSubgroupGtMask) -> Self {
        Self::SubgroupGtMask(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupLeMask;
impl From<BuiltInSubgroupLeMask> for BuiltIn {
    fn from(v: BuiltInSubgroupLeMask) -> Self {
        Self::SubgroupLeMask(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInSubgroupLtMask;
impl From<BuiltInSubgroupLtMask> for BuiltIn {
    fn from(v: BuiltInSubgroupLtMask) -> Self {
        Self::SubgroupLtMask(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInBaseVertex;
impl From<BuiltInBaseVertex> for BuiltIn {
    fn from(v: BuiltInBaseVertex) -> Self {
        Self::BaseVertex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInBaseInstance;
impl From<BuiltInBaseInstance> for BuiltIn {
    fn from(v: BuiltInBaseInstance) -> Self {
        Self::BaseInstance(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInDrawIndex;
impl From<BuiltInDrawIndex> for BuiltIn {
    fn from(v: BuiltInDrawIndex) -> Self {
        Self::DrawIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInDeviceIndex;
impl From<BuiltInDeviceIndex> for BuiltIn {
    fn from(v: BuiltInDeviceIndex) -> Self {
        Self::DeviceIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct BuiltInViewIndex;
impl From<BuiltInViewIndex> for BuiltIn {
    fn from(v: BuiltInViewIndex) -> Self {
        Self::ViewIndex(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum BuiltIn {
    Position(BuiltInPosition),
    PointSize(BuiltInPointSize),
    ClipDistance(BuiltInClipDistance),
    CullDistance(BuiltInCullDistance),
    VertexId(BuiltInVertexId),
    InstanceId(BuiltInInstanceId),
    PrimitiveId(BuiltInPrimitiveId),
    InvocationId(BuiltInInvocationId),
    Layer(BuiltInLayer),
    ViewportIndex(BuiltInViewportIndex),
    TessLevelOuter(BuiltInTessLevelOuter),
    TessLevelInner(BuiltInTessLevelInner),
    TessCoord(BuiltInTessCoord),
    PatchVertices(BuiltInPatchVertices),
    FragCoord(BuiltInFragCoord),
    PointCoord(BuiltInPointCoord),
    FrontFacing(BuiltInFrontFacing),
    SampleId(BuiltInSampleId),
    SamplePosition(BuiltInSamplePosition),
    SampleMask(BuiltInSampleMask),
    FragDepth(BuiltInFragDepth),
    HelperInvocation(BuiltInHelperInvocation),
    NumWorkgroups(BuiltInNumWorkgroups),
    WorkgroupSize(BuiltInWorkgroupSize),
    WorkgroupId(BuiltInWorkgroupId),
    LocalInvocationId(BuiltInLocalInvocationId),
    GlobalInvocationId(BuiltInGlobalInvocationId),
    LocalInvocationIndex(BuiltInLocalInvocationIndex),
    WorkDim(BuiltInWorkDim),
    GlobalSize(BuiltInGlobalSize),
    EnqueuedWorkgroupSize(BuiltInEnqueuedWorkgroupSize),
    GlobalOffset(BuiltInGlobalOffset),
    GlobalLinearId(BuiltInGlobalLinearId),
    SubgroupSize(BuiltInSubgroupSize),
    SubgroupMaxSize(BuiltInSubgroupMaxSize),
    NumSubgroups(BuiltInNumSubgroups),
    NumEnqueuedSubgroups(BuiltInNumEnqueuedSubgroups),
    SubgroupId(BuiltInSubgroupId),
    SubgroupLocalInvocationId(BuiltInSubgroupLocalInvocationId),
    VertexIndex(BuiltInVertexIndex),
    InstanceIndex(BuiltInInstanceIndex),
    SubgroupEqMask(BuiltInSubgroupEqMask),
    SubgroupGeMask(BuiltInSubgroupGeMask),
    SubgroupGtMask(BuiltInSubgroupGtMask),
    SubgroupLeMask(BuiltInSubgroupLeMask),
    SubgroupLtMask(BuiltInSubgroupLtMask),
    BaseVertex(BuiltInBaseVertex),
    BaseInstance(BuiltInBaseInstance),
    DrawIndex(BuiltInDrawIndex),
    DeviceIndex(BuiltInDeviceIndex),
    ViewIndex(BuiltInViewIndex),
}
impl SPIRVParse for BuiltIn {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((BuiltIn::Position(BuiltInPosition), words)),
            1u32 => Ok((BuiltIn::PointSize(BuiltInPointSize), words)),
            3u32 => Ok((BuiltIn::ClipDistance(BuiltInClipDistance), words)),
            4u32 => Ok((BuiltIn::CullDistance(BuiltInCullDistance), words)),
            5u32 => Ok((BuiltIn::VertexId(BuiltInVertexId), words)),
            6u32 => Ok((BuiltIn::InstanceId(BuiltInInstanceId), words)),
            7u32 => Ok((BuiltIn::PrimitiveId(BuiltInPrimitiveId), words)),
            8u32 => Ok((BuiltIn::InvocationId(BuiltInInvocationId), words)),
            9u32 => Ok((BuiltIn::Layer(BuiltInLayer), words)),
            10u32 => Ok((BuiltIn::ViewportIndex(BuiltInViewportIndex), words)),
            11u32 => Ok((BuiltIn::TessLevelOuter(BuiltInTessLevelOuter), words)),
            12u32 => Ok((BuiltIn::TessLevelInner(BuiltInTessLevelInner), words)),
            13u32 => Ok((BuiltIn::TessCoord(BuiltInTessCoord), words)),
            14u32 => Ok((BuiltIn::PatchVertices(BuiltInPatchVertices), words)),
            15u32 => Ok((BuiltIn::FragCoord(BuiltInFragCoord), words)),
            16u32 => Ok((BuiltIn::PointCoord(BuiltInPointCoord), words)),
            17u32 => Ok((BuiltIn::FrontFacing(BuiltInFrontFacing), words)),
            18u32 => Ok((BuiltIn::SampleId(BuiltInSampleId), words)),
            19u32 => Ok((BuiltIn::SamplePosition(BuiltInSamplePosition), words)),
            20u32 => Ok((BuiltIn::SampleMask(BuiltInSampleMask), words)),
            22u32 => Ok((BuiltIn::FragDepth(BuiltInFragDepth), words)),
            23u32 => Ok((BuiltIn::HelperInvocation(BuiltInHelperInvocation), words)),
            24u32 => Ok((BuiltIn::NumWorkgroups(BuiltInNumWorkgroups), words)),
            25u32 => Ok((BuiltIn::WorkgroupSize(BuiltInWorkgroupSize), words)),
            26u32 => Ok((BuiltIn::WorkgroupId(BuiltInWorkgroupId), words)),
            27u32 => Ok((BuiltIn::LocalInvocationId(BuiltInLocalInvocationId), words)),
            28u32 => Ok((
                BuiltIn::GlobalInvocationId(BuiltInGlobalInvocationId),
                words,
            )),
            29u32 => Ok((
                BuiltIn::LocalInvocationIndex(BuiltInLocalInvocationIndex),
                words,
            )),
            30u32 => Ok((BuiltIn::WorkDim(BuiltInWorkDim), words)),
            31u32 => Ok((BuiltIn::GlobalSize(BuiltInGlobalSize), words)),
            32u32 => Ok((
                BuiltIn::EnqueuedWorkgroupSize(BuiltInEnqueuedWorkgroupSize),
                words,
            )),
            33u32 => Ok((BuiltIn::GlobalOffset(BuiltInGlobalOffset), words)),
            34u32 => Ok((BuiltIn::GlobalLinearId(BuiltInGlobalLinearId), words)),
            36u32 => Ok((BuiltIn::SubgroupSize(BuiltInSubgroupSize), words)),
            37u32 => Ok((BuiltIn::SubgroupMaxSize(BuiltInSubgroupMaxSize), words)),
            38u32 => Ok((BuiltIn::NumSubgroups(BuiltInNumSubgroups), words)),
            39u32 => Ok((
                BuiltIn::NumEnqueuedSubgroups(BuiltInNumEnqueuedSubgroups),
                words,
            )),
            40u32 => Ok((BuiltIn::SubgroupId(BuiltInSubgroupId), words)),
            41u32 => Ok((
                BuiltIn::SubgroupLocalInvocationId(BuiltInSubgroupLocalInvocationId),
                words,
            )),
            42u32 => Ok((BuiltIn::VertexIndex(BuiltInVertexIndex), words)),
            43u32 => Ok((BuiltIn::InstanceIndex(BuiltInInstanceIndex), words)),
            4416u32 => Ok((BuiltIn::SubgroupEqMask(BuiltInSubgroupEqMask), words)),
            4417u32 => Ok((BuiltIn::SubgroupGeMask(BuiltInSubgroupGeMask), words)),
            4418u32 => Ok((BuiltIn::SubgroupGtMask(BuiltInSubgroupGtMask), words)),
            4419u32 => Ok((BuiltIn::SubgroupLeMask(BuiltInSubgroupLeMask), words)),
            4420u32 => Ok((BuiltIn::SubgroupLtMask(BuiltInSubgroupLtMask), words)),
            4424u32 => Ok((BuiltIn::BaseVertex(BuiltInBaseVertex), words)),
            4425u32 => Ok((BuiltIn::BaseInstance(BuiltInBaseInstance), words)),
            4426u32 => Ok((BuiltIn::DrawIndex(BuiltInDrawIndex), words)),
            4438u32 => Ok((BuiltIn::DeviceIndex(BuiltInDeviceIndex), words)),
            4440u32 => Ok((BuiltIn::ViewIndex(BuiltInViewIndex), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for BuiltIn {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BuiltIn::Position(_) => write!(f, " {}", "Position"),
            BuiltIn::PointSize(_) => write!(f, " {}", "PointSize"),
            BuiltIn::ClipDistance(_) => write!(f, " {}", "ClipDistance"),
            BuiltIn::CullDistance(_) => write!(f, " {}", "CullDistance"),
            BuiltIn::VertexId(_) => write!(f, " {}", "VertexId"),
            BuiltIn::InstanceId(_) => write!(f, " {}", "InstanceId"),
            BuiltIn::PrimitiveId(_) => write!(f, " {}", "PrimitiveId"),
            BuiltIn::InvocationId(_) => write!(f, " {}", "InvocationId"),
            BuiltIn::Layer(_) => write!(f, " {}", "Layer"),
            BuiltIn::ViewportIndex(_) => write!(f, " {}", "ViewportIndex"),
            BuiltIn::TessLevelOuter(_) => write!(f, " {}", "TessLevelOuter"),
            BuiltIn::TessLevelInner(_) => write!(f, " {}", "TessLevelInner"),
            BuiltIn::TessCoord(_) => write!(f, " {}", "TessCoord"),
            BuiltIn::PatchVertices(_) => write!(f, " {}", "PatchVertices"),
            BuiltIn::FragCoord(_) => write!(f, " {}", "FragCoord"),
            BuiltIn::PointCoord(_) => write!(f, " {}", "PointCoord"),
            BuiltIn::FrontFacing(_) => write!(f, " {}", "FrontFacing"),
            BuiltIn::SampleId(_) => write!(f, " {}", "SampleId"),
            BuiltIn::SamplePosition(_) => write!(f, " {}", "SamplePosition"),
            BuiltIn::SampleMask(_) => write!(f, " {}", "SampleMask"),
            BuiltIn::FragDepth(_) => write!(f, " {}", "FragDepth"),
            BuiltIn::HelperInvocation(_) => write!(f, " {}", "HelperInvocation"),
            BuiltIn::NumWorkgroups(_) => write!(f, " {}", "NumWorkgroups"),
            BuiltIn::WorkgroupSize(_) => write!(f, " {}", "WorkgroupSize"),
            BuiltIn::WorkgroupId(_) => write!(f, " {}", "WorkgroupId"),
            BuiltIn::LocalInvocationId(_) => write!(f, " {}", "LocalInvocationId"),
            BuiltIn::GlobalInvocationId(_) => write!(f, " {}", "GlobalInvocationId"),
            BuiltIn::LocalInvocationIndex(_) => write!(f, " {}", "LocalInvocationIndex"),
            BuiltIn::WorkDim(_) => write!(f, " {}", "WorkDim"),
            BuiltIn::GlobalSize(_) => write!(f, " {}", "GlobalSize"),
            BuiltIn::EnqueuedWorkgroupSize(_) => write!(f, " {}", "EnqueuedWorkgroupSize"),
            BuiltIn::GlobalOffset(_) => write!(f, " {}", "GlobalOffset"),
            BuiltIn::GlobalLinearId(_) => write!(f, " {}", "GlobalLinearId"),
            BuiltIn::SubgroupSize(_) => write!(f, " {}", "SubgroupSize"),
            BuiltIn::SubgroupMaxSize(_) => write!(f, " {}", "SubgroupMaxSize"),
            BuiltIn::NumSubgroups(_) => write!(f, " {}", "NumSubgroups"),
            BuiltIn::NumEnqueuedSubgroups(_) => write!(f, " {}", "NumEnqueuedSubgroups"),
            BuiltIn::SubgroupId(_) => write!(f, " {}", "SubgroupId"),
            BuiltIn::SubgroupLocalInvocationId(_) => write!(f, " {}", "SubgroupLocalInvocationId"),
            BuiltIn::VertexIndex(_) => write!(f, " {}", "VertexIndex"),
            BuiltIn::InstanceIndex(_) => write!(f, " {}", "InstanceIndex"),
            BuiltIn::SubgroupEqMask(_) => write!(f, " {}", "SubgroupEqMask"),
            BuiltIn::SubgroupGeMask(_) => write!(f, " {}", "SubgroupGeMask"),
            BuiltIn::SubgroupGtMask(_) => write!(f, " {}", "SubgroupGtMask"),
            BuiltIn::SubgroupLeMask(_) => write!(f, " {}", "SubgroupLeMask"),
            BuiltIn::SubgroupLtMask(_) => write!(f, " {}", "SubgroupLtMask"),
            BuiltIn::BaseVertex(_) => write!(f, " {}", "BaseVertex"),
            BuiltIn::BaseInstance(_) => write!(f, " {}", "BaseInstance"),
            BuiltIn::DrawIndex(_) => write!(f, " {}", "DrawIndex"),
            BuiltIn::DeviceIndex(_) => write!(f, " {}", "DeviceIndex"),
            BuiltIn::ViewIndex(_) => write!(f, " {}", "ViewIndex"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ScopeCrossDevice;
impl From<ScopeCrossDevice> for Scope {
    fn from(v: ScopeCrossDevice) -> Self {
        Self::CrossDevice(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ScopeDevice;
impl From<ScopeDevice> for Scope {
    fn from(v: ScopeDevice) -> Self {
        Self::Device(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ScopeWorkgroup;
impl From<ScopeWorkgroup> for Scope {
    fn from(v: ScopeWorkgroup) -> Self {
        Self::Workgroup(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ScopeSubgroup;
impl From<ScopeSubgroup> for Scope {
    fn from(v: ScopeSubgroup) -> Self {
        Self::Subgroup(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ScopeInvocation;
impl From<ScopeInvocation> for Scope {
    fn from(v: ScopeInvocation) -> Self {
        Self::Invocation(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct ScopeQueueFamily;
impl From<ScopeQueueFamily> for Scope {
    fn from(v: ScopeQueueFamily) -> Self {
        Self::QueueFamily(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum Scope {
    CrossDevice(ScopeCrossDevice),
    Device(ScopeDevice),
    Workgroup(ScopeWorkgroup),
    Subgroup(ScopeSubgroup),
    Invocation(ScopeInvocation),
    QueueFamily(ScopeQueueFamily),
}
impl SPIRVParse for Scope {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Scope::CrossDevice(ScopeCrossDevice), words)),
            1u32 => Ok((Scope::Device(ScopeDevice), words)),
            2u32 => Ok((Scope::Workgroup(ScopeWorkgroup), words)),
            3u32 => Ok((Scope::Subgroup(ScopeSubgroup), words)),
            4u32 => Ok((Scope::Invocation(ScopeInvocation), words)),
            5u32 => Ok((Scope::QueueFamily(ScopeQueueFamily), words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Scope {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Scope::CrossDevice(_) => write!(f, " {}", "CrossDevice"),
            Scope::Device(_) => write!(f, " {}", "Device"),
            Scope::Workgroup(_) => write!(f, " {}", "Workgroup"),
            Scope::Subgroup(_) => write!(f, " {}", "Subgroup"),
            Scope::Invocation(_) => write!(f, " {}", "Invocation"),
            Scope::QueueFamily(_) => write!(f, " {}", "QueueFamily"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct GroupOperationReduce;
impl From<GroupOperationReduce> for GroupOperation {
    fn from(v: GroupOperationReduce) -> Self {
        Self::Reduce(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct GroupOperationInclusiveScan;
impl From<GroupOperationInclusiveScan> for GroupOperation {
    fn from(v: GroupOperationInclusiveScan) -> Self {
        Self::InclusiveScan(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct GroupOperationExclusiveScan;
impl From<GroupOperationExclusiveScan> for GroupOperation {
    fn from(v: GroupOperationExclusiveScan) -> Self {
        Self::ExclusiveScan(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct GroupOperationClusteredReduce;
impl From<GroupOperationClusteredReduce> for GroupOperation {
    fn from(v: GroupOperationClusteredReduce) -> Self {
        Self::ClusteredReduce(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum GroupOperation {
    Reduce(GroupOperationReduce),
    InclusiveScan(GroupOperationInclusiveScan),
    ExclusiveScan(GroupOperationExclusiveScan),
    ClusteredReduce(GroupOperationClusteredReduce),
}
impl SPIRVParse for GroupOperation {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((GroupOperation::Reduce(GroupOperationReduce), words)),
            1u32 => Ok((
                GroupOperation::InclusiveScan(GroupOperationInclusiveScan),
                words,
            )),
            2u32 => Ok((
                GroupOperation::ExclusiveScan(GroupOperationExclusiveScan),
                words,
            )),
            3u32 => Ok((
                GroupOperation::ClusteredReduce(GroupOperationClusteredReduce),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for GroupOperation {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            GroupOperation::Reduce(_) => write!(f, " {}", "Reduce"),
            GroupOperation::InclusiveScan(_) => write!(f, " {}", "InclusiveScan"),
            GroupOperation::ExclusiveScan(_) => write!(f, " {}", "ExclusiveScan"),
            GroupOperation::ClusteredReduce(_) => write!(f, " {}", "ClusteredReduce"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct KernelEnqueueFlagsNoWait;
impl From<KernelEnqueueFlagsNoWait> for KernelEnqueueFlags {
    fn from(v: KernelEnqueueFlagsNoWait) -> Self {
        Self::NoWait(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct KernelEnqueueFlagsWaitKernel;
impl From<KernelEnqueueFlagsWaitKernel> for KernelEnqueueFlags {
    fn from(v: KernelEnqueueFlagsWaitKernel) -> Self {
        Self::WaitKernel(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct KernelEnqueueFlagsWaitWorkGroup;
impl From<KernelEnqueueFlagsWaitWorkGroup> for KernelEnqueueFlags {
    fn from(v: KernelEnqueueFlagsWaitWorkGroup) -> Self {
        Self::WaitWorkGroup(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum KernelEnqueueFlags {
    NoWait(KernelEnqueueFlagsNoWait),
    WaitKernel(KernelEnqueueFlagsWaitKernel),
    WaitWorkGroup(KernelEnqueueFlagsWaitWorkGroup),
}
impl SPIRVParse for KernelEnqueueFlags {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((KernelEnqueueFlags::NoWait(KernelEnqueueFlagsNoWait), words)),
            1u32 => Ok((
                KernelEnqueueFlags::WaitKernel(KernelEnqueueFlagsWaitKernel),
                words,
            )),
            2u32 => Ok((
                KernelEnqueueFlags::WaitWorkGroup(KernelEnqueueFlagsWaitWorkGroup),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for KernelEnqueueFlags {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            KernelEnqueueFlags::NoWait(_) => write!(f, " {}", "NoWait"),
            KernelEnqueueFlags::WaitKernel(_) => write!(f, " {}", "WaitKernel"),
            KernelEnqueueFlags::WaitWorkGroup(_) => write!(f, " {}", "WaitWorkGroup"),
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityMatrix;
impl From<CapabilityMatrix> for Capability {
    fn from(v: CapabilityMatrix) -> Self {
        Self::Matrix(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityShader;
impl From<CapabilityShader> for Capability {
    fn from(v: CapabilityShader) -> Self {
        Self::Shader(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGeometry;
impl From<CapabilityGeometry> for Capability {
    fn from(v: CapabilityGeometry) -> Self {
        Self::Geometry(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityTessellation;
impl From<CapabilityTessellation> for Capability {
    fn from(v: CapabilityTessellation) -> Self {
        Self::Tessellation(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityAddresses;
impl From<CapabilityAddresses> for Capability {
    fn from(v: CapabilityAddresses) -> Self {
        Self::Addresses(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityLinkage;
impl From<CapabilityLinkage> for Capability {
    fn from(v: CapabilityLinkage) -> Self {
        Self::Linkage(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityKernel;
impl From<CapabilityKernel> for Capability {
    fn from(v: CapabilityKernel) -> Self {
        Self::Kernel(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityVector16;
impl From<CapabilityVector16> for Capability {
    fn from(v: CapabilityVector16) -> Self {
        Self::Vector16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityFloat16Buffer;
impl From<CapabilityFloat16Buffer> for Capability {
    fn from(v: CapabilityFloat16Buffer) -> Self {
        Self::Float16Buffer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityFloat16;
impl From<CapabilityFloat16> for Capability {
    fn from(v: CapabilityFloat16) -> Self {
        Self::Float16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityFloat64;
impl From<CapabilityFloat64> for Capability {
    fn from(v: CapabilityFloat64) -> Self {
        Self::Float64(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInt64;
impl From<CapabilityInt64> for Capability {
    fn from(v: CapabilityInt64) -> Self {
        Self::Int64(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInt64Atomics;
impl From<CapabilityInt64Atomics> for Capability {
    fn from(v: CapabilityInt64Atomics) -> Self {
        Self::Int64Atomics(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageBasic;
impl From<CapabilityImageBasic> for Capability {
    fn from(v: CapabilityImageBasic) -> Self {
        Self::ImageBasic(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageReadWrite;
impl From<CapabilityImageReadWrite> for Capability {
    fn from(v: CapabilityImageReadWrite) -> Self {
        Self::ImageReadWrite(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageMipmap;
impl From<CapabilityImageMipmap> for Capability {
    fn from(v: CapabilityImageMipmap) -> Self {
        Self::ImageMipmap(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityPipes;
impl From<CapabilityPipes> for Capability {
    fn from(v: CapabilityPipes) -> Self {
        Self::Pipes(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroups;
impl From<CapabilityGroups> for Capability {
    fn from(v: CapabilityGroups) -> Self {
        Self::Groups(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityDeviceEnqueue;
impl From<CapabilityDeviceEnqueue> for Capability {
    fn from(v: CapabilityDeviceEnqueue) -> Self {
        Self::DeviceEnqueue(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityLiteralSampler;
impl From<CapabilityLiteralSampler> for Capability {
    fn from(v: CapabilityLiteralSampler) -> Self {
        Self::LiteralSampler(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityAtomicStorage;
impl From<CapabilityAtomicStorage> for Capability {
    fn from(v: CapabilityAtomicStorage) -> Self {
        Self::AtomicStorage(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInt16;
impl From<CapabilityInt16> for Capability {
    fn from(v: CapabilityInt16) -> Self {
        Self::Int16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityTessellationPointSize;
impl From<CapabilityTessellationPointSize> for Capability {
    fn from(v: CapabilityTessellationPointSize) -> Self {
        Self::TessellationPointSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGeometryPointSize;
impl From<CapabilityGeometryPointSize> for Capability {
    fn from(v: CapabilityGeometryPointSize) -> Self {
        Self::GeometryPointSize(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageGatherExtended;
impl From<CapabilityImageGatherExtended> for Capability {
    fn from(v: CapabilityImageGatherExtended) -> Self {
        Self::ImageGatherExtended(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageImageMultisample;
impl From<CapabilityStorageImageMultisample> for Capability {
    fn from(v: CapabilityStorageImageMultisample) -> Self {
        Self::StorageImageMultisample(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityUniformBufferArrayDynamicIndexing;
impl From<CapabilityUniformBufferArrayDynamicIndexing> for Capability {
    fn from(v: CapabilityUniformBufferArrayDynamicIndexing) -> Self {
        Self::UniformBufferArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampledImageArrayDynamicIndexing;
impl From<CapabilitySampledImageArrayDynamicIndexing> for Capability {
    fn from(v: CapabilitySampledImageArrayDynamicIndexing) -> Self {
        Self::SampledImageArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageBufferArrayDynamicIndexing;
impl From<CapabilityStorageBufferArrayDynamicIndexing> for Capability {
    fn from(v: CapabilityStorageBufferArrayDynamicIndexing) -> Self {
        Self::StorageBufferArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageImageArrayDynamicIndexing;
impl From<CapabilityStorageImageArrayDynamicIndexing> for Capability {
    fn from(v: CapabilityStorageImageArrayDynamicIndexing) -> Self {
        Self::StorageImageArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityClipDistance;
impl From<CapabilityClipDistance> for Capability {
    fn from(v: CapabilityClipDistance) -> Self {
        Self::ClipDistance(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityCullDistance;
impl From<CapabilityCullDistance> for Capability {
    fn from(v: CapabilityCullDistance) -> Self {
        Self::CullDistance(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageCubeArray;
impl From<CapabilityImageCubeArray> for Capability {
    fn from(v: CapabilityImageCubeArray) -> Self {
        Self::ImageCubeArray(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampleRateShading;
impl From<CapabilitySampleRateShading> for Capability {
    fn from(v: CapabilitySampleRateShading) -> Self {
        Self::SampleRateShading(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageRect;
impl From<CapabilityImageRect> for Capability {
    fn from(v: CapabilityImageRect) -> Self {
        Self::ImageRect(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampledRect;
impl From<CapabilitySampledRect> for Capability {
    fn from(v: CapabilitySampledRect) -> Self {
        Self::SampledRect(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGenericPointer;
impl From<CapabilityGenericPointer> for Capability {
    fn from(v: CapabilityGenericPointer) -> Self {
        Self::GenericPointer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInt8;
impl From<CapabilityInt8> for Capability {
    fn from(v: CapabilityInt8) -> Self {
        Self::Int8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInputAttachment;
impl From<CapabilityInputAttachment> for Capability {
    fn from(v: CapabilityInputAttachment) -> Self {
        Self::InputAttachment(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySparseResidency;
impl From<CapabilitySparseResidency> for Capability {
    fn from(v: CapabilitySparseResidency) -> Self {
        Self::SparseResidency(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityMinLod;
impl From<CapabilityMinLod> for Capability {
    fn from(v: CapabilityMinLod) -> Self {
        Self::MinLod(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampled1D;
impl From<CapabilitySampled1D> for Capability {
    fn from(v: CapabilitySampled1D) -> Self {
        Self::Sampled1D(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImage1D;
impl From<CapabilityImage1D> for Capability {
    fn from(v: CapabilityImage1D) -> Self {
        Self::Image1D(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampledCubeArray;
impl From<CapabilitySampledCubeArray> for Capability {
    fn from(v: CapabilitySampledCubeArray) -> Self {
        Self::SampledCubeArray(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampledBuffer;
impl From<CapabilitySampledBuffer> for Capability {
    fn from(v: CapabilitySampledBuffer) -> Self {
        Self::SampledBuffer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageBuffer;
impl From<CapabilityImageBuffer> for Capability {
    fn from(v: CapabilityImageBuffer) -> Self {
        Self::ImageBuffer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageMSArray;
impl From<CapabilityImageMSArray> for Capability {
    fn from(v: CapabilityImageMSArray) -> Self {
        Self::ImageMSArray(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageImageExtendedFormats;
impl From<CapabilityStorageImageExtendedFormats> for Capability {
    fn from(v: CapabilityStorageImageExtendedFormats) -> Self {
        Self::StorageImageExtendedFormats(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityImageQuery;
impl From<CapabilityImageQuery> for Capability {
    fn from(v: CapabilityImageQuery) -> Self {
        Self::ImageQuery(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityDerivativeControl;
impl From<CapabilityDerivativeControl> for Capability {
    fn from(v: CapabilityDerivativeControl) -> Self {
        Self::DerivativeControl(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInterpolationFunction;
impl From<CapabilityInterpolationFunction> for Capability {
    fn from(v: CapabilityInterpolationFunction) -> Self {
        Self::InterpolationFunction(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityTransformFeedback;
impl From<CapabilityTransformFeedback> for Capability {
    fn from(v: CapabilityTransformFeedback) -> Self {
        Self::TransformFeedback(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGeometryStreams;
impl From<CapabilityGeometryStreams> for Capability {
    fn from(v: CapabilityGeometryStreams) -> Self {
        Self::GeometryStreams(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageImageReadWithoutFormat;
impl From<CapabilityStorageImageReadWithoutFormat> for Capability {
    fn from(v: CapabilityStorageImageReadWithoutFormat) -> Self {
        Self::StorageImageReadWithoutFormat(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageImageWriteWithoutFormat;
impl From<CapabilityStorageImageWriteWithoutFormat> for Capability {
    fn from(v: CapabilityStorageImageWriteWithoutFormat) -> Self {
        Self::StorageImageWriteWithoutFormat(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityMultiViewport;
impl From<CapabilityMultiViewport> for Capability {
    fn from(v: CapabilityMultiViewport) -> Self {
        Self::MultiViewport(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySubgroupDispatch;
impl From<CapabilitySubgroupDispatch> for Capability {
    fn from(v: CapabilitySubgroupDispatch) -> Self {
        Self::SubgroupDispatch(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityNamedBarrier;
impl From<CapabilityNamedBarrier> for Capability {
    fn from(v: CapabilityNamedBarrier) -> Self {
        Self::NamedBarrier(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityPipeStorage;
impl From<CapabilityPipeStorage> for Capability {
    fn from(v: CapabilityPipeStorage) -> Self {
        Self::PipeStorage(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniform;
impl From<CapabilityGroupNonUniform> for Capability {
    fn from(v: CapabilityGroupNonUniform) -> Self {
        Self::GroupNonUniform(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformVote;
impl From<CapabilityGroupNonUniformVote> for Capability {
    fn from(v: CapabilityGroupNonUniformVote) -> Self {
        Self::GroupNonUniformVote(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformArithmetic;
impl From<CapabilityGroupNonUniformArithmetic> for Capability {
    fn from(v: CapabilityGroupNonUniformArithmetic) -> Self {
        Self::GroupNonUniformArithmetic(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformBallot;
impl From<CapabilityGroupNonUniformBallot> for Capability {
    fn from(v: CapabilityGroupNonUniformBallot) -> Self {
        Self::GroupNonUniformBallot(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformShuffle;
impl From<CapabilityGroupNonUniformShuffle> for Capability {
    fn from(v: CapabilityGroupNonUniformShuffle) -> Self {
        Self::GroupNonUniformShuffle(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformShuffleRelative;
impl From<CapabilityGroupNonUniformShuffleRelative> for Capability {
    fn from(v: CapabilityGroupNonUniformShuffleRelative) -> Self {
        Self::GroupNonUniformShuffleRelative(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformClustered;
impl From<CapabilityGroupNonUniformClustered> for Capability {
    fn from(v: CapabilityGroupNonUniformClustered) -> Self {
        Self::GroupNonUniformClustered(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityGroupNonUniformQuad;
impl From<CapabilityGroupNonUniformQuad> for Capability {
    fn from(v: CapabilityGroupNonUniformQuad) -> Self {
        Self::GroupNonUniformQuad(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityShaderLayer;
impl From<CapabilityShaderLayer> for Capability {
    fn from(v: CapabilityShaderLayer) -> Self {
        Self::ShaderLayer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityShaderViewportIndex;
impl From<CapabilityShaderViewportIndex> for Capability {
    fn from(v: CapabilityShaderViewportIndex) -> Self {
        Self::ShaderViewportIndex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityDrawParameters;
impl From<CapabilityDrawParameters> for Capability {
    fn from(v: CapabilityDrawParameters) -> Self {
        Self::DrawParameters(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageBuffer16BitAccess;
impl From<CapabilityStorageBuffer16BitAccess> for Capability {
    fn from(v: CapabilityStorageBuffer16BitAccess) -> Self {
        Self::StorageBuffer16BitAccess(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityUniformAndStorageBuffer16BitAccess;
impl From<CapabilityUniformAndStorageBuffer16BitAccess> for Capability {
    fn from(v: CapabilityUniformAndStorageBuffer16BitAccess) -> Self {
        Self::UniformAndStorageBuffer16BitAccess(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStoragePushConstant16;
impl From<CapabilityStoragePushConstant16> for Capability {
    fn from(v: CapabilityStoragePushConstant16) -> Self {
        Self::StoragePushConstant16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageInputOutput16;
impl From<CapabilityStorageInputOutput16> for Capability {
    fn from(v: CapabilityStorageInputOutput16) -> Self {
        Self::StorageInputOutput16(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityDeviceGroup;
impl From<CapabilityDeviceGroup> for Capability {
    fn from(v: CapabilityDeviceGroup) -> Self {
        Self::DeviceGroup(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityMultiView;
impl From<CapabilityMultiView> for Capability {
    fn from(v: CapabilityMultiView) -> Self {
        Self::MultiView(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityVariablePointersStorageBuffer;
impl From<CapabilityVariablePointersStorageBuffer> for Capability {
    fn from(v: CapabilityVariablePointersStorageBuffer) -> Self {
        Self::VariablePointersStorageBuffer(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityVariablePointers;
impl From<CapabilityVariablePointers> for Capability {
    fn from(v: CapabilityVariablePointers) -> Self {
        Self::VariablePointers(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageBuffer8BitAccess;
impl From<CapabilityStorageBuffer8BitAccess> for Capability {
    fn from(v: CapabilityStorageBuffer8BitAccess) -> Self {
        Self::StorageBuffer8BitAccess(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityUniformAndStorageBuffer8BitAccess;
impl From<CapabilityUniformAndStorageBuffer8BitAccess> for Capability {
    fn from(v: CapabilityUniformAndStorageBuffer8BitAccess) -> Self {
        Self::UniformAndStorageBuffer8BitAccess(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStoragePushConstant8;
impl From<CapabilityStoragePushConstant8> for Capability {
    fn from(v: CapabilityStoragePushConstant8) -> Self {
        Self::StoragePushConstant8(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityDenormPreserve;
impl From<CapabilityDenormPreserve> for Capability {
    fn from(v: CapabilityDenormPreserve) -> Self {
        Self::DenormPreserve(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityDenormFlushToZero;
impl From<CapabilityDenormFlushToZero> for Capability {
    fn from(v: CapabilityDenormFlushToZero) -> Self {
        Self::DenormFlushToZero(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySignedZeroInfNanPreserve;
impl From<CapabilitySignedZeroInfNanPreserve> for Capability {
    fn from(v: CapabilitySignedZeroInfNanPreserve) -> Self {
        Self::SignedZeroInfNanPreserve(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityRoundingModeRTE;
impl From<CapabilityRoundingModeRTE> for Capability {
    fn from(v: CapabilityRoundingModeRTE) -> Self {
        Self::RoundingModeRTE(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityRoundingModeRTZ;
impl From<CapabilityRoundingModeRTZ> for Capability {
    fn from(v: CapabilityRoundingModeRTZ) -> Self {
        Self::RoundingModeRTZ(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityShaderNonUniform;
impl From<CapabilityShaderNonUniform> for Capability {
    fn from(v: CapabilityShaderNonUniform) -> Self {
        Self::ShaderNonUniform(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityRuntimeDescriptorArray;
impl From<CapabilityRuntimeDescriptorArray> for Capability {
    fn from(v: CapabilityRuntimeDescriptorArray) -> Self {
        Self::RuntimeDescriptorArray(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInputAttachmentArrayDynamicIndexing;
impl From<CapabilityInputAttachmentArrayDynamicIndexing> for Capability {
    fn from(v: CapabilityInputAttachmentArrayDynamicIndexing) -> Self {
        Self::InputAttachmentArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityUniformTexelBufferArrayDynamicIndexing;
impl From<CapabilityUniformTexelBufferArrayDynamicIndexing> for Capability {
    fn from(v: CapabilityUniformTexelBufferArrayDynamicIndexing) -> Self {
        Self::UniformTexelBufferArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageTexelBufferArrayDynamicIndexing;
impl From<CapabilityStorageTexelBufferArrayDynamicIndexing> for Capability {
    fn from(v: CapabilityStorageTexelBufferArrayDynamicIndexing) -> Self {
        Self::StorageTexelBufferArrayDynamicIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityUniformBufferArrayNonUniformIndexing;
impl From<CapabilityUniformBufferArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilityUniformBufferArrayNonUniformIndexing) -> Self {
        Self::UniformBufferArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilitySampledImageArrayNonUniformIndexing;
impl From<CapabilitySampledImageArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilitySampledImageArrayNonUniformIndexing) -> Self {
        Self::SampledImageArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageBufferArrayNonUniformIndexing;
impl From<CapabilityStorageBufferArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilityStorageBufferArrayNonUniformIndexing) -> Self {
        Self::StorageBufferArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageImageArrayNonUniformIndexing;
impl From<CapabilityStorageImageArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilityStorageImageArrayNonUniformIndexing) -> Self {
        Self::StorageImageArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityInputAttachmentArrayNonUniformIndexing;
impl From<CapabilityInputAttachmentArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilityInputAttachmentArrayNonUniformIndexing) -> Self {
        Self::InputAttachmentArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityUniformTexelBufferArrayNonUniformIndexing;
impl From<CapabilityUniformTexelBufferArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilityUniformTexelBufferArrayNonUniformIndexing) -> Self {
        Self::UniformTexelBufferArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityStorageTexelBufferArrayNonUniformIndexing;
impl From<CapabilityStorageTexelBufferArrayNonUniformIndexing> for Capability {
    fn from(v: CapabilityStorageTexelBufferArrayNonUniformIndexing) -> Self {
        Self::StorageTexelBufferArrayNonUniformIndexing(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityVulkanMemoryModel;
impl From<CapabilityVulkanMemoryModel> for Capability {
    fn from(v: CapabilityVulkanMemoryModel) -> Self {
        Self::VulkanMemoryModel(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityVulkanMemoryModelDeviceScope;
impl From<CapabilityVulkanMemoryModelDeviceScope> for Capability {
    fn from(v: CapabilityVulkanMemoryModelDeviceScope) -> Self {
        Self::VulkanMemoryModelDeviceScope(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct CapabilityPhysicalStorageBufferAddresses;
impl From<CapabilityPhysicalStorageBufferAddresses> for Capability {
    fn from(v: CapabilityPhysicalStorageBufferAddresses) -> Self {
        Self::PhysicalStorageBufferAddresses(v)
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum Capability {
    Matrix(CapabilityMatrix),
    Shader(CapabilityShader),
    Geometry(CapabilityGeometry),
    Tessellation(CapabilityTessellation),
    Addresses(CapabilityAddresses),
    Linkage(CapabilityLinkage),
    Kernel(CapabilityKernel),
    Vector16(CapabilityVector16),
    Float16Buffer(CapabilityFloat16Buffer),
    Float16(CapabilityFloat16),
    Float64(CapabilityFloat64),
    Int64(CapabilityInt64),
    Int64Atomics(CapabilityInt64Atomics),
    ImageBasic(CapabilityImageBasic),
    ImageReadWrite(CapabilityImageReadWrite),
    ImageMipmap(CapabilityImageMipmap),
    Pipes(CapabilityPipes),
    Groups(CapabilityGroups),
    DeviceEnqueue(CapabilityDeviceEnqueue),
    LiteralSampler(CapabilityLiteralSampler),
    AtomicStorage(CapabilityAtomicStorage),
    Int16(CapabilityInt16),
    TessellationPointSize(CapabilityTessellationPointSize),
    GeometryPointSize(CapabilityGeometryPointSize),
    ImageGatherExtended(CapabilityImageGatherExtended),
    StorageImageMultisample(CapabilityStorageImageMultisample),
    UniformBufferArrayDynamicIndexing(CapabilityUniformBufferArrayDynamicIndexing),
    SampledImageArrayDynamicIndexing(CapabilitySampledImageArrayDynamicIndexing),
    StorageBufferArrayDynamicIndexing(CapabilityStorageBufferArrayDynamicIndexing),
    StorageImageArrayDynamicIndexing(CapabilityStorageImageArrayDynamicIndexing),
    ClipDistance(CapabilityClipDistance),
    CullDistance(CapabilityCullDistance),
    ImageCubeArray(CapabilityImageCubeArray),
    SampleRateShading(CapabilitySampleRateShading),
    ImageRect(CapabilityImageRect),
    SampledRect(CapabilitySampledRect),
    GenericPointer(CapabilityGenericPointer),
    Int8(CapabilityInt8),
    InputAttachment(CapabilityInputAttachment),
    SparseResidency(CapabilitySparseResidency),
    MinLod(CapabilityMinLod),
    Sampled1D(CapabilitySampled1D),
    Image1D(CapabilityImage1D),
    SampledCubeArray(CapabilitySampledCubeArray),
    SampledBuffer(CapabilitySampledBuffer),
    ImageBuffer(CapabilityImageBuffer),
    ImageMSArray(CapabilityImageMSArray),
    StorageImageExtendedFormats(CapabilityStorageImageExtendedFormats),
    ImageQuery(CapabilityImageQuery),
    DerivativeControl(CapabilityDerivativeControl),
    InterpolationFunction(CapabilityInterpolationFunction),
    TransformFeedback(CapabilityTransformFeedback),
    GeometryStreams(CapabilityGeometryStreams),
    StorageImageReadWithoutFormat(CapabilityStorageImageReadWithoutFormat),
    StorageImageWriteWithoutFormat(CapabilityStorageImageWriteWithoutFormat),
    MultiViewport(CapabilityMultiViewport),
    SubgroupDispatch(CapabilitySubgroupDispatch),
    NamedBarrier(CapabilityNamedBarrier),
    PipeStorage(CapabilityPipeStorage),
    GroupNonUniform(CapabilityGroupNonUniform),
    GroupNonUniformVote(CapabilityGroupNonUniformVote),
    GroupNonUniformArithmetic(CapabilityGroupNonUniformArithmetic),
    GroupNonUniformBallot(CapabilityGroupNonUniformBallot),
    GroupNonUniformShuffle(CapabilityGroupNonUniformShuffle),
    GroupNonUniformShuffleRelative(CapabilityGroupNonUniformShuffleRelative),
    GroupNonUniformClustered(CapabilityGroupNonUniformClustered),
    GroupNonUniformQuad(CapabilityGroupNonUniformQuad),
    ShaderLayer(CapabilityShaderLayer),
    ShaderViewportIndex(CapabilityShaderViewportIndex),
    DrawParameters(CapabilityDrawParameters),
    StorageBuffer16BitAccess(CapabilityStorageBuffer16BitAccess),
    UniformAndStorageBuffer16BitAccess(CapabilityUniformAndStorageBuffer16BitAccess),
    StoragePushConstant16(CapabilityStoragePushConstant16),
    StorageInputOutput16(CapabilityStorageInputOutput16),
    DeviceGroup(CapabilityDeviceGroup),
    MultiView(CapabilityMultiView),
    VariablePointersStorageBuffer(CapabilityVariablePointersStorageBuffer),
    VariablePointers(CapabilityVariablePointers),
    StorageBuffer8BitAccess(CapabilityStorageBuffer8BitAccess),
    UniformAndStorageBuffer8BitAccess(CapabilityUniformAndStorageBuffer8BitAccess),
    StoragePushConstant8(CapabilityStoragePushConstant8),
    DenormPreserve(CapabilityDenormPreserve),
    DenormFlushToZero(CapabilityDenormFlushToZero),
    SignedZeroInfNanPreserve(CapabilitySignedZeroInfNanPreserve),
    RoundingModeRTE(CapabilityRoundingModeRTE),
    RoundingModeRTZ(CapabilityRoundingModeRTZ),
    ShaderNonUniform(CapabilityShaderNonUniform),
    RuntimeDescriptorArray(CapabilityRuntimeDescriptorArray),
    InputAttachmentArrayDynamicIndexing(CapabilityInputAttachmentArrayDynamicIndexing),
    UniformTexelBufferArrayDynamicIndexing(CapabilityUniformTexelBufferArrayDynamicIndexing),
    StorageTexelBufferArrayDynamicIndexing(CapabilityStorageTexelBufferArrayDynamicIndexing),
    UniformBufferArrayNonUniformIndexing(CapabilityUniformBufferArrayNonUniformIndexing),
    SampledImageArrayNonUniformIndexing(CapabilitySampledImageArrayNonUniformIndexing),
    StorageBufferArrayNonUniformIndexing(CapabilityStorageBufferArrayNonUniformIndexing),
    StorageImageArrayNonUniformIndexing(CapabilityStorageImageArrayNonUniformIndexing),
    InputAttachmentArrayNonUniformIndexing(CapabilityInputAttachmentArrayNonUniformIndexing),
    UniformTexelBufferArrayNonUniformIndexing(CapabilityUniformTexelBufferArrayNonUniformIndexing),
    StorageTexelBufferArrayNonUniformIndexing(CapabilityStorageTexelBufferArrayNonUniformIndexing),
    VulkanMemoryModel(CapabilityVulkanMemoryModel),
    VulkanMemoryModelDeviceScope(CapabilityVulkanMemoryModelDeviceScope),
    PhysicalStorageBufferAddresses(CapabilityPhysicalStorageBufferAddresses),
}
impl SPIRVParse for Capability {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Capability::Matrix(CapabilityMatrix), words)),
            1u32 => Ok((Capability::Shader(CapabilityShader), words)),
            2u32 => Ok((Capability::Geometry(CapabilityGeometry), words)),
            3u32 => Ok((Capability::Tessellation(CapabilityTessellation), words)),
            4u32 => Ok((Capability::Addresses(CapabilityAddresses), words)),
            5u32 => Ok((Capability::Linkage(CapabilityLinkage), words)),
            6u32 => Ok((Capability::Kernel(CapabilityKernel), words)),
            7u32 => Ok((Capability::Vector16(CapabilityVector16), words)),
            8u32 => Ok((Capability::Float16Buffer(CapabilityFloat16Buffer), words)),
            9u32 => Ok((Capability::Float16(CapabilityFloat16), words)),
            10u32 => Ok((Capability::Float64(CapabilityFloat64), words)),
            11u32 => Ok((Capability::Int64(CapabilityInt64), words)),
            12u32 => Ok((Capability::Int64Atomics(CapabilityInt64Atomics), words)),
            13u32 => Ok((Capability::ImageBasic(CapabilityImageBasic), words)),
            14u32 => Ok((Capability::ImageReadWrite(CapabilityImageReadWrite), words)),
            15u32 => Ok((Capability::ImageMipmap(CapabilityImageMipmap), words)),
            17u32 => Ok((Capability::Pipes(CapabilityPipes), words)),
            18u32 => Ok((Capability::Groups(CapabilityGroups), words)),
            19u32 => Ok((Capability::DeviceEnqueue(CapabilityDeviceEnqueue), words)),
            20u32 => Ok((Capability::LiteralSampler(CapabilityLiteralSampler), words)),
            21u32 => Ok((Capability::AtomicStorage(CapabilityAtomicStorage), words)),
            22u32 => Ok((Capability::Int16(CapabilityInt16), words)),
            23u32 => Ok((
                Capability::TessellationPointSize(CapabilityTessellationPointSize),
                words,
            )),
            24u32 => Ok((
                Capability::GeometryPointSize(CapabilityGeometryPointSize),
                words,
            )),
            25u32 => Ok((
                Capability::ImageGatherExtended(CapabilityImageGatherExtended),
                words,
            )),
            27u32 => Ok((
                Capability::StorageImageMultisample(CapabilityStorageImageMultisample),
                words,
            )),
            28u32 => Ok((
                Capability::UniformBufferArrayDynamicIndexing(
                    CapabilityUniformBufferArrayDynamicIndexing,
                ),
                words,
            )),
            29u32 => Ok((
                Capability::SampledImageArrayDynamicIndexing(
                    CapabilitySampledImageArrayDynamicIndexing,
                ),
                words,
            )),
            30u32 => Ok((
                Capability::StorageBufferArrayDynamicIndexing(
                    CapabilityStorageBufferArrayDynamicIndexing,
                ),
                words,
            )),
            31u32 => Ok((
                Capability::StorageImageArrayDynamicIndexing(
                    CapabilityStorageImageArrayDynamicIndexing,
                ),
                words,
            )),
            32u32 => Ok((Capability::ClipDistance(CapabilityClipDistance), words)),
            33u32 => Ok((Capability::CullDistance(CapabilityCullDistance), words)),
            34u32 => Ok((Capability::ImageCubeArray(CapabilityImageCubeArray), words)),
            35u32 => Ok((
                Capability::SampleRateShading(CapabilitySampleRateShading),
                words,
            )),
            36u32 => Ok((Capability::ImageRect(CapabilityImageRect), words)),
            37u32 => Ok((Capability::SampledRect(CapabilitySampledRect), words)),
            38u32 => Ok((Capability::GenericPointer(CapabilityGenericPointer), words)),
            39u32 => Ok((Capability::Int8(CapabilityInt8), words)),
            40u32 => Ok((
                Capability::InputAttachment(CapabilityInputAttachment),
                words,
            )),
            41u32 => Ok((
                Capability::SparseResidency(CapabilitySparseResidency),
                words,
            )),
            42u32 => Ok((Capability::MinLod(CapabilityMinLod), words)),
            43u32 => Ok((Capability::Sampled1D(CapabilitySampled1D), words)),
            44u32 => Ok((Capability::Image1D(CapabilityImage1D), words)),
            45u32 => Ok((
                Capability::SampledCubeArray(CapabilitySampledCubeArray),
                words,
            )),
            46u32 => Ok((Capability::SampledBuffer(CapabilitySampledBuffer), words)),
            47u32 => Ok((Capability::ImageBuffer(CapabilityImageBuffer), words)),
            48u32 => Ok((Capability::ImageMSArray(CapabilityImageMSArray), words)),
            49u32 => Ok((
                Capability::StorageImageExtendedFormats(CapabilityStorageImageExtendedFormats),
                words,
            )),
            50u32 => Ok((Capability::ImageQuery(CapabilityImageQuery), words)),
            51u32 => Ok((
                Capability::DerivativeControl(CapabilityDerivativeControl),
                words,
            )),
            52u32 => Ok((
                Capability::InterpolationFunction(CapabilityInterpolationFunction),
                words,
            )),
            53u32 => Ok((
                Capability::TransformFeedback(CapabilityTransformFeedback),
                words,
            )),
            54u32 => Ok((
                Capability::GeometryStreams(CapabilityGeometryStreams),
                words,
            )),
            55u32 => Ok((
                Capability::StorageImageReadWithoutFormat(CapabilityStorageImageReadWithoutFormat),
                words,
            )),
            56u32 => Ok((
                Capability::StorageImageWriteWithoutFormat(
                    CapabilityStorageImageWriteWithoutFormat,
                ),
                words,
            )),
            57u32 => Ok((Capability::MultiViewport(CapabilityMultiViewport), words)),
            58u32 => Ok((
                Capability::SubgroupDispatch(CapabilitySubgroupDispatch),
                words,
            )),
            59u32 => Ok((Capability::NamedBarrier(CapabilityNamedBarrier), words)),
            60u32 => Ok((Capability::PipeStorage(CapabilityPipeStorage), words)),
            61u32 => Ok((
                Capability::GroupNonUniform(CapabilityGroupNonUniform),
                words,
            )),
            62u32 => Ok((
                Capability::GroupNonUniformVote(CapabilityGroupNonUniformVote),
                words,
            )),
            63u32 => Ok((
                Capability::GroupNonUniformArithmetic(CapabilityGroupNonUniformArithmetic),
                words,
            )),
            64u32 => Ok((
                Capability::GroupNonUniformBallot(CapabilityGroupNonUniformBallot),
                words,
            )),
            65u32 => Ok((
                Capability::GroupNonUniformShuffle(CapabilityGroupNonUniformShuffle),
                words,
            )),
            66u32 => Ok((
                Capability::GroupNonUniformShuffleRelative(
                    CapabilityGroupNonUniformShuffleRelative,
                ),
                words,
            )),
            67u32 => Ok((
                Capability::GroupNonUniformClustered(CapabilityGroupNonUniformClustered),
                words,
            )),
            68u32 => Ok((
                Capability::GroupNonUniformQuad(CapabilityGroupNonUniformQuad),
                words,
            )),
            69u32 => Ok((Capability::ShaderLayer(CapabilityShaderLayer), words)),
            70u32 => Ok((
                Capability::ShaderViewportIndex(CapabilityShaderViewportIndex),
                words,
            )),
            4427u32 => Ok((Capability::DrawParameters(CapabilityDrawParameters), words)),
            4433u32 => Ok((
                Capability::StorageBuffer16BitAccess(CapabilityStorageBuffer16BitAccess),
                words,
            )),
            4434u32 => Ok((
                Capability::UniformAndStorageBuffer16BitAccess(
                    CapabilityUniformAndStorageBuffer16BitAccess,
                ),
                words,
            )),
            4435u32 => Ok((
                Capability::StoragePushConstant16(CapabilityStoragePushConstant16),
                words,
            )),
            4436u32 => Ok((
                Capability::StorageInputOutput16(CapabilityStorageInputOutput16),
                words,
            )),
            4437u32 => Ok((Capability::DeviceGroup(CapabilityDeviceGroup), words)),
            4439u32 => Ok((Capability::MultiView(CapabilityMultiView), words)),
            4441u32 => Ok((
                Capability::VariablePointersStorageBuffer(CapabilityVariablePointersStorageBuffer),
                words,
            )),
            4442u32 => Ok((
                Capability::VariablePointers(CapabilityVariablePointers),
                words,
            )),
            4448u32 => Ok((
                Capability::StorageBuffer8BitAccess(CapabilityStorageBuffer8BitAccess),
                words,
            )),
            4449u32 => Ok((
                Capability::UniformAndStorageBuffer8BitAccess(
                    CapabilityUniformAndStorageBuffer8BitAccess,
                ),
                words,
            )),
            4450u32 => Ok((
                Capability::StoragePushConstant8(CapabilityStoragePushConstant8),
                words,
            )),
            4464u32 => Ok((Capability::DenormPreserve(CapabilityDenormPreserve), words)),
            4465u32 => Ok((
                Capability::DenormFlushToZero(CapabilityDenormFlushToZero),
                words,
            )),
            4466u32 => Ok((
                Capability::SignedZeroInfNanPreserve(CapabilitySignedZeroInfNanPreserve),
                words,
            )),
            4467u32 => Ok((
                Capability::RoundingModeRTE(CapabilityRoundingModeRTE),
                words,
            )),
            4468u32 => Ok((
                Capability::RoundingModeRTZ(CapabilityRoundingModeRTZ),
                words,
            )),
            5301u32 => Ok((
                Capability::ShaderNonUniform(CapabilityShaderNonUniform),
                words,
            )),
            5302u32 => Ok((
                Capability::RuntimeDescriptorArray(CapabilityRuntimeDescriptorArray),
                words,
            )),
            5303u32 => Ok((
                Capability::InputAttachmentArrayDynamicIndexing(
                    CapabilityInputAttachmentArrayDynamicIndexing,
                ),
                words,
            )),
            5304u32 => Ok((
                Capability::UniformTexelBufferArrayDynamicIndexing(
                    CapabilityUniformTexelBufferArrayDynamicIndexing,
                ),
                words,
            )),
            5305u32 => Ok((
                Capability::StorageTexelBufferArrayDynamicIndexing(
                    CapabilityStorageTexelBufferArrayDynamicIndexing,
                ),
                words,
            )),
            5306u32 => Ok((
                Capability::UniformBufferArrayNonUniformIndexing(
                    CapabilityUniformBufferArrayNonUniformIndexing,
                ),
                words,
            )),
            5307u32 => Ok((
                Capability::SampledImageArrayNonUniformIndexing(
                    CapabilitySampledImageArrayNonUniformIndexing,
                ),
                words,
            )),
            5308u32 => Ok((
                Capability::StorageBufferArrayNonUniformIndexing(
                    CapabilityStorageBufferArrayNonUniformIndexing,
                ),
                words,
            )),
            5309u32 => Ok((
                Capability::StorageImageArrayNonUniformIndexing(
                    CapabilityStorageImageArrayNonUniformIndexing,
                ),
                words,
            )),
            5310u32 => Ok((
                Capability::InputAttachmentArrayNonUniformIndexing(
                    CapabilityInputAttachmentArrayNonUniformIndexing,
                ),
                words,
            )),
            5311u32 => Ok((
                Capability::UniformTexelBufferArrayNonUniformIndexing(
                    CapabilityUniformTexelBufferArrayNonUniformIndexing,
                ),
                words,
            )),
            5312u32 => Ok((
                Capability::StorageTexelBufferArrayNonUniformIndexing(
                    CapabilityStorageTexelBufferArrayNonUniformIndexing,
                ),
                words,
            )),
            5345u32 => Ok((
                Capability::VulkanMemoryModel(CapabilityVulkanMemoryModel),
                words,
            )),
            5346u32 => Ok((
                Capability::VulkanMemoryModelDeviceScope(CapabilityVulkanMemoryModelDeviceScope),
                words,
            )),
            5347u32 => Ok((
                Capability::PhysicalStorageBufferAddresses(
                    CapabilityPhysicalStorageBufferAddresses,
                ),
                words,
            )),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Capability {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Capability::Matrix(_) => write!(f, " {}", "Matrix"),
            Capability::Shader(_) => write!(f, " {}", "Shader"),
            Capability::Geometry(_) => write!(f, " {}", "Geometry"),
            Capability::Tessellation(_) => write!(f, " {}", "Tessellation"),
            Capability::Addresses(_) => write!(f, " {}", "Addresses"),
            Capability::Linkage(_) => write!(f, " {}", "Linkage"),
            Capability::Kernel(_) => write!(f, " {}", "Kernel"),
            Capability::Vector16(_) => write!(f, " {}", "Vector16"),
            Capability::Float16Buffer(_) => write!(f, " {}", "Float16Buffer"),
            Capability::Float16(_) => write!(f, " {}", "Float16"),
            Capability::Float64(_) => write!(f, " {}", "Float64"),
            Capability::Int64(_) => write!(f, " {}", "Int64"),
            Capability::Int64Atomics(_) => write!(f, " {}", "Int64Atomics"),
            Capability::ImageBasic(_) => write!(f, " {}", "ImageBasic"),
            Capability::ImageReadWrite(_) => write!(f, " {}", "ImageReadWrite"),
            Capability::ImageMipmap(_) => write!(f, " {}", "ImageMipmap"),
            Capability::Pipes(_) => write!(f, " {}", "Pipes"),
            Capability::Groups(_) => write!(f, " {}", "Groups"),
            Capability::DeviceEnqueue(_) => write!(f, " {}", "DeviceEnqueue"),
            Capability::LiteralSampler(_) => write!(f, " {}", "LiteralSampler"),
            Capability::AtomicStorage(_) => write!(f, " {}", "AtomicStorage"),
            Capability::Int16(_) => write!(f, " {}", "Int16"),
            Capability::TessellationPointSize(_) => write!(f, " {}", "TessellationPointSize"),
            Capability::GeometryPointSize(_) => write!(f, " {}", "GeometryPointSize"),
            Capability::ImageGatherExtended(_) => write!(f, " {}", "ImageGatherExtended"),
            Capability::StorageImageMultisample(_) => write!(f, " {}", "StorageImageMultisample"),
            Capability::UniformBufferArrayDynamicIndexing(_) => {
                write!(f, " {}", "UniformBufferArrayDynamicIndexing")
            }
            Capability::SampledImageArrayDynamicIndexing(_) => {
                write!(f, " {}", "SampledImageArrayDynamicIndexing")
            }
            Capability::StorageBufferArrayDynamicIndexing(_) => {
                write!(f, " {}", "StorageBufferArrayDynamicIndexing")
            }
            Capability::StorageImageArrayDynamicIndexing(_) => {
                write!(f, " {}", "StorageImageArrayDynamicIndexing")
            }
            Capability::ClipDistance(_) => write!(f, " {}", "ClipDistance"),
            Capability::CullDistance(_) => write!(f, " {}", "CullDistance"),
            Capability::ImageCubeArray(_) => write!(f, " {}", "ImageCubeArray"),
            Capability::SampleRateShading(_) => write!(f, " {}", "SampleRateShading"),
            Capability::ImageRect(_) => write!(f, " {}", "ImageRect"),
            Capability::SampledRect(_) => write!(f, " {}", "SampledRect"),
            Capability::GenericPointer(_) => write!(f, " {}", "GenericPointer"),
            Capability::Int8(_) => write!(f, " {}", "Int8"),
            Capability::InputAttachment(_) => write!(f, " {}", "InputAttachment"),
            Capability::SparseResidency(_) => write!(f, " {}", "SparseResidency"),
            Capability::MinLod(_) => write!(f, " {}", "MinLod"),
            Capability::Sampled1D(_) => write!(f, " {}", "Sampled1D"),
            Capability::Image1D(_) => write!(f, " {}", "Image1D"),
            Capability::SampledCubeArray(_) => write!(f, " {}", "SampledCubeArray"),
            Capability::SampledBuffer(_) => write!(f, " {}", "SampledBuffer"),
            Capability::ImageBuffer(_) => write!(f, " {}", "ImageBuffer"),
            Capability::ImageMSArray(_) => write!(f, " {}", "ImageMSArray"),
            Capability::StorageImageExtendedFormats(_) => {
                write!(f, " {}", "StorageImageExtendedFormats")
            }
            Capability::ImageQuery(_) => write!(f, " {}", "ImageQuery"),
            Capability::DerivativeControl(_) => write!(f, " {}", "DerivativeControl"),
            Capability::InterpolationFunction(_) => write!(f, " {}", "InterpolationFunction"),
            Capability::TransformFeedback(_) => write!(f, " {}", "TransformFeedback"),
            Capability::GeometryStreams(_) => write!(f, " {}", "GeometryStreams"),
            Capability::StorageImageReadWithoutFormat(_) => {
                write!(f, " {}", "StorageImageReadWithoutFormat")
            }
            Capability::StorageImageWriteWithoutFormat(_) => {
                write!(f, " {}", "StorageImageWriteWithoutFormat")
            }
            Capability::MultiViewport(_) => write!(f, " {}", "MultiViewport"),
            Capability::SubgroupDispatch(_) => write!(f, " {}", "SubgroupDispatch"),
            Capability::NamedBarrier(_) => write!(f, " {}", "NamedBarrier"),
            Capability::PipeStorage(_) => write!(f, " {}", "PipeStorage"),
            Capability::GroupNonUniform(_) => write!(f, " {}", "GroupNonUniform"),
            Capability::GroupNonUniformVote(_) => write!(f, " {}", "GroupNonUniformVote"),
            Capability::GroupNonUniformArithmetic(_) => {
                write!(f, " {}", "GroupNonUniformArithmetic")
            }
            Capability::GroupNonUniformBallot(_) => write!(f, " {}", "GroupNonUniformBallot"),
            Capability::GroupNonUniformShuffle(_) => write!(f, " {}", "GroupNonUniformShuffle"),
            Capability::GroupNonUniformShuffleRelative(_) => {
                write!(f, " {}", "GroupNonUniformShuffleRelative")
            }
            Capability::GroupNonUniformClustered(_) => write!(f, " {}", "GroupNonUniformClustered"),
            Capability::GroupNonUniformQuad(_) => write!(f, " {}", "GroupNonUniformQuad"),
            Capability::ShaderLayer(_) => write!(f, " {}", "ShaderLayer"),
            Capability::ShaderViewportIndex(_) => write!(f, " {}", "ShaderViewportIndex"),
            Capability::DrawParameters(_) => write!(f, " {}", "DrawParameters"),
            Capability::StorageBuffer16BitAccess(_) => write!(f, " {}", "StorageBuffer16BitAccess"),
            Capability::UniformAndStorageBuffer16BitAccess(_) => {
                write!(f, " {}", "UniformAndStorageBuffer16BitAccess")
            }
            Capability::StoragePushConstant16(_) => write!(f, " {}", "StoragePushConstant16"),
            Capability::StorageInputOutput16(_) => write!(f, " {}", "StorageInputOutput16"),
            Capability::DeviceGroup(_) => write!(f, " {}", "DeviceGroup"),
            Capability::MultiView(_) => write!(f, " {}", "MultiView"),
            Capability::VariablePointersStorageBuffer(_) => {
                write!(f, " {}", "VariablePointersStorageBuffer")
            }
            Capability::VariablePointers(_) => write!(f, " {}", "VariablePointers"),
            Capability::StorageBuffer8BitAccess(_) => write!(f, " {}", "StorageBuffer8BitAccess"),
            Capability::UniformAndStorageBuffer8BitAccess(_) => {
                write!(f, " {}", "UniformAndStorageBuffer8BitAccess")
            }
            Capability::StoragePushConstant8(_) => write!(f, " {}", "StoragePushConstant8"),
            Capability::DenormPreserve(_) => write!(f, " {}", "DenormPreserve"),
            Capability::DenormFlushToZero(_) => write!(f, " {}", "DenormFlushToZero"),
            Capability::SignedZeroInfNanPreserve(_) => write!(f, " {}", "SignedZeroInfNanPreserve"),
            Capability::RoundingModeRTE(_) => write!(f, " {}", "RoundingModeRTE"),
            Capability::RoundingModeRTZ(_) => write!(f, " {}", "RoundingModeRTZ"),
            Capability::ShaderNonUniform(_) => write!(f, " {}", "ShaderNonUniform"),
            Capability::RuntimeDescriptorArray(_) => write!(f, " {}", "RuntimeDescriptorArray"),
            Capability::InputAttachmentArrayDynamicIndexing(_) => {
                write!(f, " {}", "InputAttachmentArrayDynamicIndexing")
            }
            Capability::UniformTexelBufferArrayDynamicIndexing(_) => {
                write!(f, " {}", "UniformTexelBufferArrayDynamicIndexing")
            }
            Capability::StorageTexelBufferArrayDynamicIndexing(_) => {
                write!(f, " {}", "StorageTexelBufferArrayDynamicIndexing")
            }
            Capability::UniformBufferArrayNonUniformIndexing(_) => {
                write!(f, " {}", "UniformBufferArrayNonUniformIndexing")
            }
            Capability::SampledImageArrayNonUniformIndexing(_) => {
                write!(f, " {}", "SampledImageArrayNonUniformIndexing")
            }
            Capability::StorageBufferArrayNonUniformIndexing(_) => {
                write!(f, " {}", "StorageBufferArrayNonUniformIndexing")
            }
            Capability::StorageImageArrayNonUniformIndexing(_) => {
                write!(f, " {}", "StorageImageArrayNonUniformIndexing")
            }
            Capability::InputAttachmentArrayNonUniformIndexing(_) => {
                write!(f, " {}", "InputAttachmentArrayNonUniformIndexing")
            }
            Capability::UniformTexelBufferArrayNonUniformIndexing(_) => {
                write!(f, " {}", "UniformTexelBufferArrayNonUniformIndexing")
            }
            Capability::StorageTexelBufferArrayNonUniformIndexing(_) => {
                write!(f, " {}", "StorageTexelBufferArrayNonUniformIndexing")
            }
            Capability::VulkanMemoryModel(_) => write!(f, " {}", "VulkanMemoryModel"),
            Capability::VulkanMemoryModelDeviceScope(_) => {
                write!(f, " {}", "VulkanMemoryModelDeviceScope")
            }
            Capability::PhysicalStorageBufferAddresses(_) => {
                write!(f, " {}", "PhysicalStorageBufferAddresses")
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdResultType(pub IdRef);
impl SPIRVParse for IdResultType {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state).map(|(value, words)| (IdResultType(value), words))
    }
}
impl fmt::Display for IdResultType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdResultType {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdResult(pub IdRef);
impl SPIRVParse for IdResult {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state).map(|(value, words)| (IdResult(value), words))
    }
}
impl fmt::Display for IdResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdResult {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdMemorySemantics(pub IdRef);
impl SPIRVParse for IdMemorySemantics {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state)
            .map(|(value, words)| (IdMemorySemantics(value), words))
    }
}
impl fmt::Display for IdMemorySemantics {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdMemorySemantics {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdScope(pub IdRef);
impl SPIRVParse for IdScope {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state).map(|(value, words)| (IdScope(value), words))
    }
}
impl fmt::Display for IdScope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdScope {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdRef(pub u32);
pub type LiteralInteger32 = u32;
pub type LiteralInteger64 = u64;
pub type LiteralString = String;
pub type LiteralContextDependentNumber32 = u32;
pub type LiteralContextDependentNumber64 = u64;
pub type LiteralExtInstInteger = u32;
pub type PairLiteralInteger32IdRef = (LiteralInteger32, IdRef);
pub type PairLiteralInteger64IdRef = (LiteralInteger64, IdRef);
pub type PairIdRefLiteralInteger = (IdRef, LiteralInteger32);
pub type PairIdRefIdRef = (IdRef, IdRef);
#[derive(Clone, Debug)]
pub enum OpSpecConstantOp {
    AccessChain(OpAccessChain),
    InBoundsAccessChain(OpInBoundsAccessChain),
    PtrAccessChain(OpPtrAccessChain),
    InBoundsPtrAccessChain(OpInBoundsPtrAccessChain),
    VectorShuffle(OpVectorShuffle),
    CompositeExtract(OpCompositeExtract),
    CompositeInsert(OpCompositeInsert),
    ConvertFToU(OpConvertFToU),
    ConvertFToS(OpConvertFToS),
    ConvertSToF(OpConvertSToF),
    ConvertUToF(OpConvertUToF),
    UConvert(OpUConvert),
    SConvert(OpSConvert),
    FConvert(OpFConvert),
    QuantizeToF16(OpQuantizeToF16),
    ConvertPtrToU(OpConvertPtrToU),
    ConvertUToPtr(OpConvertUToPtr),
    PtrCastToGeneric(OpPtrCastToGeneric),
    GenericCastToPtr(OpGenericCastToPtr),
    Bitcast(OpBitcast),
    SNegate(OpSNegate),
    FNegate(OpFNegate),
    IAdd(OpIAdd),
    FAdd(OpFAdd),
    ISub(OpISub),
    FSub(OpFSub),
    IMul(OpIMul),
    FMul(OpFMul),
    UDiv(OpUDiv),
    SDiv(OpSDiv),
    FDiv(OpFDiv),
    UMod(OpUMod),
    SRem(OpSRem),
    SMod(OpSMod),
    FRem(OpFRem),
    FMod(OpFMod),
    LogicalEqual(OpLogicalEqual),
    LogicalNotEqual(OpLogicalNotEqual),
    LogicalOr(OpLogicalOr),
    LogicalAnd(OpLogicalAnd),
    LogicalNot(OpLogicalNot),
    Select(OpSelect),
    IEqual(OpIEqual),
    INotEqual(OpINotEqual),
    UGreaterThan(OpUGreaterThan),
    SGreaterThan(OpSGreaterThan),
    UGreaterThanEqual(OpUGreaterThanEqual),
    SGreaterThanEqual(OpSGreaterThanEqual),
    ULessThan(OpULessThan),
    SLessThan(OpSLessThan),
    ULessThanEqual(OpULessThanEqual),
    SLessThanEqual(OpSLessThanEqual),
    ShiftRightLogical(OpShiftRightLogical),
    ShiftRightArithmetic(OpShiftRightArithmetic),
    ShiftLeftLogical(OpShiftLeftLogical),
    BitwiseOr(OpBitwiseOr),
    BitwiseXor(OpBitwiseXor),
    BitwiseAnd(OpBitwiseAnd),
    Not(OpNot),
}
impl fmt::Display for OpSpecConstantOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            OpSpecConstantOp::AccessChain(OpAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "AccessChain")?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::InBoundsAccessChain(OpInBoundsAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "InBoundsAccessChain")?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::PtrAccessChain(OpPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "PtrAccessChain")?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::InBoundsPtrAccessChain(OpInBoundsPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "InBoundsPtrAccessChain")?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::VectorShuffle(OpVectorShuffle {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
                components,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "VectorShuffle")?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                components.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::CompositeExtract(OpCompositeExtract {
                id_result_type,
                id_result,
                composite,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "CompositeExtract")?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::CompositeInsert(OpCompositeInsert {
                id_result_type,
                id_result,
                object,
                composite,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "CompositeInsert")?;
                object.spirv_display(f)?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertFToU(OpConvertFToU {
                id_result_type,
                id_result,
                float_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertFToU")?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertFToS(OpConvertFToS {
                id_result_type,
                id_result,
                float_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertFToS")?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertSToF(OpConvertSToF {
                id_result_type,
                id_result,
                signed_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertSToF")?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertUToF(OpConvertUToF {
                id_result_type,
                id_result,
                unsigned_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertUToF")?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UConvert(OpUConvert {
                id_result_type,
                id_result,
                unsigned_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UConvert")?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SConvert(OpSConvert {
                id_result_type,
                id_result,
                signed_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SConvert")?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FConvert(OpFConvert {
                id_result_type,
                id_result,
                float_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FConvert")?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::QuantizeToF16(OpQuantizeToF16 {
                id_result_type,
                id_result,
                value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "QuantizeToF16")?;
                value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertPtrToU(OpConvertPtrToU {
                id_result_type,
                id_result,
                pointer,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertPtrToU")?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertUToPtr(OpConvertUToPtr {
                id_result_type,
                id_result,
                integer_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertUToPtr")?;
                integer_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::PtrCastToGeneric(OpPtrCastToGeneric {
                id_result_type,
                id_result,
                pointer,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "PtrCastToGeneric")?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::GenericCastToPtr(OpGenericCastToPtr {
                id_result_type,
                id_result,
                pointer,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "GenericCastToPtr")?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::Bitcast(OpBitcast {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "Bitcast")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SNegate(OpSNegate {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SNegate")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FNegate(OpFNegate {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FNegate")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::IAdd(OpIAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "IAdd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FAdd(OpFAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FAdd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ISub(OpISub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ISub")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FSub(OpFSub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FSub")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::IMul(OpIMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "IMul")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FMul(OpFMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FMul")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UDiv(OpUDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UDiv")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SDiv(OpSDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SDiv")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FDiv(OpFDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FDiv")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UMod(OpUMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UMod")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SRem(OpSRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SRem")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SMod(OpSMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SMod")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FRem(OpFRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FRem")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FMod(OpFMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FMod")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalEqual(OpLogicalEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalNotEqual(OpLogicalNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalNotEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalOr(OpLogicalOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalOr")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalAnd(OpLogicalAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalAnd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalNot(OpLogicalNot {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalNot")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::Select(OpSelect {
                id_result_type,
                id_result,
                condition,
                object_1,
                object_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "Select")?;
                condition.spirv_display(f)?;
                object_1.spirv_display(f)?;
                object_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::IEqual(OpIEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "IEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::INotEqual(OpINotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "INotEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UGreaterThan(OpUGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UGreaterThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SGreaterThan(OpSGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SGreaterThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UGreaterThanEqual(OpUGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UGreaterThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SGreaterThanEqual(OpSGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SGreaterThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ULessThan(OpULessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ULessThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SLessThan(OpSLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SLessThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ULessThanEqual(OpULessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ULessThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SLessThanEqual(OpSLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SLessThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ShiftRightLogical(OpShiftRightLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ShiftRightLogical")?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ShiftRightArithmetic(OpShiftRightArithmetic {
                id_result_type,
                id_result,
                base,
                shift,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ShiftRightArithmetic")?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ShiftLeftLogical(OpShiftLeftLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ShiftLeftLogical")?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::BitwiseOr(OpBitwiseOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "BitwiseOr")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::BitwiseXor(OpBitwiseXor {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "BitwiseXor")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::BitwiseAnd(OpBitwiseAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "BitwiseAnd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::Not(OpNot {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "Not")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpNop;
impl From<OpNop> for Instruction {
    fn from(v: OpNop) -> Self {
        Self::Nop(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUndef {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpUndef> for Instruction {
    fn from(v: OpUndef) -> Self {
        Self::Undef(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSourceContinued {
    pub continued_source: LiteralString,
}
impl From<OpSourceContinued> for Instruction {
    fn from(v: OpSourceContinued) -> Self {
        Self::SourceContinued(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSource {
    pub source_language: SourceLanguage,
    pub version: LiteralInteger32,
    pub file: Option<IdRef>,
    pub source: Option<LiteralString>,
}
impl From<OpSource> for Instruction {
    fn from(v: OpSource) -> Self {
        Self::Source(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSourceExtension {
    pub extension: LiteralString,
}
impl From<OpSourceExtension> for Instruction {
    fn from(v: OpSourceExtension) -> Self {
        Self::SourceExtension(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpName {
    pub target: IdRef,
    pub name: LiteralString,
}
impl From<OpName> for Instruction {
    fn from(v: OpName) -> Self {
        Self::Name(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemberName {
    pub type_: IdRef,
    pub member: LiteralInteger32,
    pub name: LiteralString,
}
impl From<OpMemberName> for Instruction {
    fn from(v: OpMemberName) -> Self {
        Self::MemberName(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpString {
    pub id_result: IdResult,
    pub string: LiteralString,
}
impl From<OpString> for Instruction {
    fn from(v: OpString) -> Self {
        Self::String(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLine {
    pub file: IdRef,
    pub line: LiteralInteger32,
    pub column: LiteralInteger32,
}
impl From<OpLine> for Instruction {
    fn from(v: OpLine) -> Self {
        Self::Line(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExtension {
    pub name: LiteralString,
}
impl From<OpExtension> for Instruction {
    fn from(v: OpExtension) -> Self {
        Self::Extension(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExtInstImport {
    pub id_result: IdResult,
    pub name: LiteralString,
}
impl From<OpExtInstImport> for Instruction {
    fn from(v: OpExtInstImport) -> Self {
        Self::ExtInstImport(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExtInst {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub instruction: LiteralExtInstInteger,
    pub operands: Vec<LiteralInteger32>,
}
impl From<OpExtInst> for Instruction {
    fn from(v: OpExtInst) -> Self {
        Self::ExtInst(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemoryModel {
    pub addressing_model: AddressingModel,
    pub memory_model: MemoryModel,
}
impl From<OpMemoryModel> for Instruction {
    fn from(v: OpMemoryModel) -> Self {
        Self::MemoryModel(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEntryPoint {
    pub execution_model: ExecutionModel,
    pub entry_point: IdRef,
    pub name: LiteralString,
    pub interface: Vec<IdRef>,
}
impl From<OpEntryPoint> for Instruction {
    fn from(v: OpEntryPoint) -> Self {
        Self::EntryPoint(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExecutionMode {
    pub entry_point: IdRef,
    pub mode: ExecutionMode,
}
impl From<OpExecutionMode> for Instruction {
    fn from(v: OpExecutionMode) -> Self {
        Self::ExecutionMode(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCapability {
    pub capability: Capability,
}
impl From<OpCapability> for Instruction {
    fn from(v: OpCapability) -> Self {
        Self::Capability(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeVoid {
    pub id_result: IdResult,
}
impl From<OpTypeVoid> for Instruction {
    fn from(v: OpTypeVoid) -> Self {
        Self::TypeVoid(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeBool {
    pub id_result: IdResult,
}
impl From<OpTypeBool> for Instruction {
    fn from(v: OpTypeBool) -> Self {
        Self::TypeBool(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeInt {
    pub id_result: IdResult,
    pub width: LiteralInteger32,
    pub signedness: LiteralInteger32,
}
impl From<OpTypeInt> for Instruction {
    fn from(v: OpTypeInt) -> Self {
        Self::TypeInt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeFloat {
    pub id_result: IdResult,
    pub width: LiteralInteger32,
}
impl From<OpTypeFloat> for Instruction {
    fn from(v: OpTypeFloat) -> Self {
        Self::TypeFloat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeVector {
    pub id_result: IdResult,
    pub component_type: IdRef,
    pub component_count: LiteralInteger32,
}
impl From<OpTypeVector> for Instruction {
    fn from(v: OpTypeVector) -> Self {
        Self::TypeVector(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeMatrix {
    pub id_result: IdResult,
    pub column_type: IdRef,
    pub column_count: LiteralInteger32,
}
impl From<OpTypeMatrix> for Instruction {
    fn from(v: OpTypeMatrix) -> Self {
        Self::TypeMatrix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeImage {
    pub id_result: IdResult,
    pub sampled_type: IdRef,
    pub dim: Dim,
    pub depth: LiteralInteger32,
    pub arrayed: LiteralInteger32,
    pub ms: LiteralInteger32,
    pub sampled: LiteralInteger32,
    pub image_format: ImageFormat,
    pub access_qualifier: Option<AccessQualifier>,
}
impl From<OpTypeImage> for Instruction {
    fn from(v: OpTypeImage) -> Self {
        Self::TypeImage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeSampler {
    pub id_result: IdResult,
}
impl From<OpTypeSampler> for Instruction {
    fn from(v: OpTypeSampler) -> Self {
        Self::TypeSampler(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeSampledImage {
    pub id_result: IdResult,
    pub image_type: IdRef,
}
impl From<OpTypeSampledImage> for Instruction {
    fn from(v: OpTypeSampledImage) -> Self {
        Self::TypeSampledImage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeArray {
    pub id_result: IdResult,
    pub element_type: IdRef,
    pub length: IdRef,
}
impl From<OpTypeArray> for Instruction {
    fn from(v: OpTypeArray) -> Self {
        Self::TypeArray(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeRuntimeArray {
    pub id_result: IdResult,
    pub element_type: IdRef,
}
impl From<OpTypeRuntimeArray> for Instruction {
    fn from(v: OpTypeRuntimeArray) -> Self {
        Self::TypeRuntimeArray(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeStruct {
    pub id_result: IdResult,
    pub member_types: Vec<IdRef>,
}
impl From<OpTypeStruct> for Instruction {
    fn from(v: OpTypeStruct) -> Self {
        Self::TypeStruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeOpaque {
    pub id_result: IdResult,
    pub the_name_of_the_opaque_type: LiteralString,
}
impl From<OpTypeOpaque> for Instruction {
    fn from(v: OpTypeOpaque) -> Self {
        Self::TypeOpaque(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypePointer {
    pub id_result: IdResult,
    pub storage_class: StorageClass,
    pub type_: IdRef,
}
impl From<OpTypePointer> for Instruction {
    fn from(v: OpTypePointer) -> Self {
        Self::TypePointer(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeFunction {
    pub id_result: IdResult,
    pub return_type: IdRef,
    pub parameter_types: Vec<IdRef>,
}
impl From<OpTypeFunction> for Instruction {
    fn from(v: OpTypeFunction) -> Self {
        Self::TypeFunction(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeEvent {
    pub id_result: IdResult,
}
impl From<OpTypeEvent> for Instruction {
    fn from(v: OpTypeEvent) -> Self {
        Self::TypeEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeDeviceEvent {
    pub id_result: IdResult,
}
impl From<OpTypeDeviceEvent> for Instruction {
    fn from(v: OpTypeDeviceEvent) -> Self {
        Self::TypeDeviceEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeReserveId {
    pub id_result: IdResult,
}
impl From<OpTypeReserveId> for Instruction {
    fn from(v: OpTypeReserveId) -> Self {
        Self::TypeReserveId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeQueue {
    pub id_result: IdResult,
}
impl From<OpTypeQueue> for Instruction {
    fn from(v: OpTypeQueue) -> Self {
        Self::TypeQueue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypePipe {
    pub id_result: IdResult,
    pub qualifier: AccessQualifier,
}
impl From<OpTypePipe> for Instruction {
    fn from(v: OpTypePipe) -> Self {
        Self::TypePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeForwardPointer {
    pub pointer_type: IdRef,
    pub storage_class: StorageClass,
}
impl From<OpTypeForwardPointer> for Instruction {
    fn from(v: OpTypeForwardPointer) -> Self {
        Self::TypeForwardPointer(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantTrue {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpConstantTrue> for Instruction {
    fn from(v: OpConstantTrue) -> Self {
        Self::ConstantTrue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantFalse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpConstantFalse> for Instruction {
    fn from(v: OpConstantFalse) -> Self {
        Self::ConstantFalse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstant32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber32,
}
impl From<OpConstant32> for Instruction {
    fn from(v: OpConstant32) -> Self {
        Self::Constant32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstant64 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber64,
}
impl From<OpConstant64> for Instruction {
    fn from(v: OpConstant64) -> Self {
        Self::Constant64(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantComposite {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub constituents: Vec<IdRef>,
}
impl From<OpConstantComposite> for Instruction {
    fn from(v: OpConstantComposite) -> Self {
        Self::ConstantComposite(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantSampler {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampler_addressing_mode: SamplerAddressingMode,
    pub param: LiteralInteger32,
    pub sampler_filter_mode: SamplerFilterMode,
}
impl From<OpConstantSampler> for Instruction {
    fn from(v: OpConstantSampler) -> Self {
        Self::ConstantSampler(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantNull {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpConstantNull> for Instruction {
    fn from(v: OpConstantNull) -> Self {
        Self::ConstantNull(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstantTrue {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpSpecConstantTrue> for Instruction {
    fn from(v: OpSpecConstantTrue) -> Self {
        Self::SpecConstantTrue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstantFalse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpSpecConstantFalse> for Instruction {
    fn from(v: OpSpecConstantFalse) -> Self {
        Self::SpecConstantFalse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstant32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber32,
}
impl From<OpSpecConstant32> for Instruction {
    fn from(v: OpSpecConstant32) -> Self {
        Self::SpecConstant32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstant64 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber64,
}
impl From<OpSpecConstant64> for Instruction {
    fn from(v: OpSpecConstant64) -> Self {
        Self::SpecConstant64(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstantComposite {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub constituents: Vec<IdRef>,
}
impl From<OpSpecConstantComposite> for Instruction {
    fn from(v: OpSpecConstantComposite) -> Self {
        Self::SpecConstantComposite(v)
    }
}
impl From<OpSpecConstantOp> for Instruction {
    fn from(v: OpSpecConstantOp) -> Self {
        Self::SpecConstantOp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFunction {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub function_control: FunctionControl,
    pub function_type: IdRef,
}
impl From<OpFunction> for Instruction {
    fn from(v: OpFunction) -> Self {
        Self::Function(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFunctionParameter {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpFunctionParameter> for Instruction {
    fn from(v: OpFunctionParameter) -> Self {
        Self::FunctionParameter(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpFunctionEnd;
impl From<OpFunctionEnd> for Instruction {
    fn from(v: OpFunctionEnd) -> Self {
        Self::FunctionEnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFunctionCall {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub function: IdRef,
    pub arguments: Vec<IdRef>,
}
impl From<OpFunctionCall> for Instruction {
    fn from(v: OpFunctionCall) -> Self {
        Self::FunctionCall(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVariable {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub storage_class: StorageClass,
    pub initializer: Option<IdRef>,
}
impl From<OpVariable> for Instruction {
    fn from(v: OpVariable) -> Self {
        Self::Variable(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageTexelPointer {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub sample: IdRef,
}
impl From<OpImageTexelPointer> for Instruction {
    fn from(v: OpImageTexelPointer) -> Self {
        Self::ImageTexelPointer(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLoad {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory_access: Option<MemoryAccess>,
}
impl From<OpLoad> for Instruction {
    fn from(v: OpLoad) -> Self {
        Self::Load(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpStore {
    pub pointer: IdRef,
    pub object: IdRef,
    pub memory_access: Option<MemoryAccess>,
}
impl From<OpStore> for Instruction {
    fn from(v: OpStore) -> Self {
        Self::Store(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyMemory {
    pub target: IdRef,
    pub source: IdRef,
    pub memory_access: Option<MemoryAccess>,
    pub source_memory_access: Option<MemoryAccess>,
}
impl From<OpCopyMemory> for Instruction {
    fn from(v: OpCopyMemory) -> Self {
        Self::CopyMemory(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyMemorySized {
    pub target: IdRef,
    pub source: IdRef,
    pub size: IdRef,
    pub memory_access: Option<MemoryAccess>,
    pub source_memory_access: Option<MemoryAccess>,
}
impl From<OpCopyMemorySized> for Instruction {
    fn from(v: OpCopyMemorySized) -> Self {
        Self::CopyMemorySized(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpAccessChain> for Instruction {
    fn from(v: OpAccessChain) -> Self {
        Self::AccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpInBoundsAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpInBoundsAccessChain> for Instruction {
    fn from(v: OpInBoundsAccessChain) -> Self {
        Self::InBoundsAccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub element: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpPtrAccessChain> for Instruction {
    fn from(v: OpPtrAccessChain) -> Self {
        Self::PtrAccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpArrayLength {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub structure: IdRef,
    pub array_member: LiteralInteger32,
}
impl From<OpArrayLength> for Instruction {
    fn from(v: OpArrayLength) -> Self {
        Self::ArrayLength(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGenericPtrMemSemantics {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpGenericPtrMemSemantics> for Instruction {
    fn from(v: OpGenericPtrMemSemantics) -> Self {
        Self::GenericPtrMemSemantics(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpInBoundsPtrAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub element: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpInBoundsPtrAccessChain> for Instruction {
    fn from(v: OpInBoundsPtrAccessChain) -> Self {
        Self::InBoundsPtrAccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorate {
    pub target: IdRef,
    pub decoration: Decoration,
}
impl From<OpDecorate> for Instruction {
    fn from(v: OpDecorate) -> Self {
        Self::Decorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemberDecorate {
    pub structure_type: IdRef,
    pub member: LiteralInteger32,
    pub decoration: Decoration,
}
impl From<OpMemberDecorate> for Instruction {
    fn from(v: OpMemberDecorate) -> Self {
        Self::MemberDecorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorationGroup {
    pub id_result: IdResult,
}
impl From<OpDecorationGroup> for Instruction {
    fn from(v: OpDecorationGroup) -> Self {
        Self::DecorationGroup(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupDecorate {
    pub decoration_group: IdRef,
    pub targets: Vec<IdRef>,
}
impl From<OpGroupDecorate> for Instruction {
    fn from(v: OpGroupDecorate) -> Self {
        Self::GroupDecorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupMemberDecorate {
    pub decoration_group: IdRef,
    pub targets: Vec<PairIdRefLiteralInteger>,
}
impl From<OpGroupMemberDecorate> for Instruction {
    fn from(v: OpGroupMemberDecorate) -> Self {
        Self::GroupMemberDecorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorExtractDynamic {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub index: IdRef,
}
impl From<OpVectorExtractDynamic> for Instruction {
    fn from(v: OpVectorExtractDynamic) -> Self {
        Self::VectorExtractDynamic(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorInsertDynamic {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub component: IdRef,
    pub index: IdRef,
}
impl From<OpVectorInsertDynamic> for Instruction {
    fn from(v: OpVectorInsertDynamic) -> Self {
        Self::VectorInsertDynamic(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorShuffle {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector_1: IdRef,
    pub vector_2: IdRef,
    pub components: Vec<LiteralInteger32>,
}
impl From<OpVectorShuffle> for Instruction {
    fn from(v: OpVectorShuffle) -> Self {
        Self::VectorShuffle(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCompositeConstruct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub constituents: Vec<IdRef>,
}
impl From<OpCompositeConstruct> for Instruction {
    fn from(v: OpCompositeConstruct) -> Self {
        Self::CompositeConstruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCompositeExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub composite: IdRef,
    pub indexes: Vec<LiteralInteger32>,
}
impl From<OpCompositeExtract> for Instruction {
    fn from(v: OpCompositeExtract) -> Self {
        Self::CompositeExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCompositeInsert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub object: IdRef,
    pub composite: IdRef,
    pub indexes: Vec<LiteralInteger32>,
}
impl From<OpCompositeInsert> for Instruction {
    fn from(v: OpCompositeInsert) -> Self {
        Self::CompositeInsert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyObject {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpCopyObject> for Instruction {
    fn from(v: OpCopyObject) -> Self {
        Self::CopyObject(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTranspose {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub matrix: IdRef,
}
impl From<OpTranspose> for Instruction {
    fn from(v: OpTranspose) -> Self {
        Self::Transpose(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSampledImage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub sampler: IdRef,
}
impl From<OpSampledImage> for Instruction {
    fn from(v: OpSampledImage) -> Self {
        Self::SampledImage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleImplicitLod> for Instruction {
    fn from(v: OpImageSampleImplicitLod) -> Self {
        Self::ImageSampleImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleExplicitLod> for Instruction {
    fn from(v: OpImageSampleExplicitLod) -> Self {
        Self::ImageSampleExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleDrefImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleDrefImplicitLod> for Instruction {
    fn from(v: OpImageSampleDrefImplicitLod) -> Self {
        Self::ImageSampleDrefImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleDrefExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleDrefExplicitLod> for Instruction {
    fn from(v: OpImageSampleDrefExplicitLod) -> Self {
        Self::ImageSampleDrefExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleProjImplicitLod> for Instruction {
    fn from(v: OpImageSampleProjImplicitLod) -> Self {
        Self::ImageSampleProjImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleProjExplicitLod> for Instruction {
    fn from(v: OpImageSampleProjExplicitLod) -> Self {
        Self::ImageSampleProjExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjDrefImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleProjDrefImplicitLod> for Instruction {
    fn from(v: OpImageSampleProjDrefImplicitLod) -> Self {
        Self::ImageSampleProjDrefImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjDrefExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleProjDrefExplicitLod> for Instruction {
    fn from(v: OpImageSampleProjDrefExplicitLod) -> Self {
        Self::ImageSampleProjDrefExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageFetch {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageFetch> for Instruction {
    fn from(v: OpImageFetch) -> Self {
        Self::ImageFetch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub component: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageGather> for Instruction {
    fn from(v: OpImageGather) -> Self {
        Self::ImageGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageDrefGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageDrefGather> for Instruction {
    fn from(v: OpImageDrefGather) -> Self {
        Self::ImageDrefGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageRead {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageRead> for Instruction {
    fn from(v: OpImageRead) -> Self {
        Self::ImageRead(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageWrite {
    pub image: IdRef,
    pub coordinate: IdRef,
    pub texel: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageWrite> for Instruction {
    fn from(v: OpImageWrite) -> Self {
        Self::ImageWrite(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
}
impl From<OpImage> for Instruction {
    fn from(v: OpImage) -> Self {
        Self::Image(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryFormat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQueryFormat> for Instruction {
    fn from(v: OpImageQueryFormat) -> Self {
        Self::ImageQueryFormat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryOrder {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQueryOrder> for Instruction {
    fn from(v: OpImageQueryOrder) -> Self {
        Self::ImageQueryOrder(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQuerySizeLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub level_of_detail: IdRef,
}
impl From<OpImageQuerySizeLod> for Instruction {
    fn from(v: OpImageQuerySizeLod) -> Self {
        Self::ImageQuerySizeLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQuerySize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQuerySize> for Instruction {
    fn from(v: OpImageQuerySize) -> Self {
        Self::ImageQuerySize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
}
impl From<OpImageQueryLod> for Instruction {
    fn from(v: OpImageQueryLod) -> Self {
        Self::ImageQueryLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryLevels {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQueryLevels> for Instruction {
    fn from(v: OpImageQueryLevels) -> Self {
        Self::ImageQueryLevels(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQuerySamples {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQuerySamples> for Instruction {
    fn from(v: OpImageQuerySamples) -> Self {
        Self::ImageQuerySamples(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertFToU {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub float_value: IdRef,
}
impl From<OpConvertFToU> for Instruction {
    fn from(v: OpConvertFToU) -> Self {
        Self::ConvertFToU(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertFToS {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub float_value: IdRef,
}
impl From<OpConvertFToS> for Instruction {
    fn from(v: OpConvertFToS) -> Self {
        Self::ConvertFToS(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertSToF {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub signed_value: IdRef,
}
impl From<OpConvertSToF> for Instruction {
    fn from(v: OpConvertSToF) -> Self {
        Self::ConvertSToF(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertUToF {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub unsigned_value: IdRef,
}
impl From<OpConvertUToF> for Instruction {
    fn from(v: OpConvertUToF) -> Self {
        Self::ConvertUToF(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUConvert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub unsigned_value: IdRef,
}
impl From<OpUConvert> for Instruction {
    fn from(v: OpUConvert) -> Self {
        Self::UConvert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSConvert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub signed_value: IdRef,
}
impl From<OpSConvert> for Instruction {
    fn from(v: OpSConvert) -> Self {
        Self::SConvert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFConvert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub float_value: IdRef,
}
impl From<OpFConvert> for Instruction {
    fn from(v: OpFConvert) -> Self {
        Self::FConvert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpQuantizeToF16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: IdRef,
}
impl From<OpQuantizeToF16> for Instruction {
    fn from(v: OpQuantizeToF16) -> Self {
        Self::QuantizeToF16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertPtrToU {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpConvertPtrToU> for Instruction {
    fn from(v: OpConvertPtrToU) -> Self {
        Self::ConvertPtrToU(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSatConvertSToU {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub signed_value: IdRef,
}
impl From<OpSatConvertSToU> for Instruction {
    fn from(v: OpSatConvertSToU) -> Self {
        Self::SatConvertSToU(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSatConvertUToS {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub unsigned_value: IdRef,
}
impl From<OpSatConvertUToS> for Instruction {
    fn from(v: OpSatConvertUToS) -> Self {
        Self::SatConvertUToS(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertUToPtr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub integer_value: IdRef,
}
impl From<OpConvertUToPtr> for Instruction {
    fn from(v: OpConvertUToPtr) -> Self {
        Self::ConvertUToPtr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrCastToGeneric {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpPtrCastToGeneric> for Instruction {
    fn from(v: OpPtrCastToGeneric) -> Self {
        Self::PtrCastToGeneric(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGenericCastToPtr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpGenericCastToPtr> for Instruction {
    fn from(v: OpGenericCastToPtr) -> Self {
        Self::GenericCastToPtr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGenericCastToPtrExplicit {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub storage: StorageClass,
}
impl From<OpGenericCastToPtrExplicit> for Instruction {
    fn from(v: OpGenericCastToPtrExplicit) -> Self {
        Self::GenericCastToPtrExplicit(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpBitcast> for Instruction {
    fn from(v: OpBitcast) -> Self {
        Self::Bitcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSNegate {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpSNegate> for Instruction {
    fn from(v: OpSNegate) -> Self {
        Self::SNegate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFNegate {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpFNegate> for Instruction {
    fn from(v: OpFNegate) -> Self {
        Self::FNegate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIAdd> for Instruction {
    fn from(v: OpIAdd) -> Self {
        Self::IAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFAdd> for Instruction {
    fn from(v: OpFAdd) -> Self {
        Self::FAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpISub {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpISub> for Instruction {
    fn from(v: OpISub) -> Self {
        Self::ISub(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFSub {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFSub> for Instruction {
    fn from(v: OpFSub) -> Self {
        Self::FSub(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIMul> for Instruction {
    fn from(v: OpIMul) -> Self {
        Self::IMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFMul> for Instruction {
    fn from(v: OpFMul) -> Self {
        Self::FMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUDiv {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUDiv> for Instruction {
    fn from(v: OpUDiv) -> Self {
        Self::UDiv(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSDiv {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSDiv> for Instruction {
    fn from(v: OpSDiv) -> Self {
        Self::SDiv(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFDiv {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFDiv> for Instruction {
    fn from(v: OpFDiv) -> Self {
        Self::FDiv(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUMod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUMod> for Instruction {
    fn from(v: OpUMod) -> Self {
        Self::UMod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSRem {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSRem> for Instruction {
    fn from(v: OpSRem) -> Self {
        Self::SRem(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSMod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSMod> for Instruction {
    fn from(v: OpSMod) -> Self {
        Self::SMod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFRem {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFRem> for Instruction {
    fn from(v: OpFRem) -> Self {
        Self::FRem(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFMod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFMod> for Instruction {
    fn from(v: OpFMod) -> Self {
        Self::FMod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorTimesScalar {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub scalar: IdRef,
}
impl From<OpVectorTimesScalar> for Instruction {
    fn from(v: OpVectorTimesScalar) -> Self {
        Self::VectorTimesScalar(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMatrixTimesScalar {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub matrix: IdRef,
    pub scalar: IdRef,
}
impl From<OpMatrixTimesScalar> for Instruction {
    fn from(v: OpMatrixTimesScalar) -> Self {
        Self::MatrixTimesScalar(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorTimesMatrix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub matrix: IdRef,
}
impl From<OpVectorTimesMatrix> for Instruction {
    fn from(v: OpVectorTimesMatrix) -> Self {
        Self::VectorTimesMatrix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMatrixTimesVector {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub matrix: IdRef,
    pub vector: IdRef,
}
impl From<OpMatrixTimesVector> for Instruction {
    fn from(v: OpMatrixTimesVector) -> Self {
        Self::MatrixTimesVector(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMatrixTimesMatrix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub left_matrix: IdRef,
    pub right_matrix: IdRef,
}
impl From<OpMatrixTimesMatrix> for Instruction {
    fn from(v: OpMatrixTimesMatrix) -> Self {
        Self::MatrixTimesMatrix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOuterProduct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector_1: IdRef,
    pub vector_2: IdRef,
}
impl From<OpOuterProduct> for Instruction {
    fn from(v: OpOuterProduct) -> Self {
        Self::OuterProduct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector_1: IdRef,
    pub vector_2: IdRef,
}
impl From<OpDot> for Instruction {
    fn from(v: OpDot) -> Self {
        Self::Dot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIAddCarry {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIAddCarry> for Instruction {
    fn from(v: OpIAddCarry) -> Self {
        Self::IAddCarry(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpISubBorrow {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpISubBorrow> for Instruction {
    fn from(v: OpISubBorrow) -> Self {
        Self::ISubBorrow(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUMulExtended {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUMulExtended> for Instruction {
    fn from(v: OpUMulExtended) -> Self {
        Self::UMulExtended(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSMulExtended {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSMulExtended> for Instruction {
    fn from(v: OpSMulExtended) -> Self {
        Self::SMulExtended(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAny {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
}
impl From<OpAny> for Instruction {
    fn from(v: OpAny) -> Self {
        Self::Any(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAll {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
}
impl From<OpAll> for Instruction {
    fn from(v: OpAll) -> Self {
        Self::All(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsNan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsNan> for Instruction {
    fn from(v: OpIsNan) -> Self {
        Self::IsNan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsInf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsInf> for Instruction {
    fn from(v: OpIsInf) -> Self {
        Self::IsInf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsFinite {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsFinite> for Instruction {
    fn from(v: OpIsFinite) -> Self {
        Self::IsFinite(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsNormal {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsNormal> for Instruction {
    fn from(v: OpIsNormal) -> Self {
        Self::IsNormal(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSignBitSet {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpSignBitSet> for Instruction {
    fn from(v: OpSignBitSet) -> Self {
        Self::SignBitSet(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLessOrGreater {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpLessOrGreater> for Instruction {
    fn from(v: OpLessOrGreater) -> Self {
        Self::LessOrGreater(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOrdered {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOrdered> for Instruction {
    fn from(v: OpOrdered) -> Self {
        Self::Ordered(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUnordered {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpUnordered> for Instruction {
    fn from(v: OpUnordered) -> Self {
        Self::Unordered(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalEqual> for Instruction {
    fn from(v: OpLogicalEqual) -> Self {
        Self::LogicalEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalNotEqual> for Instruction {
    fn from(v: OpLogicalNotEqual) -> Self {
        Self::LogicalNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalOr> for Instruction {
    fn from(v: OpLogicalOr) -> Self {
        Self::LogicalOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalAnd> for Instruction {
    fn from(v: OpLogicalAnd) -> Self {
        Self::LogicalAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalNot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpLogicalNot> for Instruction {
    fn from(v: OpLogicalNot) -> Self {
        Self::LogicalNot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSelect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub condition: IdRef,
    pub object_1: IdRef,
    pub object_2: IdRef,
}
impl From<OpSelect> for Instruction {
    fn from(v: OpSelect) -> Self {
        Self::Select(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIEqual> for Instruction {
    fn from(v: OpIEqual) -> Self {
        Self::IEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpINotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpINotEqual> for Instruction {
    fn from(v: OpINotEqual) -> Self {
        Self::INotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUGreaterThan> for Instruction {
    fn from(v: OpUGreaterThan) -> Self {
        Self::UGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSGreaterThan> for Instruction {
    fn from(v: OpSGreaterThan) -> Self {
        Self::SGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUGreaterThanEqual> for Instruction {
    fn from(v: OpUGreaterThanEqual) -> Self {
        Self::UGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSGreaterThanEqual> for Instruction {
    fn from(v: OpSGreaterThanEqual) -> Self {
        Self::SGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpULessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpULessThan> for Instruction {
    fn from(v: OpULessThan) -> Self {
        Self::ULessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSLessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSLessThan> for Instruction {
    fn from(v: OpSLessThan) -> Self {
        Self::SLessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpULessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpULessThanEqual> for Instruction {
    fn from(v: OpULessThanEqual) -> Self {
        Self::ULessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSLessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSLessThanEqual> for Instruction {
    fn from(v: OpSLessThanEqual) -> Self {
        Self::SLessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdEqual> for Instruction {
    fn from(v: OpFOrdEqual) -> Self {
        Self::FOrdEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordEqual> for Instruction {
    fn from(v: OpFUnordEqual) -> Self {
        Self::FUnordEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdNotEqual> for Instruction {
    fn from(v: OpFOrdNotEqual) -> Self {
        Self::FOrdNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordNotEqual> for Instruction {
    fn from(v: OpFUnordNotEqual) -> Self {
        Self::FUnordNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdLessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdLessThan> for Instruction {
    fn from(v: OpFOrdLessThan) -> Self {
        Self::FOrdLessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordLessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordLessThan> for Instruction {
    fn from(v: OpFUnordLessThan) -> Self {
        Self::FUnordLessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdGreaterThan> for Instruction {
    fn from(v: OpFOrdGreaterThan) -> Self {
        Self::FOrdGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordGreaterThan> for Instruction {
    fn from(v: OpFUnordGreaterThan) -> Self {
        Self::FUnordGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdLessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdLessThanEqual> for Instruction {
    fn from(v: OpFOrdLessThanEqual) -> Self {
        Self::FOrdLessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordLessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordLessThanEqual> for Instruction {
    fn from(v: OpFUnordLessThanEqual) -> Self {
        Self::FUnordLessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdGreaterThanEqual> for Instruction {
    fn from(v: OpFOrdGreaterThanEqual) -> Self {
        Self::FOrdGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordGreaterThanEqual> for Instruction {
    fn from(v: OpFUnordGreaterThanEqual) -> Self {
        Self::FUnordGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpShiftRightLogical {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub shift: IdRef,
}
impl From<OpShiftRightLogical> for Instruction {
    fn from(v: OpShiftRightLogical) -> Self {
        Self::ShiftRightLogical(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpShiftRightArithmetic {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub shift: IdRef,
}
impl From<OpShiftRightArithmetic> for Instruction {
    fn from(v: OpShiftRightArithmetic) -> Self {
        Self::ShiftRightArithmetic(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpShiftLeftLogical {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub shift: IdRef,
}
impl From<OpShiftLeftLogical> for Instruction {
    fn from(v: OpShiftLeftLogical) -> Self {
        Self::ShiftLeftLogical(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitwiseOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpBitwiseOr> for Instruction {
    fn from(v: OpBitwiseOr) -> Self {
        Self::BitwiseOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitwiseXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpBitwiseXor> for Instruction {
    fn from(v: OpBitwiseXor) -> Self {
        Self::BitwiseXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitwiseAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpBitwiseAnd> for Instruction {
    fn from(v: OpBitwiseAnd) -> Self {
        Self::BitwiseAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpNot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpNot> for Instruction {
    fn from(v: OpNot) -> Self {
        Self::Not(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitFieldInsert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub insert: IdRef,
    pub offset: IdRef,
    pub count: IdRef,
}
impl From<OpBitFieldInsert> for Instruction {
    fn from(v: OpBitFieldInsert) -> Self {
        Self::BitFieldInsert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitFieldSExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub offset: IdRef,
    pub count: IdRef,
}
impl From<OpBitFieldSExtract> for Instruction {
    fn from(v: OpBitFieldSExtract) -> Self {
        Self::BitFieldSExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitFieldUExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub offset: IdRef,
    pub count: IdRef,
}
impl From<OpBitFieldUExtract> for Instruction {
    fn from(v: OpBitFieldUExtract) -> Self {
        Self::BitFieldUExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitReverse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
}
impl From<OpBitReverse> for Instruction {
    fn from(v: OpBitReverse) -> Self {
        Self::BitReverse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
}
impl From<OpBitCount> for Instruction {
    fn from(v: OpBitCount) -> Self {
        Self::BitCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdx {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdx> for Instruction {
    fn from(v: OpDPdx) -> Self {
        Self::DPdx(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdy {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdy> for Instruction {
    fn from(v: OpDPdy) -> Self {
        Self::DPdy(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFwidth {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpFwidth> for Instruction {
    fn from(v: OpFwidth) -> Self {
        Self::Fwidth(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdxFine {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdxFine> for Instruction {
    fn from(v: OpDPdxFine) -> Self {
        Self::DPdxFine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdyFine {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdyFine> for Instruction {
    fn from(v: OpDPdyFine) -> Self {
        Self::DPdyFine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFwidthFine {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpFwidthFine> for Instruction {
    fn from(v: OpFwidthFine) -> Self {
        Self::FwidthFine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdxCoarse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdxCoarse> for Instruction {
    fn from(v: OpDPdxCoarse) -> Self {
        Self::DPdxCoarse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdyCoarse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdyCoarse> for Instruction {
    fn from(v: OpDPdyCoarse) -> Self {
        Self::DPdyCoarse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFwidthCoarse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpFwidthCoarse> for Instruction {
    fn from(v: OpFwidthCoarse) -> Self {
        Self::FwidthCoarse(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpEmitVertex;
impl From<OpEmitVertex> for Instruction {
    fn from(v: OpEmitVertex) -> Self {
        Self::EmitVertex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpEndPrimitive;
impl From<OpEndPrimitive> for Instruction {
    fn from(v: OpEndPrimitive) -> Self {
        Self::EndPrimitive(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEmitStreamVertex {
    pub stream: IdRef,
}
impl From<OpEmitStreamVertex> for Instruction {
    fn from(v: OpEmitStreamVertex) -> Self {
        Self::EmitStreamVertex(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEndStreamPrimitive {
    pub stream: IdRef,
}
impl From<OpEndStreamPrimitive> for Instruction {
    fn from(v: OpEndStreamPrimitive) -> Self {
        Self::EndStreamPrimitive(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpControlBarrier {
    pub execution: IdScope,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpControlBarrier> for Instruction {
    fn from(v: OpControlBarrier) -> Self {
        Self::ControlBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemoryBarrier {
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpMemoryBarrier> for Instruction {
    fn from(v: OpMemoryBarrier) -> Self {
        Self::MemoryBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicLoad {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicLoad> for Instruction {
    fn from(v: OpAtomicLoad) -> Self {
        Self::AtomicLoad(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicStore {
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicStore> for Instruction {
    fn from(v: OpAtomicStore) -> Self {
        Self::AtomicStore(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicExchange {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicExchange> for Instruction {
    fn from(v: OpAtomicExchange) -> Self {
        Self::AtomicExchange(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicCompareExchange {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub equal: IdMemorySemantics,
    pub unequal: IdMemorySemantics,
    pub value: IdRef,
    pub comparator: IdRef,
}
impl From<OpAtomicCompareExchange> for Instruction {
    fn from(v: OpAtomicCompareExchange) -> Self {
        Self::AtomicCompareExchange(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicCompareExchangeWeak {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub equal: IdMemorySemantics,
    pub unequal: IdMemorySemantics,
    pub value: IdRef,
    pub comparator: IdRef,
}
impl From<OpAtomicCompareExchangeWeak> for Instruction {
    fn from(v: OpAtomicCompareExchangeWeak) -> Self {
        Self::AtomicCompareExchangeWeak(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicIIncrement {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicIIncrement> for Instruction {
    fn from(v: OpAtomicIIncrement) -> Self {
        Self::AtomicIIncrement(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicIDecrement {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicIDecrement> for Instruction {
    fn from(v: OpAtomicIDecrement) -> Self {
        Self::AtomicIDecrement(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicIAdd> for Instruction {
    fn from(v: OpAtomicIAdd) -> Self {
        Self::AtomicIAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicISub {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicISub> for Instruction {
    fn from(v: OpAtomicISub) -> Self {
        Self::AtomicISub(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicSMin> for Instruction {
    fn from(v: OpAtomicSMin) -> Self {
        Self::AtomicSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicUMin> for Instruction {
    fn from(v: OpAtomicUMin) -> Self {
        Self::AtomicUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicSMax> for Instruction {
    fn from(v: OpAtomicSMax) -> Self {
        Self::AtomicSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicUMax> for Instruction {
    fn from(v: OpAtomicUMax) -> Self {
        Self::AtomicUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicAnd> for Instruction {
    fn from(v: OpAtomicAnd) -> Self {
        Self::AtomicAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicOr> for Instruction {
    fn from(v: OpAtomicOr) -> Self {
        Self::AtomicOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicXor> for Instruction {
    fn from(v: OpAtomicXor) -> Self {
        Self::AtomicXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPhi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub variable_parent: Vec<PairIdRefIdRef>,
}
impl From<OpPhi> for Instruction {
    fn from(v: OpPhi) -> Self {
        Self::Phi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLoopMerge {
    pub merge_block: IdRef,
    pub continue_target: IdRef,
    pub loop_control: LoopControl,
}
impl From<OpLoopMerge> for Instruction {
    fn from(v: OpLoopMerge) -> Self {
        Self::LoopMerge(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSelectionMerge {
    pub merge_block: IdRef,
    pub selection_control: SelectionControl,
}
impl From<OpSelectionMerge> for Instruction {
    fn from(v: OpSelectionMerge) -> Self {
        Self::SelectionMerge(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLabel {
    pub id_result: IdResult,
}
impl From<OpLabel> for Instruction {
    fn from(v: OpLabel) -> Self {
        Self::Label(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBranch {
    pub target_label: IdRef,
}
impl From<OpBranch> for Instruction {
    fn from(v: OpBranch) -> Self {
        Self::Branch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBranchConditional {
    pub condition: IdRef,
    pub true_label: IdRef,
    pub false_label: IdRef,
    pub branch_weights: Vec<LiteralInteger32>,
}
impl From<OpBranchConditional> for Instruction {
    fn from(v: OpBranchConditional) -> Self {
        Self::BranchConditional(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSwitch32 {
    pub selector: IdRef,
    pub default: IdRef,
    pub target: Vec<PairLiteralInteger32IdRef>,
}
impl From<OpSwitch32> for Instruction {
    fn from(v: OpSwitch32) -> Self {
        Self::Switch32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSwitch64 {
    pub selector: IdRef,
    pub default: IdRef,
    pub target: Vec<PairLiteralInteger64IdRef>,
}
impl From<OpSwitch64> for Instruction {
    fn from(v: OpSwitch64) -> Self {
        Self::Switch64(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpKill;
impl From<OpKill> for Instruction {
    fn from(v: OpKill) -> Self {
        Self::Kill(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpReturn;
impl From<OpReturn> for Instruction {
    fn from(v: OpReturn) -> Self {
        Self::Return(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReturnValue {
    pub value: IdRef,
}
impl From<OpReturnValue> for Instruction {
    fn from(v: OpReturnValue) -> Self {
        Self::ReturnValue(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpUnreachable;
impl From<OpUnreachable> for Instruction {
    fn from(v: OpUnreachable) -> Self {
        Self::Unreachable(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLifetimeStart {
    pub pointer: IdRef,
    pub size: LiteralInteger32,
}
impl From<OpLifetimeStart> for Instruction {
    fn from(v: OpLifetimeStart) -> Self {
        Self::LifetimeStart(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLifetimeStop {
    pub pointer: IdRef,
    pub size: LiteralInteger32,
}
impl From<OpLifetimeStop> for Instruction {
    fn from(v: OpLifetimeStop) -> Self {
        Self::LifetimeStop(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupAsyncCopy {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub destination: IdRef,
    pub source: IdRef,
    pub num_elements: IdRef,
    pub stride: IdRef,
    pub event: IdRef,
}
impl From<OpGroupAsyncCopy> for Instruction {
    fn from(v: OpGroupAsyncCopy) -> Self {
        Self::GroupAsyncCopy(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupWaitEvents {
    pub execution: IdScope,
    pub num_events: IdRef,
    pub events_list: IdRef,
}
impl From<OpGroupWaitEvents> for Instruction {
    fn from(v: OpGroupWaitEvents) -> Self {
        Self::GroupWaitEvents(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupAll {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupAll> for Instruction {
    fn from(v: OpGroupAll) -> Self {
        Self::GroupAll(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupAny {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupAny> for Instruction {
    fn from(v: OpGroupAny) -> Self {
        Self::GroupAny(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupBroadcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub local_id: IdRef,
}
impl From<OpGroupBroadcast> for Instruction {
    fn from(v: OpGroupBroadcast) -> Self {
        Self::GroupBroadcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupIAdd> for Instruction {
    fn from(v: OpGroupIAdd) -> Self {
        Self::GroupIAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupFAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupFAdd> for Instruction {
    fn from(v: OpGroupFAdd) -> Self {
        Self::GroupFAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupFMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupFMin> for Instruction {
    fn from(v: OpGroupFMin) -> Self {
        Self::GroupFMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupUMin> for Instruction {
    fn from(v: OpGroupUMin) -> Self {
        Self::GroupUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupSMin> for Instruction {
    fn from(v: OpGroupSMin) -> Self {
        Self::GroupSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupFMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupFMax> for Instruction {
    fn from(v: OpGroupFMax) -> Self {
        Self::GroupFMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupUMax> for Instruction {
    fn from(v: OpGroupUMax) -> Self {
        Self::GroupUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupSMax> for Instruction {
    fn from(v: OpGroupSMax) -> Self {
        Self::GroupSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReadPipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReadPipe> for Instruction {
    fn from(v: OpReadPipe) -> Self {
        Self::ReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpWritePipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpWritePipe> for Instruction {
    fn from(v: OpWritePipe) -> Self {
        Self::WritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReservedReadPipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub index: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReservedReadPipe> for Instruction {
    fn from(v: OpReservedReadPipe) -> Self {
        Self::ReservedReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReservedWritePipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub index: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReservedWritePipe> for Instruction {
    fn from(v: OpReservedWritePipe) -> Self {
        Self::ReservedWritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReserveReadPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReserveReadPipePackets> for Instruction {
    fn from(v: OpReserveReadPipePackets) -> Self {
        Self::ReserveReadPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReserveWritePipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReserveWritePipePackets> for Instruction {
    fn from(v: OpReserveWritePipePackets) -> Self {
        Self::ReserveWritePipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCommitReadPipe {
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpCommitReadPipe> for Instruction {
    fn from(v: OpCommitReadPipe) -> Self {
        Self::CommitReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCommitWritePipe {
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpCommitWritePipe> for Instruction {
    fn from(v: OpCommitWritePipe) -> Self {
        Self::CommitWritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsValidReserveId {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub reserve_id: IdRef,
}
impl From<OpIsValidReserveId> for Instruction {
    fn from(v: OpIsValidReserveId) -> Self {
        Self::IsValidReserveId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetNumPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGetNumPipePackets> for Instruction {
    fn from(v: OpGetNumPipePackets) -> Self {
        Self::GetNumPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetMaxPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGetMaxPipePackets> for Instruction {
    fn from(v: OpGetMaxPipePackets) -> Self {
        Self::GetMaxPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupReserveReadPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupReserveReadPipePackets> for Instruction {
    fn from(v: OpGroupReserveReadPipePackets) -> Self {
        Self::GroupReserveReadPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupReserveWritePipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupReserveWritePipePackets> for Instruction {
    fn from(v: OpGroupReserveWritePipePackets) -> Self {
        Self::GroupReserveWritePipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupCommitReadPipe {
    pub execution: IdScope,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupCommitReadPipe> for Instruction {
    fn from(v: OpGroupCommitReadPipe) -> Self {
        Self::GroupCommitReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupCommitWritePipe {
    pub execution: IdScope,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupCommitWritePipe> for Instruction {
    fn from(v: OpGroupCommitWritePipe) -> Self {
        Self::GroupCommitWritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEnqueueMarker {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub queue: IdRef,
    pub num_events: IdRef,
    pub wait_events: IdRef,
    pub ret_event: IdRef,
}
impl From<OpEnqueueMarker> for Instruction {
    fn from(v: OpEnqueueMarker) -> Self {
        Self::EnqueueMarker(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEnqueueKernel {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub queue: IdRef,
    pub flags: IdRef,
    pub nd_range: IdRef,
    pub num_events: IdRef,
    pub wait_events: IdRef,
    pub ret_event: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
    pub local_size: Vec<IdRef>,
}
impl From<OpEnqueueKernel> for Instruction {
    fn from(v: OpEnqueueKernel) -> Self {
        Self::EnqueueKernel(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelNDrangeSubGroupCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub nd_range: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelNDrangeSubGroupCount> for Instruction {
    fn from(v: OpGetKernelNDrangeSubGroupCount) -> Self {
        Self::GetKernelNDrangeSubGroupCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelNDrangeMaxSubGroupSize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub nd_range: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelNDrangeMaxSubGroupSize> for Instruction {
    fn from(v: OpGetKernelNDrangeMaxSubGroupSize) -> Self {
        Self::GetKernelNDrangeMaxSubGroupSize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelWorkGroupSize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelWorkGroupSize> for Instruction {
    fn from(v: OpGetKernelWorkGroupSize) -> Self {
        Self::GetKernelWorkGroupSize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelPreferredWorkGroupSizeMultiple {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelPreferredWorkGroupSizeMultiple> for Instruction {
    fn from(v: OpGetKernelPreferredWorkGroupSizeMultiple) -> Self {
        Self::GetKernelPreferredWorkGroupSizeMultiple(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpRetainEvent {
    pub event: IdRef,
}
impl From<OpRetainEvent> for Instruction {
    fn from(v: OpRetainEvent) -> Self {
        Self::RetainEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReleaseEvent {
    pub event: IdRef,
}
impl From<OpReleaseEvent> for Instruction {
    fn from(v: OpReleaseEvent) -> Self {
        Self::ReleaseEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCreateUserEvent {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpCreateUserEvent> for Instruction {
    fn from(v: OpCreateUserEvent) -> Self {
        Self::CreateUserEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsValidEvent {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub event: IdRef,
}
impl From<OpIsValidEvent> for Instruction {
    fn from(v: OpIsValidEvent) -> Self {
        Self::IsValidEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSetUserEventStatus {
    pub event: IdRef,
    pub status: IdRef,
}
impl From<OpSetUserEventStatus> for Instruction {
    fn from(v: OpSetUserEventStatus) -> Self {
        Self::SetUserEventStatus(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCaptureEventProfilingInfo {
    pub event: IdRef,
    pub profiling_info: IdRef,
    pub value: IdRef,
}
impl From<OpCaptureEventProfilingInfo> for Instruction {
    fn from(v: OpCaptureEventProfilingInfo) -> Self {
        Self::CaptureEventProfilingInfo(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetDefaultQueue {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpGetDefaultQueue> for Instruction {
    fn from(v: OpGetDefaultQueue) -> Self {
        Self::GetDefaultQueue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBuildNDRange {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub global_work_size: IdRef,
    pub local_work_size: IdRef,
    pub global_work_offset: IdRef,
}
impl From<OpBuildNDRange> for Instruction {
    fn from(v: OpBuildNDRange) -> Self {
        Self::BuildNDRange(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseSampleImplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleImplicitLod) -> Self {
        Self::ImageSparseSampleImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSparseSampleExplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleExplicitLod) -> Self {
        Self::ImageSparseSampleExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleDrefImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseSampleDrefImplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleDrefImplicitLod) -> Self {
        Self::ImageSparseSampleDrefImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleDrefExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSparseSampleDrefExplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleDrefExplicitLod) -> Self {
        Self::ImageSparseSampleDrefExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseFetch {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseFetch> for Instruction {
    fn from(v: OpImageSparseFetch) -> Self {
        Self::ImageSparseFetch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub component: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseGather> for Instruction {
    fn from(v: OpImageSparseGather) -> Self {
        Self::ImageSparseGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseDrefGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseDrefGather> for Instruction {
    fn from(v: OpImageSparseDrefGather) -> Self {
        Self::ImageSparseDrefGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseTexelsResident {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub resident_code: IdRef,
}
impl From<OpImageSparseTexelsResident> for Instruction {
    fn from(v: OpImageSparseTexelsResident) -> Self {
        Self::ImageSparseTexelsResident(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub struct OpNoLine;
impl From<OpNoLine> for Instruction {
    fn from(v: OpNoLine) -> Self {
        Self::NoLine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicFlagTestAndSet {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicFlagTestAndSet> for Instruction {
    fn from(v: OpAtomicFlagTestAndSet) -> Self {
        Self::AtomicFlagTestAndSet(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicFlagClear {
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicFlagClear> for Instruction {
    fn from(v: OpAtomicFlagClear) -> Self {
        Self::AtomicFlagClear(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseRead {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseRead> for Instruction {
    fn from(v: OpImageSparseRead) -> Self {
        Self::ImageSparseRead(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSizeOf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpSizeOf> for Instruction {
    fn from(v: OpSizeOf) -> Self {
        Self::SizeOf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypePipeStorage {
    pub id_result: IdResult,
}
impl From<OpTypePipeStorage> for Instruction {
    fn from(v: OpTypePipeStorage) -> Self {
        Self::TypePipeStorage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantPipeStorage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub packet_size: LiteralInteger32,
    pub packet_alignment: LiteralInteger32,
    pub capacity: LiteralInteger32,
}
impl From<OpConstantPipeStorage> for Instruction {
    fn from(v: OpConstantPipeStorage) -> Self {
        Self::ConstantPipeStorage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCreatePipeFromPipeStorage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe_storage: IdRef,
}
impl From<OpCreatePipeFromPipeStorage> for Instruction {
    fn from(v: OpCreatePipeFromPipeStorage) -> Self {
        Self::CreatePipeFromPipeStorage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelLocalSizeForSubgroupCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub subgroup_count: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelLocalSizeForSubgroupCount> for Instruction {
    fn from(v: OpGetKernelLocalSizeForSubgroupCount) -> Self {
        Self::GetKernelLocalSizeForSubgroupCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelMaxNumSubgroups {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelMaxNumSubgroups> for Instruction {
    fn from(v: OpGetKernelMaxNumSubgroups) -> Self {
        Self::GetKernelMaxNumSubgroups(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeNamedBarrier {
    pub id_result: IdResult,
}
impl From<OpTypeNamedBarrier> for Instruction {
    fn from(v: OpTypeNamedBarrier) -> Self {
        Self::TypeNamedBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpNamedBarrierInitialize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub subgroup_count: IdRef,
}
impl From<OpNamedBarrierInitialize> for Instruction {
    fn from(v: OpNamedBarrierInitialize) -> Self {
        Self::NamedBarrierInitialize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemoryNamedBarrier {
    pub named_barrier: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpMemoryNamedBarrier> for Instruction {
    fn from(v: OpMemoryNamedBarrier) -> Self {
        Self::MemoryNamedBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpModuleProcessed {
    pub process: LiteralString,
}
impl From<OpModuleProcessed> for Instruction {
    fn from(v: OpModuleProcessed) -> Self {
        Self::ModuleProcessed(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExecutionModeId {
    pub entry_point: IdRef,
    pub mode: ExecutionMode,
}
impl From<OpExecutionModeId> for Instruction {
    fn from(v: OpExecutionModeId) -> Self {
        Self::ExecutionModeId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorateId {
    pub target: IdRef,
    pub decoration: Decoration,
}
impl From<OpDecorateId> for Instruction {
    fn from(v: OpDecorateId) -> Self {
        Self::DecorateId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformElect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
}
impl From<OpGroupNonUniformElect> for Instruction {
    fn from(v: OpGroupNonUniformElect) -> Self {
        Self::GroupNonUniformElect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformAll {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupNonUniformAll> for Instruction {
    fn from(v: OpGroupNonUniformAll) -> Self {
        Self::GroupNonUniformAll(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformAny {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupNonUniformAny> for Instruction {
    fn from(v: OpGroupNonUniformAny) -> Self {
        Self::GroupNonUniformAny(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformAllEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformAllEqual> for Instruction {
    fn from(v: OpGroupNonUniformAllEqual) -> Self {
        Self::GroupNonUniformAllEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBroadcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub id: IdRef,
}
impl From<OpGroupNonUniformBroadcast> for Instruction {
    fn from(v: OpGroupNonUniformBroadcast) -> Self {
        Self::GroupNonUniformBroadcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBroadcastFirst {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBroadcastFirst> for Instruction {
    fn from(v: OpGroupNonUniformBroadcastFirst) -> Self {
        Self::GroupNonUniformBroadcastFirst(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupNonUniformBallot> for Instruction {
    fn from(v: OpGroupNonUniformBallot) -> Self {
        Self::GroupNonUniformBallot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformInverseBallot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformInverseBallot> for Instruction {
    fn from(v: OpGroupNonUniformInverseBallot) -> Self {
        Self::GroupNonUniformInverseBallot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotBitExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub index: IdRef,
}
impl From<OpGroupNonUniformBallotBitExtract> for Instruction {
    fn from(v: OpGroupNonUniformBallotBitExtract) -> Self {
        Self::GroupNonUniformBallotBitExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotBitCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBallotBitCount> for Instruction {
    fn from(v: OpGroupNonUniformBallotBitCount) -> Self {
        Self::GroupNonUniformBallotBitCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotFindLSB {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBallotFindLSB> for Instruction {
    fn from(v: OpGroupNonUniformBallotFindLSB) -> Self {
        Self::GroupNonUniformBallotFindLSB(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotFindMSB {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBallotFindMSB> for Instruction {
    fn from(v: OpGroupNonUniformBallotFindMSB) -> Self {
        Self::GroupNonUniformBallotFindMSB(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffle {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub id: IdRef,
}
impl From<OpGroupNonUniformShuffle> for Instruction {
    fn from(v: OpGroupNonUniformShuffle) -> Self {
        Self::GroupNonUniformShuffle(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffleXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub mask: IdRef,
}
impl From<OpGroupNonUniformShuffleXor> for Instruction {
    fn from(v: OpGroupNonUniformShuffleXor) -> Self {
        Self::GroupNonUniformShuffleXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffleUp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub delta: IdRef,
}
impl From<OpGroupNonUniformShuffleUp> for Instruction {
    fn from(v: OpGroupNonUniformShuffleUp) -> Self {
        Self::GroupNonUniformShuffleUp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffleDown {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub delta: IdRef,
}
impl From<OpGroupNonUniformShuffleDown> for Instruction {
    fn from(v: OpGroupNonUniformShuffleDown) -> Self {
        Self::GroupNonUniformShuffleDown(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformIAdd> for Instruction {
    fn from(v: OpGroupNonUniformIAdd) -> Self {
        Self::GroupNonUniformIAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFAdd> for Instruction {
    fn from(v: OpGroupNonUniformFAdd) -> Self {
        Self::GroupNonUniformFAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformIMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformIMul> for Instruction {
    fn from(v: OpGroupNonUniformIMul) -> Self {
        Self::GroupNonUniformIMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFMul> for Instruction {
    fn from(v: OpGroupNonUniformFMul) -> Self {
        Self::GroupNonUniformFMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformSMin> for Instruction {
    fn from(v: OpGroupNonUniformSMin) -> Self {
        Self::GroupNonUniformSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformUMin> for Instruction {
    fn from(v: OpGroupNonUniformUMin) -> Self {
        Self::GroupNonUniformUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFMin> for Instruction {
    fn from(v: OpGroupNonUniformFMin) -> Self {
        Self::GroupNonUniformFMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformSMax> for Instruction {
    fn from(v: OpGroupNonUniformSMax) -> Self {
        Self::GroupNonUniformSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformUMax> for Instruction {
    fn from(v: OpGroupNonUniformUMax) -> Self {
        Self::GroupNonUniformUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFMax> for Instruction {
    fn from(v: OpGroupNonUniformFMax) -> Self {
        Self::GroupNonUniformFMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBitwiseAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformBitwiseAnd> for Instruction {
    fn from(v: OpGroupNonUniformBitwiseAnd) -> Self {
        Self::GroupNonUniformBitwiseAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBitwiseOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformBitwiseOr> for Instruction {
    fn from(v: OpGroupNonUniformBitwiseOr) -> Self {
        Self::GroupNonUniformBitwiseOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBitwiseXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformBitwiseXor> for Instruction {
    fn from(v: OpGroupNonUniformBitwiseXor) -> Self {
        Self::GroupNonUniformBitwiseXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformLogicalAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformLogicalAnd> for Instruction {
    fn from(v: OpGroupNonUniformLogicalAnd) -> Self {
        Self::GroupNonUniformLogicalAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformLogicalOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformLogicalOr> for Instruction {
    fn from(v: OpGroupNonUniformLogicalOr) -> Self {
        Self::GroupNonUniformLogicalOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformLogicalXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformLogicalXor> for Instruction {
    fn from(v: OpGroupNonUniformLogicalXor) -> Self {
        Self::GroupNonUniformLogicalXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformQuadBroadcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub index: IdRef,
}
impl From<OpGroupNonUniformQuadBroadcast> for Instruction {
    fn from(v: OpGroupNonUniformQuadBroadcast) -> Self {
        Self::GroupNonUniformQuadBroadcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformQuadSwap {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub direction: IdRef,
}
impl From<OpGroupNonUniformQuadSwap> for Instruction {
    fn from(v: OpGroupNonUniformQuadSwap) -> Self {
        Self::GroupNonUniformQuadSwap(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyLogical {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpCopyLogical> for Instruction {
    fn from(v: OpCopyLogical) -> Self {
        Self::CopyLogical(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpPtrEqual> for Instruction {
    fn from(v: OpPtrEqual) -> Self {
        Self::PtrEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpPtrNotEqual> for Instruction {
    fn from(v: OpPtrNotEqual) -> Self {
        Self::PtrNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrDiff {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpPtrDiff> for Instruction {
    fn from(v: OpPtrDiff) -> Self {
        Self::PtrDiff(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorateString {
    pub target: IdRef,
    pub decoration: Decoration,
}
impl From<OpDecorateString> for Instruction {
    fn from(v: OpDecorateString) -> Self {
        Self::DecorateString(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemberDecorateString {
    pub struct_type: IdRef,
    pub member: LiteralInteger32,
    pub decoration: Decoration,
}
impl From<OpMemberDecorateString> for Instruction {
    fn from(v: OpMemberDecorateString) -> Self {
        Self::MemberDecorateString(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAcos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAcos> for Instruction {
    fn from(v: OpOpenCLStdAcos) -> Self {
        Self::OpenCLStdAcos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAcosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAcosh> for Instruction {
    fn from(v: OpOpenCLStdAcosh) -> Self {
        Self::OpenCLStdAcosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAcospi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAcospi> for Instruction {
    fn from(v: OpOpenCLStdAcospi) -> Self {
        Self::OpenCLStdAcospi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAsin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAsin> for Instruction {
    fn from(v: OpOpenCLStdAsin) -> Self {
        Self::OpenCLStdAsin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAsinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAsinh> for Instruction {
    fn from(v: OpOpenCLStdAsinh) -> Self {
        Self::OpenCLStdAsinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAsinpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAsinpi> for Instruction {
    fn from(v: OpOpenCLStdAsinpi) -> Self {
        Self::OpenCLStdAsinpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtan> for Instruction {
    fn from(v: OpOpenCLStdAtan) -> Self {
        Self::OpenCLStdAtan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtan2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtan2> for Instruction {
    fn from(v: OpOpenCLStdAtan2) -> Self {
        Self::OpenCLStdAtan2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtanh> for Instruction {
    fn from(v: OpOpenCLStdAtanh) -> Self {
        Self::OpenCLStdAtanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtanpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtanpi> for Instruction {
    fn from(v: OpOpenCLStdAtanpi) -> Self {
        Self::OpenCLStdAtanpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtan2pi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtan2pi> for Instruction {
    fn from(v: OpOpenCLStdAtan2pi) -> Self {
        Self::OpenCLStdAtan2pi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCbrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCbrt> for Instruction {
    fn from(v: OpOpenCLStdCbrt) -> Self {
        Self::OpenCLStdCbrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCeil {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCeil> for Instruction {
    fn from(v: OpOpenCLStdCeil) -> Self {
        Self::OpenCLStdCeil(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCopysign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdCopysign> for Instruction {
    fn from(v: OpOpenCLStdCopysign) -> Self {
        Self::OpenCLStdCopysign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCos> for Instruction {
    fn from(v: OpOpenCLStdCos) -> Self {
        Self::OpenCLStdCos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCosh> for Instruction {
    fn from(v: OpOpenCLStdCosh) -> Self {
        Self::OpenCLStdCosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCospi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCospi> for Instruction {
    fn from(v: OpOpenCLStdCospi) -> Self {
        Self::OpenCLStdCospi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdErfc {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdErfc> for Instruction {
    fn from(v: OpOpenCLStdErfc) -> Self {
        Self::OpenCLStdErfc(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdErf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdErf> for Instruction {
    fn from(v: OpOpenCLStdErf) -> Self {
        Self::OpenCLStdErf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExp> for Instruction {
    fn from(v: OpOpenCLStdExp) -> Self {
        Self::OpenCLStdExp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExp2> for Instruction {
    fn from(v: OpOpenCLStdExp2) -> Self {
        Self::OpenCLStdExp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExp10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExp10> for Instruction {
    fn from(v: OpOpenCLStdExp10) -> Self {
        Self::OpenCLStdExp10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExpm1 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExpm1> for Instruction {
    fn from(v: OpOpenCLStdExpm1) -> Self {
        Self::OpenCLStdExpm1(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFabs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdFabs> for Instruction {
    fn from(v: OpOpenCLStdFabs) -> Self {
        Self::OpenCLStdFabs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFdim {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFdim> for Instruction {
    fn from(v: OpOpenCLStdFdim) -> Self {
        Self::OpenCLStdFdim(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFloor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdFloor> for Instruction {
    fn from(v: OpOpenCLStdFloor) -> Self {
        Self::OpenCLStdFloor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdFma> for Instruction {
    fn from(v: OpOpenCLStdFma) -> Self {
        Self::OpenCLStdFma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmax> for Instruction {
    fn from(v: OpOpenCLStdFmax) -> Self {
        Self::OpenCLStdFmax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmin> for Instruction {
    fn from(v: OpOpenCLStdFmin) -> Self {
        Self::OpenCLStdFmin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmod> for Instruction {
    fn from(v: OpOpenCLStdFmod) -> Self {
        Self::OpenCLStdFmod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub ptr: IdRef,
}
impl From<OpOpenCLStdFract> for Instruction {
    fn from(v: OpOpenCLStdFract) -> Self {
        Self::OpenCLStdFract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFrexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub exp: IdRef,
}
impl From<OpOpenCLStdFrexp> for Instruction {
    fn from(v: OpOpenCLStdFrexp) -> Self {
        Self::OpenCLStdFrexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHypot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdHypot> for Instruction {
    fn from(v: OpOpenCLStdHypot) -> Self {
        Self::OpenCLStdHypot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdIlogb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdIlogb> for Instruction {
    fn from(v: OpOpenCLStdIlogb) -> Self {
        Self::OpenCLStdIlogb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLdexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub k: IdRef,
}
impl From<OpOpenCLStdLdexp> for Instruction {
    fn from(v: OpOpenCLStdLdexp) -> Self {
        Self::OpenCLStdLdexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLgamma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLgamma> for Instruction {
    fn from(v: OpOpenCLStdLgamma) -> Self {
        Self::OpenCLStdLgamma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLgammaR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub signp: IdRef,
}
impl From<OpOpenCLStdLgammaR> for Instruction {
    fn from(v: OpOpenCLStdLgammaR) -> Self {
        Self::OpenCLStdLgammaR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog> for Instruction {
    fn from(v: OpOpenCLStdLog) -> Self {
        Self::OpenCLStdLog(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog2> for Instruction {
    fn from(v: OpOpenCLStdLog2) -> Self {
        Self::OpenCLStdLog2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog10> for Instruction {
    fn from(v: OpOpenCLStdLog10) -> Self {
        Self::OpenCLStdLog10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog1p {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog1p> for Instruction {
    fn from(v: OpOpenCLStdLog1p) -> Self {
        Self::OpenCLStdLog1p(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLogb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLogb> for Instruction {
    fn from(v: OpOpenCLStdLogb) -> Self {
        Self::OpenCLStdLogb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMad {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdMad> for Instruction {
    fn from(v: OpOpenCLStdMad) -> Self {
        Self::OpenCLStdMad(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMaxmag {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdMaxmag> for Instruction {
    fn from(v: OpOpenCLStdMaxmag) -> Self {
        Self::OpenCLStdMaxmag(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMinmag {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdMinmag> for Instruction {
    fn from(v: OpOpenCLStdMinmag) -> Self {
        Self::OpenCLStdMinmag(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdModf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub iptr: IdRef,
}
impl From<OpOpenCLStdModf> for Instruction {
    fn from(v: OpOpenCLStdModf) -> Self {
        Self::OpenCLStdModf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub nancode: IdRef,
}
impl From<OpOpenCLStdNan> for Instruction {
    fn from(v: OpOpenCLStdNan) -> Self {
        Self::OpenCLStdNan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNextafter {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdNextafter> for Instruction {
    fn from(v: OpOpenCLStdNextafter) -> Self {
        Self::OpenCLStdNextafter(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPow {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdPow> for Instruction {
    fn from(v: OpOpenCLStdPow) -> Self {
        Self::OpenCLStdPow(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPown {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdPown> for Instruction {
    fn from(v: OpOpenCLStdPown) -> Self {
        Self::OpenCLStdPown(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPowr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdPowr> for Instruction {
    fn from(v: OpOpenCLStdPowr) -> Self {
        Self::OpenCLStdPowr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRemainder {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdRemainder> for Instruction {
    fn from(v: OpOpenCLStdRemainder) -> Self {
        Self::OpenCLStdRemainder(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRemquo {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub quo: IdRef,
}
impl From<OpOpenCLStdRemquo> for Instruction {
    fn from(v: OpOpenCLStdRemquo) -> Self {
        Self::OpenCLStdRemquo(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRint {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdRint> for Instruction {
    fn from(v: OpOpenCLStdRint) -> Self {
        Self::OpenCLStdRint(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRootn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdRootn> for Instruction {
    fn from(v: OpOpenCLStdRootn) -> Self {
        Self::OpenCLStdRootn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRound {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdRound> for Instruction {
    fn from(v: OpOpenCLStdRound) -> Self {
        Self::OpenCLStdRound(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRsqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdRsqrt> for Instruction {
    fn from(v: OpOpenCLStdRsqrt) -> Self {
        Self::OpenCLStdRsqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSin> for Instruction {
    fn from(v: OpOpenCLStdSin) -> Self {
        Self::OpenCLStdSin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSincos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub cosval: IdRef,
}
impl From<OpOpenCLStdSincos> for Instruction {
    fn from(v: OpOpenCLStdSincos) -> Self {
        Self::OpenCLStdSincos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSinh> for Instruction {
    fn from(v: OpOpenCLStdSinh) -> Self {
        Self::OpenCLStdSinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSinpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSinpi> for Instruction {
    fn from(v: OpOpenCLStdSinpi) -> Self {
        Self::OpenCLStdSinpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSqrt> for Instruction {
    fn from(v: OpOpenCLStdSqrt) -> Self {
        Self::OpenCLStdSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTan> for Instruction {
    fn from(v: OpOpenCLStdTan) -> Self {
        Self::OpenCLStdTan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTanh> for Instruction {
    fn from(v: OpOpenCLStdTanh) -> Self {
        Self::OpenCLStdTanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTanpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTanpi> for Instruction {
    fn from(v: OpOpenCLStdTanpi) -> Self {
        Self::OpenCLStdTanpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTgamma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTgamma> for Instruction {
    fn from(v: OpOpenCLStdTgamma) -> Self {
        Self::OpenCLStdTgamma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTrunc {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTrunc> for Instruction {
    fn from(v: OpOpenCLStdTrunc) -> Self {
        Self::OpenCLStdTrunc(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfCos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfCos> for Instruction {
    fn from(v: OpOpenCLStdHalfCos) -> Self {
        Self::OpenCLStdHalfCos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfDivide {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdHalfDivide> for Instruction {
    fn from(v: OpOpenCLStdHalfDivide) -> Self {
        Self::OpenCLStdHalfDivide(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfExp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfExp> for Instruction {
    fn from(v: OpOpenCLStdHalfExp) -> Self {
        Self::OpenCLStdHalfExp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfExp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfExp2> for Instruction {
    fn from(v: OpOpenCLStdHalfExp2) -> Self {
        Self::OpenCLStdHalfExp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfExp10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfExp10> for Instruction {
    fn from(v: OpOpenCLStdHalfExp10) -> Self {
        Self::OpenCLStdHalfExp10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfLog {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfLog> for Instruction {
    fn from(v: OpOpenCLStdHalfLog) -> Self {
        Self::OpenCLStdHalfLog(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfLog2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfLog2> for Instruction {
    fn from(v: OpOpenCLStdHalfLog2) -> Self {
        Self::OpenCLStdHalfLog2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfLog10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfLog10> for Instruction {
    fn from(v: OpOpenCLStdHalfLog10) -> Self {
        Self::OpenCLStdHalfLog10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfPowr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdHalfPowr> for Instruction {
    fn from(v: OpOpenCLStdHalfPowr) -> Self {
        Self::OpenCLStdHalfPowr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfRecip {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfRecip> for Instruction {
    fn from(v: OpOpenCLStdHalfRecip) -> Self {
        Self::OpenCLStdHalfRecip(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfRsqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfRsqrt> for Instruction {
    fn from(v: OpOpenCLStdHalfRsqrt) -> Self {
        Self::OpenCLStdHalfRsqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfSin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfSin> for Instruction {
    fn from(v: OpOpenCLStdHalfSin) -> Self {
        Self::OpenCLStdHalfSin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfSqrt> for Instruction {
    fn from(v: OpOpenCLStdHalfSqrt) -> Self {
        Self::OpenCLStdHalfSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfTan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfTan> for Instruction {
    fn from(v: OpOpenCLStdHalfTan) -> Self {
        Self::OpenCLStdHalfTan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeCos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeCos> for Instruction {
    fn from(v: OpOpenCLStdNativeCos) -> Self {
        Self::OpenCLStdNativeCos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeDivide {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdNativeDivide> for Instruction {
    fn from(v: OpOpenCLStdNativeDivide) -> Self {
        Self::OpenCLStdNativeDivide(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeExp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeExp> for Instruction {
    fn from(v: OpOpenCLStdNativeExp) -> Self {
        Self::OpenCLStdNativeExp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeExp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeExp2> for Instruction {
    fn from(v: OpOpenCLStdNativeExp2) -> Self {
        Self::OpenCLStdNativeExp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeExp10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeExp10> for Instruction {
    fn from(v: OpOpenCLStdNativeExp10) -> Self {
        Self::OpenCLStdNativeExp10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeLog {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeLog> for Instruction {
    fn from(v: OpOpenCLStdNativeLog) -> Self {
        Self::OpenCLStdNativeLog(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeLog2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeLog2> for Instruction {
    fn from(v: OpOpenCLStdNativeLog2) -> Self {
        Self::OpenCLStdNativeLog2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeLog10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeLog10> for Instruction {
    fn from(v: OpOpenCLStdNativeLog10) -> Self {
        Self::OpenCLStdNativeLog10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativePowr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdNativePowr> for Instruction {
    fn from(v: OpOpenCLStdNativePowr) -> Self {
        Self::OpenCLStdNativePowr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeRecip {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeRecip> for Instruction {
    fn from(v: OpOpenCLStdNativeRecip) -> Self {
        Self::OpenCLStdNativeRecip(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeRsqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeRsqrt> for Instruction {
    fn from(v: OpOpenCLStdNativeRsqrt) -> Self {
        Self::OpenCLStdNativeRsqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeSin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeSin> for Instruction {
    fn from(v: OpOpenCLStdNativeSin) -> Self {
        Self::OpenCLStdNativeSin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeSqrt> for Instruction {
    fn from(v: OpOpenCLStdNativeSqrt) -> Self {
        Self::OpenCLStdNativeSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeTan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeTan> for Instruction {
    fn from(v: OpOpenCLStdNativeTan) -> Self {
        Self::OpenCLStdNativeTan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSAbs> for Instruction {
    fn from(v: OpOpenCLStdSAbs) -> Self {
        Self::OpenCLStdSAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSAbsDiff {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSAbsDiff> for Instruction {
    fn from(v: OpOpenCLStdSAbsDiff) -> Self {
        Self::OpenCLStdSAbsDiff(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSAddSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSAddSat> for Instruction {
    fn from(v: OpOpenCLStdSAddSat) -> Self {
        Self::OpenCLStdSAddSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUAddSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUAddSat> for Instruction {
    fn from(v: OpOpenCLStdUAddSat) -> Self {
        Self::OpenCLStdUAddSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSHadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSHadd> for Instruction {
    fn from(v: OpOpenCLStdSHadd) -> Self {
        Self::OpenCLStdSHadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUHadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUHadd> for Instruction {
    fn from(v: OpOpenCLStdUHadd) -> Self {
        Self::OpenCLStdUHadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSRhadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSRhadd> for Instruction {
    fn from(v: OpOpenCLStdSRhadd) -> Self {
        Self::OpenCLStdSRhadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdURhadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdURhadd> for Instruction {
    fn from(v: OpOpenCLStdURhadd) -> Self {
        Self::OpenCLStdURhadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub minval: IdRef,
    pub maxval: IdRef,
}
impl From<OpOpenCLStdSClamp> for Instruction {
    fn from(v: OpOpenCLStdSClamp) -> Self {
        Self::OpenCLStdSClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub minval: IdRef,
    pub maxval: IdRef,
}
impl From<OpOpenCLStdUClamp> for Instruction {
    fn from(v: OpOpenCLStdUClamp) -> Self {
        Self::OpenCLStdUClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdClz {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdClz> for Instruction {
    fn from(v: OpOpenCLStdClz) -> Self {
        Self::OpenCLStdClz(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCtz {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCtz> for Instruction {
    fn from(v: OpOpenCLStdCtz) -> Self {
        Self::OpenCLStdCtz(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMadHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdSMadHi> for Instruction {
    fn from(v: OpOpenCLStdSMadHi) -> Self {
        Self::OpenCLStdSMadHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMadSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdUMadSat> for Instruction {
    fn from(v: OpOpenCLStdUMadSat) -> Self {
        Self::OpenCLStdUMadSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMadSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdSMadSat> for Instruction {
    fn from(v: OpOpenCLStdSMadSat) -> Self {
        Self::OpenCLStdSMadSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMax> for Instruction {
    fn from(v: OpOpenCLStdSMax) -> Self {
        Self::OpenCLStdSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMax> for Instruction {
    fn from(v: OpOpenCLStdUMax) -> Self {
        Self::OpenCLStdUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMin> for Instruction {
    fn from(v: OpOpenCLStdSMin) -> Self {
        Self::OpenCLStdSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMin> for Instruction {
    fn from(v: OpOpenCLStdUMin) -> Self {
        Self::OpenCLStdUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMulHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMulHi> for Instruction {
    fn from(v: OpOpenCLStdSMulHi) -> Self {
        Self::OpenCLStdSMulHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRotate {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
    pub i: IdRef,
}
impl From<OpOpenCLStdRotate> for Instruction {
    fn from(v: OpOpenCLStdRotate) -> Self {
        Self::OpenCLStdRotate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSSubSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSSubSat> for Instruction {
    fn from(v: OpOpenCLStdSSubSat) -> Self {
        Self::OpenCLStdSSubSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUSubSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUSubSat> for Instruction {
    fn from(v: OpOpenCLStdUSubSat) -> Self {
        Self::OpenCLStdUSubSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUUpsample {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub hi: IdRef,
    pub lo: IdRef,
}
impl From<OpOpenCLStdUUpsample> for Instruction {
    fn from(v: OpOpenCLStdUUpsample) -> Self {
        Self::OpenCLStdUUpsample(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSUpsample {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub hi: IdRef,
    pub lo: IdRef,
}
impl From<OpOpenCLStdSUpsample> for Instruction {
    fn from(v: OpOpenCLStdSUpsample) -> Self {
        Self::OpenCLStdSUpsample(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPopcount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdPopcount> for Instruction {
    fn from(v: OpOpenCLStdPopcount) -> Self {
        Self::OpenCLStdPopcount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMad24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdSMad24> for Instruction {
    fn from(v: OpOpenCLStdSMad24) -> Self {
        Self::OpenCLStdSMad24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMad24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdUMad24> for Instruction {
    fn from(v: OpOpenCLStdUMad24) -> Self {
        Self::OpenCLStdUMad24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMul24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMul24> for Instruction {
    fn from(v: OpOpenCLStdSMul24) -> Self {
        Self::OpenCLStdSMul24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMul24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMul24> for Instruction {
    fn from(v: OpOpenCLStdUMul24) -> Self {
        Self::OpenCLStdUMul24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdUAbs> for Instruction {
    fn from(v: OpOpenCLStdUAbs) -> Self {
        Self::OpenCLStdUAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUAbsDiff {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUAbsDiff> for Instruction {
    fn from(v: OpOpenCLStdUAbsDiff) -> Self {
        Self::OpenCLStdUAbsDiff(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMulHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMulHi> for Instruction {
    fn from(v: OpOpenCLStdUMulHi) -> Self {
        Self::OpenCLStdUMulHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMadHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdUMadHi> for Instruction {
    fn from(v: OpOpenCLStdUMadHi) -> Self {
        Self::OpenCLStdUMadHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFclamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub minval: IdRef,
    pub maxval: IdRef,
}
impl From<OpOpenCLStdFclamp> for Instruction {
    fn from(v: OpOpenCLStdFclamp) -> Self {
        Self::OpenCLStdFclamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdDegrees {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub radians: IdRef,
}
impl From<OpOpenCLStdDegrees> for Instruction {
    fn from(v: OpOpenCLStdDegrees) -> Self {
        Self::OpenCLStdDegrees(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmaxCommon {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmaxCommon> for Instruction {
    fn from(v: OpOpenCLStdFmaxCommon) -> Self {
        Self::OpenCLStdFmaxCommon(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFminCommon {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFminCommon> for Instruction {
    fn from(v: OpOpenCLStdFminCommon) -> Self {
        Self::OpenCLStdFminCommon(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub a: IdRef,
}
impl From<OpOpenCLStdMix> for Instruction {
    fn from(v: OpOpenCLStdMix) -> Self {
        Self::OpenCLStdMix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRadians {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub degrees: IdRef,
}
impl From<OpOpenCLStdRadians> for Instruction {
    fn from(v: OpOpenCLStdRadians) -> Self {
        Self::OpenCLStdRadians(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdStep {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdStep> for Instruction {
    fn from(v: OpOpenCLStdStep) -> Self {
        Self::OpenCLStdStep(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSmoothstep {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge0: IdRef,
    pub edge1: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSmoothstep> for Instruction {
    fn from(v: OpOpenCLStdSmoothstep) -> Self {
        Self::OpenCLStdSmoothstep(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSign> for Instruction {
    fn from(v: OpOpenCLStdSign) -> Self {
        Self::OpenCLStdSign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCross {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpOpenCLStdCross> for Instruction {
    fn from(v: OpOpenCLStdCross) -> Self {
        Self::OpenCLStdCross(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdDistance {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpOpenCLStdDistance> for Instruction {
    fn from(v: OpOpenCLStdDistance) -> Self {
        Self::OpenCLStdDistance(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLength {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdLength> for Instruction {
    fn from(v: OpOpenCLStdLength) -> Self {
        Self::OpenCLStdLength(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNormalize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdNormalize> for Instruction {
    fn from(v: OpOpenCLStdNormalize) -> Self {
        Self::OpenCLStdNormalize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFastDistance {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpOpenCLStdFastDistance> for Instruction {
    fn from(v: OpOpenCLStdFastDistance) -> Self {
        Self::OpenCLStdFastDistance(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFastLength {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdFastLength> for Instruction {
    fn from(v: OpOpenCLStdFastLength) -> Self {
        Self::OpenCLStdFastLength(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFastNormalize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdFastNormalize> for Instruction {
    fn from(v: OpOpenCLStdFastNormalize) -> Self {
        Self::OpenCLStdFastNormalize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdBitselect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdBitselect> for Instruction {
    fn from(v: OpOpenCLStdBitselect) -> Self {
        Self::OpenCLStdBitselect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSelect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdSelect> for Instruction {
    fn from(v: OpOpenCLStdSelect) -> Self {
        Self::OpenCLStdSelect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub n: LiteralInteger32,
}
impl From<OpOpenCLStdVloadn> for Instruction {
    fn from(v: OpOpenCLStdVloadn) -> Self {
        Self::OpenCLStdVloadn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoren {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoren> for Instruction {
    fn from(v: OpOpenCLStdVstoren) -> Self {
        Self::OpenCLStdVstoren(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadHalf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVloadHalf> for Instruction {
    fn from(v: OpOpenCLStdVloadHalf) -> Self {
        Self::OpenCLStdVloadHalf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub n: LiteralInteger32,
}
impl From<OpOpenCLStdVloadHalfn> for Instruction {
    fn from(v: OpOpenCLStdVloadHalfn) -> Self {
        Self::OpenCLStdVloadHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoreHalf> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalf) -> Self {
        Self::OpenCLStdVstoreHalf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalfR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub mode: FPRoundingMode,
}
impl From<OpOpenCLStdVstoreHalfR> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalfR) -> Self {
        Self::OpenCLStdVstoreHalfR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoreHalfn> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalfn) -> Self {
        Self::OpenCLStdVstoreHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalfnR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub mode: FPRoundingMode,
}
impl From<OpOpenCLStdVstoreHalfnR> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalfnR) -> Self {
        Self::OpenCLStdVstoreHalfnR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadaHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub n: LiteralInteger32,
}
impl From<OpOpenCLStdVloadaHalfn> for Instruction {
    fn from(v: OpOpenCLStdVloadaHalfn) -> Self {
        Self::OpenCLStdVloadaHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreaHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoreaHalfn> for Instruction {
    fn from(v: OpOpenCLStdVstoreaHalfn) -> Self {
        Self::OpenCLStdVstoreaHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreaHalfnR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub mode: FPRoundingMode,
}
impl From<OpOpenCLStdVstoreaHalfnR> for Instruction {
    fn from(v: OpOpenCLStdVstoreaHalfnR) -> Self {
        Self::OpenCLStdVstoreaHalfnR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdShuffle {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub shuffle_mask: IdRef,
}
impl From<OpOpenCLStdShuffle> for Instruction {
    fn from(v: OpOpenCLStdShuffle) -> Self {
        Self::OpenCLStdShuffle(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdShuffle2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub shuffle_mask: IdRef,
}
impl From<OpOpenCLStdShuffle2> for Instruction {
    fn from(v: OpOpenCLStdShuffle2) -> Self {
        Self::OpenCLStdShuffle2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPrintf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub format: IdRef,
    pub additional_arguments: Vec<IdRef>,
}
impl From<OpOpenCLStdPrintf> for Instruction {
    fn from(v: OpOpenCLStdPrintf) -> Self {
        Self::OpenCLStdPrintf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPrefetch {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub ptr: IdRef,
    pub num_elements: IdRef,
}
impl From<OpOpenCLStdPrefetch> for Instruction {
    fn from(v: OpOpenCLStdPrefetch) -> Self {
        Self::OpenCLStdPrefetch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Round {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Round> for Instruction {
    fn from(v: OpGLSLStd450Round) -> Self {
        Self::GLSLStd450Round(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450RoundEven {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450RoundEven> for Instruction {
    fn from(v: OpGLSLStd450RoundEven) -> Self {
        Self::GLSLStd450RoundEven(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Trunc {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Trunc> for Instruction {
    fn from(v: OpGLSLStd450Trunc) -> Self {
        Self::GLSLStd450Trunc(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450FAbs> for Instruction {
    fn from(v: OpGLSLStd450FAbs) -> Self {
        Self::GLSLStd450FAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450SAbs> for Instruction {
    fn from(v: OpGLSLStd450SAbs) -> Self {
        Self::GLSLStd450SAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FSign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450FSign> for Instruction {
    fn from(v: OpGLSLStd450FSign) -> Self {
        Self::GLSLStd450FSign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SSign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450SSign> for Instruction {
    fn from(v: OpGLSLStd450SSign) -> Self {
        Self::GLSLStd450SSign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Floor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Floor> for Instruction {
    fn from(v: OpGLSLStd450Floor) -> Self {
        Self::GLSLStd450Floor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Ceil {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Ceil> for Instruction {
    fn from(v: OpGLSLStd450Ceil) -> Self {
        Self::GLSLStd450Ceil(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Fract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Fract> for Instruction {
    fn from(v: OpGLSLStd450Fract) -> Self {
        Self::GLSLStd450Fract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Radians {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub degrees: IdRef,
}
impl From<OpGLSLStd450Radians> for Instruction {
    fn from(v: OpGLSLStd450Radians) -> Self {
        Self::GLSLStd450Radians(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Degrees {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub radians: IdRef,
}
impl From<OpGLSLStd450Degrees> for Instruction {
    fn from(v: OpGLSLStd450Degrees) -> Self {
        Self::GLSLStd450Degrees(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Sin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Sin> for Instruction {
    fn from(v: OpGLSLStd450Sin) -> Self {
        Self::GLSLStd450Sin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Cos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Cos> for Instruction {
    fn from(v: OpGLSLStd450Cos) -> Self {
        Self::GLSLStd450Cos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Tan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Tan> for Instruction {
    fn from(v: OpGLSLStd450Tan) -> Self {
        Self::GLSLStd450Tan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Asin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Asin> for Instruction {
    fn from(v: OpGLSLStd450Asin) -> Self {
        Self::GLSLStd450Asin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Acos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Acos> for Instruction {
    fn from(v: OpGLSLStd450Acos) -> Self {
        Self::GLSLStd450Acos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Atan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y_over_x: IdRef,
}
impl From<OpGLSLStd450Atan> for Instruction {
    fn from(v: OpGLSLStd450Atan) -> Self {
        Self::GLSLStd450Atan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Sinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Sinh> for Instruction {
    fn from(v: OpGLSLStd450Sinh) -> Self {
        Self::GLSLStd450Sinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Cosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Cosh> for Instruction {
    fn from(v: OpGLSLStd450Cosh) -> Self {
        Self::GLSLStd450Cosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Tanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Tanh> for Instruction {
    fn from(v: OpGLSLStd450Tanh) -> Self {
        Self::GLSLStd450Tanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Asinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Asinh> for Instruction {
    fn from(v: OpGLSLStd450Asinh) -> Self {
        Self::GLSLStd450Asinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Acosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Acosh> for Instruction {
    fn from(v: OpGLSLStd450Acosh) -> Self {
        Self::GLSLStd450Acosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Atanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Atanh> for Instruction {
    fn from(v: OpGLSLStd450Atanh) -> Self {
        Self::GLSLStd450Atanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Atan2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Atan2> for Instruction {
    fn from(v: OpGLSLStd450Atan2) -> Self {
        Self::GLSLStd450Atan2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Pow {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450Pow> for Instruction {
    fn from(v: OpGLSLStd450Pow) -> Self {
        Self::GLSLStd450Pow(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Exp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Exp> for Instruction {
    fn from(v: OpGLSLStd450Exp) -> Self {
        Self::GLSLStd450Exp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Log {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Log> for Instruction {
    fn from(v: OpGLSLStd450Log) -> Self {
        Self::GLSLStd450Log(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Exp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Exp2> for Instruction {
    fn from(v: OpGLSLStd450Exp2) -> Self {
        Self::GLSLStd450Exp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Log2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Log2> for Instruction {
    fn from(v: OpGLSLStd450Log2) -> Self {
        Self::GLSLStd450Log2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Sqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Sqrt> for Instruction {
    fn from(v: OpGLSLStd450Sqrt) -> Self {
        Self::GLSLStd450Sqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InverseSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450InverseSqrt> for Instruction {
    fn from(v: OpGLSLStd450InverseSqrt) -> Self {
        Self::GLSLStd450InverseSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Determinant {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Determinant> for Instruction {
    fn from(v: OpGLSLStd450Determinant) -> Self {
        Self::GLSLStd450Determinant(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450MatrixInverse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450MatrixInverse> for Instruction {
    fn from(v: OpGLSLStd450MatrixInverse) -> Self {
        Self::GLSLStd450MatrixInverse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Modf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub i: IdRef,
}
impl From<OpGLSLStd450Modf> for Instruction {
    fn from(v: OpGLSLStd450Modf) -> Self {
        Self::GLSLStd450Modf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450ModfStruct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450ModfStruct> for Instruction {
    fn from(v: OpGLSLStd450ModfStruct) -> Self {
        Self::GLSLStd450ModfStruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450FMin> for Instruction {
    fn from(v: OpGLSLStd450FMin) -> Self {
        Self::GLSLStd450FMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450UMin> for Instruction {
    fn from(v: OpGLSLStd450UMin) -> Self {
        Self::GLSLStd450UMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450SMin> for Instruction {
    fn from(v: OpGLSLStd450SMin) -> Self {
        Self::GLSLStd450SMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450FMax> for Instruction {
    fn from(v: OpGLSLStd450FMax) -> Self {
        Self::GLSLStd450FMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450UMax> for Instruction {
    fn from(v: OpGLSLStd450UMax) -> Self {
        Self::GLSLStd450UMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450SMax> for Instruction {
    fn from(v: OpGLSLStd450SMax) -> Self {
        Self::GLSLStd450SMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450FClamp> for Instruction {
    fn from(v: OpGLSLStd450FClamp) -> Self {
        Self::GLSLStd450FClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450UClamp> for Instruction {
    fn from(v: OpGLSLStd450UClamp) -> Self {
        Self::GLSLStd450UClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450SClamp> for Instruction {
    fn from(v: OpGLSLStd450SClamp) -> Self {
        Self::GLSLStd450SClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FMix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub a: IdRef,
}
impl From<OpGLSLStd450FMix> for Instruction {
    fn from(v: OpGLSLStd450FMix) -> Self {
        Self::GLSLStd450FMix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450IMix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub a: IdRef,
}
impl From<OpGLSLStd450IMix> for Instruction {
    fn from(v: OpGLSLStd450IMix) -> Self {
        Self::GLSLStd450IMix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Step {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Step> for Instruction {
    fn from(v: OpGLSLStd450Step) -> Self {
        Self::GLSLStd450Step(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SmoothStep {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge0: IdRef,
    pub edge1: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450SmoothStep> for Instruction {
    fn from(v: OpGLSLStd450SmoothStep) -> Self {
        Self::GLSLStd450SmoothStep(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Fma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpGLSLStd450Fma> for Instruction {
    fn from(v: OpGLSLStd450Fma) -> Self {
        Self::GLSLStd450Fma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Frexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub exp: IdRef,
}
impl From<OpGLSLStd450Frexp> for Instruction {
    fn from(v: OpGLSLStd450Frexp) -> Self {
        Self::GLSLStd450Frexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FrexpStruct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450FrexpStruct> for Instruction {
    fn from(v: OpGLSLStd450FrexpStruct) -> Self {
        Self::GLSLStd450FrexpStruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Ldexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub exp: IdRef,
}
impl From<OpGLSLStd450Ldexp> for Instruction {
    fn from(v: OpGLSLStd450Ldexp) -> Self {
        Self::GLSLStd450Ldexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackSnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackSnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450PackSnorm4x8) -> Self {
        Self::GLSLStd450PackSnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackUnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackUnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450PackUnorm4x8) -> Self {
        Self::GLSLStd450PackUnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackSnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackSnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450PackSnorm2x16) -> Self {
        Self::GLSLStd450PackSnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackUnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackUnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450PackUnorm2x16) -> Self {
        Self::GLSLStd450PackUnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackHalf2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackHalf2x16> for Instruction {
    fn from(v: OpGLSLStd450PackHalf2x16) -> Self {
        Self::GLSLStd450PackHalf2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackDouble2x32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackDouble2x32> for Instruction {
    fn from(v: OpGLSLStd450PackDouble2x32) -> Self {
        Self::GLSLStd450PackDouble2x32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackSnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackSnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450UnpackSnorm2x16) -> Self {
        Self::GLSLStd450UnpackSnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackUnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackUnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450UnpackUnorm2x16) -> Self {
        Self::GLSLStd450UnpackUnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackHalf2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450UnpackHalf2x16> for Instruction {
    fn from(v: OpGLSLStd450UnpackHalf2x16) -> Self {
        Self::GLSLStd450UnpackHalf2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackSnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackSnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450UnpackSnorm4x8) -> Self {
        Self::GLSLStd450UnpackSnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackUnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackUnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450UnpackUnorm4x8) -> Self {
        Self::GLSLStd450UnpackUnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackDouble2x32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450UnpackDouble2x32> for Instruction {
    fn from(v: OpGLSLStd450UnpackDouble2x32) -> Self {
        Self::GLSLStd450UnpackDouble2x32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Length {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Length> for Instruction {
    fn from(v: OpGLSLStd450Length) -> Self {
        Self::GLSLStd450Length(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Distance {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpGLSLStd450Distance> for Instruction {
    fn from(v: OpGLSLStd450Distance) -> Self {
        Self::GLSLStd450Distance(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Cross {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450Cross> for Instruction {
    fn from(v: OpGLSLStd450Cross) -> Self {
        Self::GLSLStd450Cross(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Normalize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Normalize> for Instruction {
    fn from(v: OpGLSLStd450Normalize) -> Self {
        Self::GLSLStd450Normalize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FaceForward {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub n: IdRef,
    pub i: IdRef,
    pub nref: IdRef,
}
impl From<OpGLSLStd450FaceForward> for Instruction {
    fn from(v: OpGLSLStd450FaceForward) -> Self {
        Self::GLSLStd450FaceForward(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Reflect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub i: IdRef,
    pub n: IdRef,
}
impl From<OpGLSLStd450Reflect> for Instruction {
    fn from(v: OpGLSLStd450Reflect) -> Self {
        Self::GLSLStd450Reflect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Refract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub i: IdRef,
    pub n: IdRef,
    pub eta: IdRef,
}
impl From<OpGLSLStd450Refract> for Instruction {
    fn from(v: OpGLSLStd450Refract) -> Self {
        Self::GLSLStd450Refract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FindILsb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub value: IdRef,
}
impl From<OpGLSLStd450FindILsb> for Instruction {
    fn from(v: OpGLSLStd450FindILsb) -> Self {
        Self::GLSLStd450FindILsb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FindSMsb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub value: IdRef,
}
impl From<OpGLSLStd450FindSMsb> for Instruction {
    fn from(v: OpGLSLStd450FindSMsb) -> Self {
        Self::GLSLStd450FindSMsb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FindUMsb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub value: IdRef,
}
impl From<OpGLSLStd450FindUMsb> for Instruction {
    fn from(v: OpGLSLStd450FindUMsb) -> Self {
        Self::GLSLStd450FindUMsb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InterpolateAtCentroid {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub interpolant: IdRef,
}
impl From<OpGLSLStd450InterpolateAtCentroid> for Instruction {
    fn from(v: OpGLSLStd450InterpolateAtCentroid) -> Self {
        Self::GLSLStd450InterpolateAtCentroid(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InterpolateAtSample {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub interpolant: IdRef,
    pub sample: IdRef,
}
impl From<OpGLSLStd450InterpolateAtSample> for Instruction {
    fn from(v: OpGLSLStd450InterpolateAtSample) -> Self {
        Self::GLSLStd450InterpolateAtSample(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InterpolateAtOffset {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub interpolant: IdRef,
    pub offset: IdRef,
}
impl From<OpGLSLStd450InterpolateAtOffset> for Instruction {
    fn from(v: OpGLSLStd450InterpolateAtOffset) -> Self {
        Self::GLSLStd450InterpolateAtOffset(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450NMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450NMin> for Instruction {
    fn from(v: OpGLSLStd450NMin) -> Self {
        Self::GLSLStd450NMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450NMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450NMax> for Instruction {
    fn from(v: OpGLSLStd450NMax) -> Self {
        Self::GLSLStd450NMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450NClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450NClamp> for Instruction {
    fn from(v: OpGLSLStd450NClamp) -> Self {
        Self::GLSLStd450NClamp(v)
    }
}
#[derive(Clone, Debug)]
pub enum Instruction {
    Nop(OpNop),
    Undef(OpUndef),
    SourceContinued(OpSourceContinued),
    Source(OpSource),
    SourceExtension(OpSourceExtension),
    Name(OpName),
    MemberName(OpMemberName),
    String(OpString),
    Line(OpLine),
    Extension(OpExtension),
    ExtInstImport(OpExtInstImport),
    ExtInst(OpExtInst),
    MemoryModel(OpMemoryModel),
    EntryPoint(OpEntryPoint),
    ExecutionMode(OpExecutionMode),
    Capability(OpCapability),
    TypeVoid(OpTypeVoid),
    TypeBool(OpTypeBool),
    TypeInt(OpTypeInt),
    TypeFloat(OpTypeFloat),
    TypeVector(OpTypeVector),
    TypeMatrix(OpTypeMatrix),
    TypeImage(OpTypeImage),
    TypeSampler(OpTypeSampler),
    TypeSampledImage(OpTypeSampledImage),
    TypeArray(OpTypeArray),
    TypeRuntimeArray(OpTypeRuntimeArray),
    TypeStruct(OpTypeStruct),
    TypeOpaque(OpTypeOpaque),
    TypePointer(OpTypePointer),
    TypeFunction(OpTypeFunction),
    TypeEvent(OpTypeEvent),
    TypeDeviceEvent(OpTypeDeviceEvent),
    TypeReserveId(OpTypeReserveId),
    TypeQueue(OpTypeQueue),
    TypePipe(OpTypePipe),
    TypeForwardPointer(OpTypeForwardPointer),
    ConstantTrue(OpConstantTrue),
    ConstantFalse(OpConstantFalse),
    Constant32(OpConstant32),
    Constant64(OpConstant64),
    ConstantComposite(OpConstantComposite),
    ConstantSampler(OpConstantSampler),
    ConstantNull(OpConstantNull),
    SpecConstantTrue(OpSpecConstantTrue),
    SpecConstantFalse(OpSpecConstantFalse),
    SpecConstant32(OpSpecConstant32),
    SpecConstant64(OpSpecConstant64),
    SpecConstantComposite(OpSpecConstantComposite),
    SpecConstantOp(OpSpecConstantOp),
    Function(OpFunction),
    FunctionParameter(OpFunctionParameter),
    FunctionEnd(OpFunctionEnd),
    FunctionCall(OpFunctionCall),
    Variable(OpVariable),
    ImageTexelPointer(OpImageTexelPointer),
    Load(OpLoad),
    Store(OpStore),
    CopyMemory(OpCopyMemory),
    CopyMemorySized(OpCopyMemorySized),
    AccessChain(OpAccessChain),
    InBoundsAccessChain(OpInBoundsAccessChain),
    PtrAccessChain(OpPtrAccessChain),
    ArrayLength(OpArrayLength),
    GenericPtrMemSemantics(OpGenericPtrMemSemantics),
    InBoundsPtrAccessChain(OpInBoundsPtrAccessChain),
    Decorate(OpDecorate),
    MemberDecorate(OpMemberDecorate),
    DecorationGroup(OpDecorationGroup),
    GroupDecorate(OpGroupDecorate),
    GroupMemberDecorate(OpGroupMemberDecorate),
    VectorExtractDynamic(OpVectorExtractDynamic),
    VectorInsertDynamic(OpVectorInsertDynamic),
    VectorShuffle(OpVectorShuffle),
    CompositeConstruct(OpCompositeConstruct),
    CompositeExtract(OpCompositeExtract),
    CompositeInsert(OpCompositeInsert),
    CopyObject(OpCopyObject),
    Transpose(OpTranspose),
    SampledImage(OpSampledImage),
    ImageSampleImplicitLod(OpImageSampleImplicitLod),
    ImageSampleExplicitLod(OpImageSampleExplicitLod),
    ImageSampleDrefImplicitLod(OpImageSampleDrefImplicitLod),
    ImageSampleDrefExplicitLod(OpImageSampleDrefExplicitLod),
    ImageSampleProjImplicitLod(OpImageSampleProjImplicitLod),
    ImageSampleProjExplicitLod(OpImageSampleProjExplicitLod),
    ImageSampleProjDrefImplicitLod(OpImageSampleProjDrefImplicitLod),
    ImageSampleProjDrefExplicitLod(OpImageSampleProjDrefExplicitLod),
    ImageFetch(OpImageFetch),
    ImageGather(OpImageGather),
    ImageDrefGather(OpImageDrefGather),
    ImageRead(OpImageRead),
    ImageWrite(OpImageWrite),
    Image(OpImage),
    ImageQueryFormat(OpImageQueryFormat),
    ImageQueryOrder(OpImageQueryOrder),
    ImageQuerySizeLod(OpImageQuerySizeLod),
    ImageQuerySize(OpImageQuerySize),
    ImageQueryLod(OpImageQueryLod),
    ImageQueryLevels(OpImageQueryLevels),
    ImageQuerySamples(OpImageQuerySamples),
    ConvertFToU(OpConvertFToU),
    ConvertFToS(OpConvertFToS),
    ConvertSToF(OpConvertSToF),
    ConvertUToF(OpConvertUToF),
    UConvert(OpUConvert),
    SConvert(OpSConvert),
    FConvert(OpFConvert),
    QuantizeToF16(OpQuantizeToF16),
    ConvertPtrToU(OpConvertPtrToU),
    SatConvertSToU(OpSatConvertSToU),
    SatConvertUToS(OpSatConvertUToS),
    ConvertUToPtr(OpConvertUToPtr),
    PtrCastToGeneric(OpPtrCastToGeneric),
    GenericCastToPtr(OpGenericCastToPtr),
    GenericCastToPtrExplicit(OpGenericCastToPtrExplicit),
    Bitcast(OpBitcast),
    SNegate(OpSNegate),
    FNegate(OpFNegate),
    IAdd(OpIAdd),
    FAdd(OpFAdd),
    ISub(OpISub),
    FSub(OpFSub),
    IMul(OpIMul),
    FMul(OpFMul),
    UDiv(OpUDiv),
    SDiv(OpSDiv),
    FDiv(OpFDiv),
    UMod(OpUMod),
    SRem(OpSRem),
    SMod(OpSMod),
    FRem(OpFRem),
    FMod(OpFMod),
    VectorTimesScalar(OpVectorTimesScalar),
    MatrixTimesScalar(OpMatrixTimesScalar),
    VectorTimesMatrix(OpVectorTimesMatrix),
    MatrixTimesVector(OpMatrixTimesVector),
    MatrixTimesMatrix(OpMatrixTimesMatrix),
    OuterProduct(OpOuterProduct),
    Dot(OpDot),
    IAddCarry(OpIAddCarry),
    ISubBorrow(OpISubBorrow),
    UMulExtended(OpUMulExtended),
    SMulExtended(OpSMulExtended),
    Any(OpAny),
    All(OpAll),
    IsNan(OpIsNan),
    IsInf(OpIsInf),
    IsFinite(OpIsFinite),
    IsNormal(OpIsNormal),
    SignBitSet(OpSignBitSet),
    LessOrGreater(OpLessOrGreater),
    Ordered(OpOrdered),
    Unordered(OpUnordered),
    LogicalEqual(OpLogicalEqual),
    LogicalNotEqual(OpLogicalNotEqual),
    LogicalOr(OpLogicalOr),
    LogicalAnd(OpLogicalAnd),
    LogicalNot(OpLogicalNot),
    Select(OpSelect),
    IEqual(OpIEqual),
    INotEqual(OpINotEqual),
    UGreaterThan(OpUGreaterThan),
    SGreaterThan(OpSGreaterThan),
    UGreaterThanEqual(OpUGreaterThanEqual),
    SGreaterThanEqual(OpSGreaterThanEqual),
    ULessThan(OpULessThan),
    SLessThan(OpSLessThan),
    ULessThanEqual(OpULessThanEqual),
    SLessThanEqual(OpSLessThanEqual),
    FOrdEqual(OpFOrdEqual),
    FUnordEqual(OpFUnordEqual),
    FOrdNotEqual(OpFOrdNotEqual),
    FUnordNotEqual(OpFUnordNotEqual),
    FOrdLessThan(OpFOrdLessThan),
    FUnordLessThan(OpFUnordLessThan),
    FOrdGreaterThan(OpFOrdGreaterThan),
    FUnordGreaterThan(OpFUnordGreaterThan),
    FOrdLessThanEqual(OpFOrdLessThanEqual),
    FUnordLessThanEqual(OpFUnordLessThanEqual),
    FOrdGreaterThanEqual(OpFOrdGreaterThanEqual),
    FUnordGreaterThanEqual(OpFUnordGreaterThanEqual),
    ShiftRightLogical(OpShiftRightLogical),
    ShiftRightArithmetic(OpShiftRightArithmetic),
    ShiftLeftLogical(OpShiftLeftLogical),
    BitwiseOr(OpBitwiseOr),
    BitwiseXor(OpBitwiseXor),
    BitwiseAnd(OpBitwiseAnd),
    Not(OpNot),
    BitFieldInsert(OpBitFieldInsert),
    BitFieldSExtract(OpBitFieldSExtract),
    BitFieldUExtract(OpBitFieldUExtract),
    BitReverse(OpBitReverse),
    BitCount(OpBitCount),
    DPdx(OpDPdx),
    DPdy(OpDPdy),
    Fwidth(OpFwidth),
    DPdxFine(OpDPdxFine),
    DPdyFine(OpDPdyFine),
    FwidthFine(OpFwidthFine),
    DPdxCoarse(OpDPdxCoarse),
    DPdyCoarse(OpDPdyCoarse),
    FwidthCoarse(OpFwidthCoarse),
    EmitVertex(OpEmitVertex),
    EndPrimitive(OpEndPrimitive),
    EmitStreamVertex(OpEmitStreamVertex),
    EndStreamPrimitive(OpEndStreamPrimitive),
    ControlBarrier(OpControlBarrier),
    MemoryBarrier(OpMemoryBarrier),
    AtomicLoad(OpAtomicLoad),
    AtomicStore(OpAtomicStore),
    AtomicExchange(OpAtomicExchange),
    AtomicCompareExchange(OpAtomicCompareExchange),
    AtomicCompareExchangeWeak(OpAtomicCompareExchangeWeak),
    AtomicIIncrement(OpAtomicIIncrement),
    AtomicIDecrement(OpAtomicIDecrement),
    AtomicIAdd(OpAtomicIAdd),
    AtomicISub(OpAtomicISub),
    AtomicSMin(OpAtomicSMin),
    AtomicUMin(OpAtomicUMin),
    AtomicSMax(OpAtomicSMax),
    AtomicUMax(OpAtomicUMax),
    AtomicAnd(OpAtomicAnd),
    AtomicOr(OpAtomicOr),
    AtomicXor(OpAtomicXor),
    Phi(OpPhi),
    LoopMerge(OpLoopMerge),
    SelectionMerge(OpSelectionMerge),
    Label(OpLabel),
    Branch(OpBranch),
    BranchConditional(OpBranchConditional),
    Switch32(OpSwitch32),
    Switch64(OpSwitch64),
    Kill(OpKill),
    Return(OpReturn),
    ReturnValue(OpReturnValue),
    Unreachable(OpUnreachable),
    LifetimeStart(OpLifetimeStart),
    LifetimeStop(OpLifetimeStop),
    GroupAsyncCopy(OpGroupAsyncCopy),
    GroupWaitEvents(OpGroupWaitEvents),
    GroupAll(OpGroupAll),
    GroupAny(OpGroupAny),
    GroupBroadcast(OpGroupBroadcast),
    GroupIAdd(OpGroupIAdd),
    GroupFAdd(OpGroupFAdd),
    GroupFMin(OpGroupFMin),
    GroupUMin(OpGroupUMin),
    GroupSMin(OpGroupSMin),
    GroupFMax(OpGroupFMax),
    GroupUMax(OpGroupUMax),
    GroupSMax(OpGroupSMax),
    ReadPipe(OpReadPipe),
    WritePipe(OpWritePipe),
    ReservedReadPipe(OpReservedReadPipe),
    ReservedWritePipe(OpReservedWritePipe),
    ReserveReadPipePackets(OpReserveReadPipePackets),
    ReserveWritePipePackets(OpReserveWritePipePackets),
    CommitReadPipe(OpCommitReadPipe),
    CommitWritePipe(OpCommitWritePipe),
    IsValidReserveId(OpIsValidReserveId),
    GetNumPipePackets(OpGetNumPipePackets),
    GetMaxPipePackets(OpGetMaxPipePackets),
    GroupReserveReadPipePackets(OpGroupReserveReadPipePackets),
    GroupReserveWritePipePackets(OpGroupReserveWritePipePackets),
    GroupCommitReadPipe(OpGroupCommitReadPipe),
    GroupCommitWritePipe(OpGroupCommitWritePipe),
    EnqueueMarker(OpEnqueueMarker),
    EnqueueKernel(OpEnqueueKernel),
    GetKernelNDrangeSubGroupCount(OpGetKernelNDrangeSubGroupCount),
    GetKernelNDrangeMaxSubGroupSize(OpGetKernelNDrangeMaxSubGroupSize),
    GetKernelWorkGroupSize(OpGetKernelWorkGroupSize),
    GetKernelPreferredWorkGroupSizeMultiple(OpGetKernelPreferredWorkGroupSizeMultiple),
    RetainEvent(OpRetainEvent),
    ReleaseEvent(OpReleaseEvent),
    CreateUserEvent(OpCreateUserEvent),
    IsValidEvent(OpIsValidEvent),
    SetUserEventStatus(OpSetUserEventStatus),
    CaptureEventProfilingInfo(OpCaptureEventProfilingInfo),
    GetDefaultQueue(OpGetDefaultQueue),
    BuildNDRange(OpBuildNDRange),
    ImageSparseSampleImplicitLod(OpImageSparseSampleImplicitLod),
    ImageSparseSampleExplicitLod(OpImageSparseSampleExplicitLod),
    ImageSparseSampleDrefImplicitLod(OpImageSparseSampleDrefImplicitLod),
    ImageSparseSampleDrefExplicitLod(OpImageSparseSampleDrefExplicitLod),
    ImageSparseFetch(OpImageSparseFetch),
    ImageSparseGather(OpImageSparseGather),
    ImageSparseDrefGather(OpImageSparseDrefGather),
    ImageSparseTexelsResident(OpImageSparseTexelsResident),
    NoLine(OpNoLine),
    AtomicFlagTestAndSet(OpAtomicFlagTestAndSet),
    AtomicFlagClear(OpAtomicFlagClear),
    ImageSparseRead(OpImageSparseRead),
    SizeOf(OpSizeOf),
    TypePipeStorage(OpTypePipeStorage),
    ConstantPipeStorage(OpConstantPipeStorage),
    CreatePipeFromPipeStorage(OpCreatePipeFromPipeStorage),
    GetKernelLocalSizeForSubgroupCount(OpGetKernelLocalSizeForSubgroupCount),
    GetKernelMaxNumSubgroups(OpGetKernelMaxNumSubgroups),
    TypeNamedBarrier(OpTypeNamedBarrier),
    NamedBarrierInitialize(OpNamedBarrierInitialize),
    MemoryNamedBarrier(OpMemoryNamedBarrier),
    ModuleProcessed(OpModuleProcessed),
    ExecutionModeId(OpExecutionModeId),
    DecorateId(OpDecorateId),
    GroupNonUniformElect(OpGroupNonUniformElect),
    GroupNonUniformAll(OpGroupNonUniformAll),
    GroupNonUniformAny(OpGroupNonUniformAny),
    GroupNonUniformAllEqual(OpGroupNonUniformAllEqual),
    GroupNonUniformBroadcast(OpGroupNonUniformBroadcast),
    GroupNonUniformBroadcastFirst(OpGroupNonUniformBroadcastFirst),
    GroupNonUniformBallot(OpGroupNonUniformBallot),
    GroupNonUniformInverseBallot(OpGroupNonUniformInverseBallot),
    GroupNonUniformBallotBitExtract(OpGroupNonUniformBallotBitExtract),
    GroupNonUniformBallotBitCount(OpGroupNonUniformBallotBitCount),
    GroupNonUniformBallotFindLSB(OpGroupNonUniformBallotFindLSB),
    GroupNonUniformBallotFindMSB(OpGroupNonUniformBallotFindMSB),
    GroupNonUniformShuffle(OpGroupNonUniformShuffle),
    GroupNonUniformShuffleXor(OpGroupNonUniformShuffleXor),
    GroupNonUniformShuffleUp(OpGroupNonUniformShuffleUp),
    GroupNonUniformShuffleDown(OpGroupNonUniformShuffleDown),
    GroupNonUniformIAdd(OpGroupNonUniformIAdd),
    GroupNonUniformFAdd(OpGroupNonUniformFAdd),
    GroupNonUniformIMul(OpGroupNonUniformIMul),
    GroupNonUniformFMul(OpGroupNonUniformFMul),
    GroupNonUniformSMin(OpGroupNonUniformSMin),
    GroupNonUniformUMin(OpGroupNonUniformUMin),
    GroupNonUniformFMin(OpGroupNonUniformFMin),
    GroupNonUniformSMax(OpGroupNonUniformSMax),
    GroupNonUniformUMax(OpGroupNonUniformUMax),
    GroupNonUniformFMax(OpGroupNonUniformFMax),
    GroupNonUniformBitwiseAnd(OpGroupNonUniformBitwiseAnd),
    GroupNonUniformBitwiseOr(OpGroupNonUniformBitwiseOr),
    GroupNonUniformBitwiseXor(OpGroupNonUniformBitwiseXor),
    GroupNonUniformLogicalAnd(OpGroupNonUniformLogicalAnd),
    GroupNonUniformLogicalOr(OpGroupNonUniformLogicalOr),
    GroupNonUniformLogicalXor(OpGroupNonUniformLogicalXor),
    GroupNonUniformQuadBroadcast(OpGroupNonUniformQuadBroadcast),
    GroupNonUniformQuadSwap(OpGroupNonUniformQuadSwap),
    CopyLogical(OpCopyLogical),
    PtrEqual(OpPtrEqual),
    PtrNotEqual(OpPtrNotEqual),
    PtrDiff(OpPtrDiff),
    DecorateString(OpDecorateString),
    MemberDecorateString(OpMemberDecorateString),
    OpenCLStdAcos(OpOpenCLStdAcos),
    OpenCLStdAcosh(OpOpenCLStdAcosh),
    OpenCLStdAcospi(OpOpenCLStdAcospi),
    OpenCLStdAsin(OpOpenCLStdAsin),
    OpenCLStdAsinh(OpOpenCLStdAsinh),
    OpenCLStdAsinpi(OpOpenCLStdAsinpi),
    OpenCLStdAtan(OpOpenCLStdAtan),
    OpenCLStdAtan2(OpOpenCLStdAtan2),
    OpenCLStdAtanh(OpOpenCLStdAtanh),
    OpenCLStdAtanpi(OpOpenCLStdAtanpi),
    OpenCLStdAtan2pi(OpOpenCLStdAtan2pi),
    OpenCLStdCbrt(OpOpenCLStdCbrt),
    OpenCLStdCeil(OpOpenCLStdCeil),
    OpenCLStdCopysign(OpOpenCLStdCopysign),
    OpenCLStdCos(OpOpenCLStdCos),
    OpenCLStdCosh(OpOpenCLStdCosh),
    OpenCLStdCospi(OpOpenCLStdCospi),
    OpenCLStdErfc(OpOpenCLStdErfc),
    OpenCLStdErf(OpOpenCLStdErf),
    OpenCLStdExp(OpOpenCLStdExp),
    OpenCLStdExp2(OpOpenCLStdExp2),
    OpenCLStdExp10(OpOpenCLStdExp10),
    OpenCLStdExpm1(OpOpenCLStdExpm1),
    OpenCLStdFabs(OpOpenCLStdFabs),
    OpenCLStdFdim(OpOpenCLStdFdim),
    OpenCLStdFloor(OpOpenCLStdFloor),
    OpenCLStdFma(OpOpenCLStdFma),
    OpenCLStdFmax(OpOpenCLStdFmax),
    OpenCLStdFmin(OpOpenCLStdFmin),
    OpenCLStdFmod(OpOpenCLStdFmod),
    OpenCLStdFract(OpOpenCLStdFract),
    OpenCLStdFrexp(OpOpenCLStdFrexp),
    OpenCLStdHypot(OpOpenCLStdHypot),
    OpenCLStdIlogb(OpOpenCLStdIlogb),
    OpenCLStdLdexp(OpOpenCLStdLdexp),
    OpenCLStdLgamma(OpOpenCLStdLgamma),
    OpenCLStdLgammaR(OpOpenCLStdLgammaR),
    OpenCLStdLog(OpOpenCLStdLog),
    OpenCLStdLog2(OpOpenCLStdLog2),
    OpenCLStdLog10(OpOpenCLStdLog10),
    OpenCLStdLog1p(OpOpenCLStdLog1p),
    OpenCLStdLogb(OpOpenCLStdLogb),
    OpenCLStdMad(OpOpenCLStdMad),
    OpenCLStdMaxmag(OpOpenCLStdMaxmag),
    OpenCLStdMinmag(OpOpenCLStdMinmag),
    OpenCLStdModf(OpOpenCLStdModf),
    OpenCLStdNan(OpOpenCLStdNan),
    OpenCLStdNextafter(OpOpenCLStdNextafter),
    OpenCLStdPow(OpOpenCLStdPow),
    OpenCLStdPown(OpOpenCLStdPown),
    OpenCLStdPowr(OpOpenCLStdPowr),
    OpenCLStdRemainder(OpOpenCLStdRemainder),
    OpenCLStdRemquo(OpOpenCLStdRemquo),
    OpenCLStdRint(OpOpenCLStdRint),
    OpenCLStdRootn(OpOpenCLStdRootn),
    OpenCLStdRound(OpOpenCLStdRound),
    OpenCLStdRsqrt(OpOpenCLStdRsqrt),
    OpenCLStdSin(OpOpenCLStdSin),
    OpenCLStdSincos(OpOpenCLStdSincos),
    OpenCLStdSinh(OpOpenCLStdSinh),
    OpenCLStdSinpi(OpOpenCLStdSinpi),
    OpenCLStdSqrt(OpOpenCLStdSqrt),
    OpenCLStdTan(OpOpenCLStdTan),
    OpenCLStdTanh(OpOpenCLStdTanh),
    OpenCLStdTanpi(OpOpenCLStdTanpi),
    OpenCLStdTgamma(OpOpenCLStdTgamma),
    OpenCLStdTrunc(OpOpenCLStdTrunc),
    OpenCLStdHalfCos(OpOpenCLStdHalfCos),
    OpenCLStdHalfDivide(OpOpenCLStdHalfDivide),
    OpenCLStdHalfExp(OpOpenCLStdHalfExp),
    OpenCLStdHalfExp2(OpOpenCLStdHalfExp2),
    OpenCLStdHalfExp10(OpOpenCLStdHalfExp10),
    OpenCLStdHalfLog(OpOpenCLStdHalfLog),
    OpenCLStdHalfLog2(OpOpenCLStdHalfLog2),
    OpenCLStdHalfLog10(OpOpenCLStdHalfLog10),
    OpenCLStdHalfPowr(OpOpenCLStdHalfPowr),
    OpenCLStdHalfRecip(OpOpenCLStdHalfRecip),
    OpenCLStdHalfRsqrt(OpOpenCLStdHalfRsqrt),
    OpenCLStdHalfSin(OpOpenCLStdHalfSin),
    OpenCLStdHalfSqrt(OpOpenCLStdHalfSqrt),
    OpenCLStdHalfTan(OpOpenCLStdHalfTan),
    OpenCLStdNativeCos(OpOpenCLStdNativeCos),
    OpenCLStdNativeDivide(OpOpenCLStdNativeDivide),
    OpenCLStdNativeExp(OpOpenCLStdNativeExp),
    OpenCLStdNativeExp2(OpOpenCLStdNativeExp2),
    OpenCLStdNativeExp10(OpOpenCLStdNativeExp10),
    OpenCLStdNativeLog(OpOpenCLStdNativeLog),
    OpenCLStdNativeLog2(OpOpenCLStdNativeLog2),
    OpenCLStdNativeLog10(OpOpenCLStdNativeLog10),
    OpenCLStdNativePowr(OpOpenCLStdNativePowr),
    OpenCLStdNativeRecip(OpOpenCLStdNativeRecip),
    OpenCLStdNativeRsqrt(OpOpenCLStdNativeRsqrt),
    OpenCLStdNativeSin(OpOpenCLStdNativeSin),
    OpenCLStdNativeSqrt(OpOpenCLStdNativeSqrt),
    OpenCLStdNativeTan(OpOpenCLStdNativeTan),
    OpenCLStdSAbs(OpOpenCLStdSAbs),
    OpenCLStdSAbsDiff(OpOpenCLStdSAbsDiff),
    OpenCLStdSAddSat(OpOpenCLStdSAddSat),
    OpenCLStdUAddSat(OpOpenCLStdUAddSat),
    OpenCLStdSHadd(OpOpenCLStdSHadd),
    OpenCLStdUHadd(OpOpenCLStdUHadd),
    OpenCLStdSRhadd(OpOpenCLStdSRhadd),
    OpenCLStdURhadd(OpOpenCLStdURhadd),
    OpenCLStdSClamp(OpOpenCLStdSClamp),
    OpenCLStdUClamp(OpOpenCLStdUClamp),
    OpenCLStdClz(OpOpenCLStdClz),
    OpenCLStdCtz(OpOpenCLStdCtz),
    OpenCLStdSMadHi(OpOpenCLStdSMadHi),
    OpenCLStdUMadSat(OpOpenCLStdUMadSat),
    OpenCLStdSMadSat(OpOpenCLStdSMadSat),
    OpenCLStdSMax(OpOpenCLStdSMax),
    OpenCLStdUMax(OpOpenCLStdUMax),
    OpenCLStdSMin(OpOpenCLStdSMin),
    OpenCLStdUMin(OpOpenCLStdUMin),
    OpenCLStdSMulHi(OpOpenCLStdSMulHi),
    OpenCLStdRotate(OpOpenCLStdRotate),
    OpenCLStdSSubSat(OpOpenCLStdSSubSat),
    OpenCLStdUSubSat(OpOpenCLStdUSubSat),
    OpenCLStdUUpsample(OpOpenCLStdUUpsample),
    OpenCLStdSUpsample(OpOpenCLStdSUpsample),
    OpenCLStdPopcount(OpOpenCLStdPopcount),
    OpenCLStdSMad24(OpOpenCLStdSMad24),
    OpenCLStdUMad24(OpOpenCLStdUMad24),
    OpenCLStdSMul24(OpOpenCLStdSMul24),
    OpenCLStdUMul24(OpOpenCLStdUMul24),
    OpenCLStdUAbs(OpOpenCLStdUAbs),
    OpenCLStdUAbsDiff(OpOpenCLStdUAbsDiff),
    OpenCLStdUMulHi(OpOpenCLStdUMulHi),
    OpenCLStdUMadHi(OpOpenCLStdUMadHi),
    OpenCLStdFclamp(OpOpenCLStdFclamp),
    OpenCLStdDegrees(OpOpenCLStdDegrees),
    OpenCLStdFmaxCommon(OpOpenCLStdFmaxCommon),
    OpenCLStdFminCommon(OpOpenCLStdFminCommon),
    OpenCLStdMix(OpOpenCLStdMix),
    OpenCLStdRadians(OpOpenCLStdRadians),
    OpenCLStdStep(OpOpenCLStdStep),
    OpenCLStdSmoothstep(OpOpenCLStdSmoothstep),
    OpenCLStdSign(OpOpenCLStdSign),
    OpenCLStdCross(OpOpenCLStdCross),
    OpenCLStdDistance(OpOpenCLStdDistance),
    OpenCLStdLength(OpOpenCLStdLength),
    OpenCLStdNormalize(OpOpenCLStdNormalize),
    OpenCLStdFastDistance(OpOpenCLStdFastDistance),
    OpenCLStdFastLength(OpOpenCLStdFastLength),
    OpenCLStdFastNormalize(OpOpenCLStdFastNormalize),
    OpenCLStdBitselect(OpOpenCLStdBitselect),
    OpenCLStdSelect(OpOpenCLStdSelect),
    OpenCLStdVloadn(OpOpenCLStdVloadn),
    OpenCLStdVstoren(OpOpenCLStdVstoren),
    OpenCLStdVloadHalf(OpOpenCLStdVloadHalf),
    OpenCLStdVloadHalfn(OpOpenCLStdVloadHalfn),
    OpenCLStdVstoreHalf(OpOpenCLStdVstoreHalf),
    OpenCLStdVstoreHalfR(OpOpenCLStdVstoreHalfR),
    OpenCLStdVstoreHalfn(OpOpenCLStdVstoreHalfn),
    OpenCLStdVstoreHalfnR(OpOpenCLStdVstoreHalfnR),
    OpenCLStdVloadaHalfn(OpOpenCLStdVloadaHalfn),
    OpenCLStdVstoreaHalfn(OpOpenCLStdVstoreaHalfn),
    OpenCLStdVstoreaHalfnR(OpOpenCLStdVstoreaHalfnR),
    OpenCLStdShuffle(OpOpenCLStdShuffle),
    OpenCLStdShuffle2(OpOpenCLStdShuffle2),
    OpenCLStdPrintf(OpOpenCLStdPrintf),
    OpenCLStdPrefetch(OpOpenCLStdPrefetch),
    GLSLStd450Round(OpGLSLStd450Round),
    GLSLStd450RoundEven(OpGLSLStd450RoundEven),
    GLSLStd450Trunc(OpGLSLStd450Trunc),
    GLSLStd450FAbs(OpGLSLStd450FAbs),
    GLSLStd450SAbs(OpGLSLStd450SAbs),
    GLSLStd450FSign(OpGLSLStd450FSign),
    GLSLStd450SSign(OpGLSLStd450SSign),
    GLSLStd450Floor(OpGLSLStd450Floor),
    GLSLStd450Ceil(OpGLSLStd450Ceil),
    GLSLStd450Fract(OpGLSLStd450Fract),
    GLSLStd450Radians(OpGLSLStd450Radians),
    GLSLStd450Degrees(OpGLSLStd450Degrees),
    GLSLStd450Sin(OpGLSLStd450Sin),
    GLSLStd450Cos(OpGLSLStd450Cos),
    GLSLStd450Tan(OpGLSLStd450Tan),
    GLSLStd450Asin(OpGLSLStd450Asin),
    GLSLStd450Acos(OpGLSLStd450Acos),
    GLSLStd450Atan(OpGLSLStd450Atan),
    GLSLStd450Sinh(OpGLSLStd450Sinh),
    GLSLStd450Cosh(OpGLSLStd450Cosh),
    GLSLStd450Tanh(OpGLSLStd450Tanh),
    GLSLStd450Asinh(OpGLSLStd450Asinh),
    GLSLStd450Acosh(OpGLSLStd450Acosh),
    GLSLStd450Atanh(OpGLSLStd450Atanh),
    GLSLStd450Atan2(OpGLSLStd450Atan2),
    GLSLStd450Pow(OpGLSLStd450Pow),
    GLSLStd450Exp(OpGLSLStd450Exp),
    GLSLStd450Log(OpGLSLStd450Log),
    GLSLStd450Exp2(OpGLSLStd450Exp2),
    GLSLStd450Log2(OpGLSLStd450Log2),
    GLSLStd450Sqrt(OpGLSLStd450Sqrt),
    GLSLStd450InverseSqrt(OpGLSLStd450InverseSqrt),
    GLSLStd450Determinant(OpGLSLStd450Determinant),
    GLSLStd450MatrixInverse(OpGLSLStd450MatrixInverse),
    GLSLStd450Modf(OpGLSLStd450Modf),
    GLSLStd450ModfStruct(OpGLSLStd450ModfStruct),
    GLSLStd450FMin(OpGLSLStd450FMin),
    GLSLStd450UMin(OpGLSLStd450UMin),
    GLSLStd450SMin(OpGLSLStd450SMin),
    GLSLStd450FMax(OpGLSLStd450FMax),
    GLSLStd450UMax(OpGLSLStd450UMax),
    GLSLStd450SMax(OpGLSLStd450SMax),
    GLSLStd450FClamp(OpGLSLStd450FClamp),
    GLSLStd450UClamp(OpGLSLStd450UClamp),
    GLSLStd450SClamp(OpGLSLStd450SClamp),
    GLSLStd450FMix(OpGLSLStd450FMix),
    GLSLStd450IMix(OpGLSLStd450IMix),
    GLSLStd450Step(OpGLSLStd450Step),
    GLSLStd450SmoothStep(OpGLSLStd450SmoothStep),
    GLSLStd450Fma(OpGLSLStd450Fma),
    GLSLStd450Frexp(OpGLSLStd450Frexp),
    GLSLStd450FrexpStruct(OpGLSLStd450FrexpStruct),
    GLSLStd450Ldexp(OpGLSLStd450Ldexp),
    GLSLStd450PackSnorm4x8(OpGLSLStd450PackSnorm4x8),
    GLSLStd450PackUnorm4x8(OpGLSLStd450PackUnorm4x8),
    GLSLStd450PackSnorm2x16(OpGLSLStd450PackSnorm2x16),
    GLSLStd450PackUnorm2x16(OpGLSLStd450PackUnorm2x16),
    GLSLStd450PackHalf2x16(OpGLSLStd450PackHalf2x16),
    GLSLStd450PackDouble2x32(OpGLSLStd450PackDouble2x32),
    GLSLStd450UnpackSnorm2x16(OpGLSLStd450UnpackSnorm2x16),
    GLSLStd450UnpackUnorm2x16(OpGLSLStd450UnpackUnorm2x16),
    GLSLStd450UnpackHalf2x16(OpGLSLStd450UnpackHalf2x16),
    GLSLStd450UnpackSnorm4x8(OpGLSLStd450UnpackSnorm4x8),
    GLSLStd450UnpackUnorm4x8(OpGLSLStd450UnpackUnorm4x8),
    GLSLStd450UnpackDouble2x32(OpGLSLStd450UnpackDouble2x32),
    GLSLStd450Length(OpGLSLStd450Length),
    GLSLStd450Distance(OpGLSLStd450Distance),
    GLSLStd450Cross(OpGLSLStd450Cross),
    GLSLStd450Normalize(OpGLSLStd450Normalize),
    GLSLStd450FaceForward(OpGLSLStd450FaceForward),
    GLSLStd450Reflect(OpGLSLStd450Reflect),
    GLSLStd450Refract(OpGLSLStd450Refract),
    GLSLStd450FindILsb(OpGLSLStd450FindILsb),
    GLSLStd450FindSMsb(OpGLSLStd450FindSMsb),
    GLSLStd450FindUMsb(OpGLSLStd450FindUMsb),
    GLSLStd450InterpolateAtCentroid(OpGLSLStd450InterpolateAtCentroid),
    GLSLStd450InterpolateAtSample(OpGLSLStd450InterpolateAtSample),
    GLSLStd450InterpolateAtOffset(OpGLSLStd450InterpolateAtOffset),
    GLSLStd450NMin(OpGLSLStd450NMin),
    GLSLStd450NMax(OpGLSLStd450NMax),
    GLSLStd450NClamp(OpGLSLStd450NClamp),
}
#[derive(Copy, Clone, Debug)]
pub struct Header {
    pub version: (u32, u32),
    pub generator: u32,
    pub bound: u32,
    pub instruction_schema: u32,
}
impl fmt::Display for Header {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "; SPIR-V")?;
        writeln!(f, "; Version: {}.{}", self.version.0, self.version.1)?;
        writeln!(f, "; Generator: {:#X}", self.generator)?;
        writeln!(f, "; Bound: {}", self.bound)?;
        writeln!(f, "; Schema: {}", self.instruction_schema)
    }
}
struct InstructionIndentAndResult(Option<IdResult>);
impl fmt::Display for InstructionIndentAndResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{:>15}",
            self.0.map(|v| format!("{} = ", v.0)).unwrap_or_default()
        )
    }
}
impl fmt::Display for IdRef {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "%{}", self.0)
    }
}
#[derive(Clone, Debug)]
pub enum Error {
    MissingHeader,
    InvalidHeader,
    BoundTooBig(u32),
    UnsupportedVersion(u32, u32),
    ZeroInstructionLength,
    SourcePrematurelyEnded,
    UnknownOpcode(u16),
    UnknownSpecConstantOpcode(u32),
    UnknownExtensionOpcode(ExtensionInstructionSet, u32),
    Utf8Error(Utf8Error),
    InstructionPrematurelyEnded,
    InvalidStringTermination,
    InstructionTooLong,
    InvalidEnumValue,
    IdOutOfBounds(u32),
    IdAlreadyDefined(IdResult),
    UnsupportedFloatSize,
    UnsupportedIntSize,
    UndefinedType(IdRef),
    SwitchSelectorIsInvalid(IdRef),
    IdIsNotExtInstImport(IdRef),
}
impl From<Utf8Error> for Error {
    fn from(v: Utf8Error) -> Self {
        Error::Utf8Error(v)
    }
}
impl From<FromUtf8Error> for Error {
    fn from(v: FromUtf8Error) -> Self {
        Error::Utf8Error(v.utf8_error())
    }
}
impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Error::MissingHeader => write!(f, "SPIR-V source is missing the file header"),
            Error::InvalidHeader => write!(f, "SPIR-V source has an invalid file header"),
            Error::BoundTooBig(bound) => write !
            (f,
             "SPIR-V source has an invalid file header; the id bound is way bigger than needed: {}",
             bound,),
            Error::UnsupportedVersion(major, minor) => write!(
                f,
                "SPIR-V source has an unsupported version: {}.{}",
                major, minor
            ),
            Error::ZeroInstructionLength => write!(f, "SPIR-V instruction has a length of zero"),
            Error::SourcePrematurelyEnded => write!(f, "SPIR-V source prematurely ended"),
            Error::UnknownOpcode(opcode) => {
                write!(f, "SPIR-V instruction has an unknown opcode: {}", opcode)
            }
            Error::UnknownSpecConstantOpcode(opcode) => write!(
                f,
                "SPIR-V OpSpecConstantOp instruction has an unknown opcode: {}",
                opcode
            ),
            Error::UnknownExtensionOpcode(ref extension_instruction_set, opcode) => write!(
                f,
                "SPIR-V OpExtInst instruction has an unknown opcode: {} in {}",
                opcode, extension_instruction_set
            ),
            Error::Utf8Error(error) => fmt::Display::fmt(&error, f),
            Error::InstructionPrematurelyEnded => write!(f, "SPIR-V instruction prematurely ended"),
            Error::InvalidStringTermination => {
                write!(f, "SPIR-V LiteralString has an invalid termination word")
            }
            Error::InstructionTooLong => write!(f, "SPIR-V instruction is too long"),
            Error::InvalidEnumValue => write!(f, "enum has invalid value"),
            Error::IdOutOfBounds(id) => write!(f, "id is out of bounds: {}", id),
            Error::IdAlreadyDefined(id) => write!(f, "id is already defined: {}", id),
            Error::UnsupportedFloatSize => write!(f, "unsupported float size"),
            Error::UnsupportedIntSize => write!(f, "unsupported int size"),
            Error::UndefinedType(id) => write!(f, "undefined type {}", id),
            Error::SwitchSelectorIsInvalid(id) => write!(f, "Switch selector is invalid: {}", id),
            Error::IdIsNotExtInstImport(id) => write!(
                f,
                "id is not the result of an OpExtInstImport instruction: {}",
                id
            ),
        }
    }
}
pub(crate) type Result<T> = result::Result<T, Error>;
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
enum BitWidth {
    Width32OrLess,
    Width64,
}
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
struct IdStateType(BitWidth);
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
struct IdStateValue(BitWidth);
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
enum IdState {
    Unknown,
    Type(IdStateType),
    Value(IdStateValue),
    ExtensionInstructionSet(ExtensionInstructionSet),
}
#[derive(Clone, Debug)]
struct ParseState {
    id_states: Vec<IdState>,
}
impl ParseState {
    fn define_id(&mut self, id_result: IdResult, new_id_state: IdState) -> Result<()> {
        let id_state = &mut self.id_states[(id_result.0).0 as usize];
        if *id_state != IdState::Unknown {
            return Err(Error::IdAlreadyDefined(id_result));
        }
        *id_state = new_id_state;
        Ok(())
    }
    fn get_type(&self, id: IdRef) -> Result<IdStateType> {
        if let IdState::Type(retval) = self.id_states[id.0 as usize] {
            Ok(retval)
        } else {
            Err(Error::UndefinedType(id))
        }
    }
    fn define_value(&mut self, id_result_type: IdResultType, id_result: IdResult) -> Result<()> {
        if let IdState::Type(IdStateType(bit_width)) = self.id_states[(id_result_type.0).0 as usize]
        {
            self.define_id(id_result, IdState::Value(IdStateValue(bit_width)))?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug)]
pub struct Parser<'a> {
    words: &'a [u32],
    header: Header,
    parse_state: ParseState,
}
fn parse_version(v: u32) -> Result<(u32, u32)> {
    if (v & 0xFF0000FF) != 0 {
        return Err(Error::InvalidHeader);
    }
    let major = (v >> 16) & 0xFF;
    let minor = (v >> 8) & 0xFF;
    Ok((major, minor))
}
impl<'a> Parser<'a> {
    pub fn header(&self) -> &Header {
        &self.header
    }
    pub fn start(mut words: &'a [u32]) -> Result<Self> {
        let header = words.get(0..5).ok_or(Error::MissingHeader)?;
        words = &words[5..];
        let header = match *header {
            [MAGIC_NUMBER, version, generator, bound, instruction_schema @ 0] if bound >= 1 => {
                let version = parse_version(version)?;
                if version.0 != MAJOR_VERSION || version.1 > MINOR_VERSION {
                    return Err(Error::UnsupportedVersion(version.0, version.1));
                }
                Header {
                    version,
                    generator,
                    bound,
                    instruction_schema,
                }
            }
            _ => return Err(Error::InvalidHeader),
        };
        if header.bound as usize > words.len() && header.bound > 0x10000 {
            Err(Error::BoundTooBig(header.bound))
        } else {
            Ok(Self {
                words,
                header,
                parse_state: ParseState {
                    id_states: vec![IdState::Unknown; header.bound as usize],
                },
            })
        }
    }
    fn next_helper(&mut self, length_and_opcode: u32) -> Result<Instruction> {
        let length = (length_and_opcode >> 16) as usize;
        let opcode = length_and_opcode as u16;
        if length == 0 {
            return Err(Error::ZeroInstructionLength);
        }
        let instruction_words = self
            .words
            .get(1..length)
            .ok_or(Error::SourcePrematurelyEnded)?;
        self.words = &self.words[length..];
        parse_instruction(opcode, instruction_words, &mut self.parse_state)
    }
}
impl<'a> Iterator for Parser<'a> {
    type Item = Result<Instruction>;
    fn next(&mut self) -> Option<Result<Instruction>> {
        let length_and_opcode = self.words.get(0)?;
        Some(self.next_helper(*length_and_opcode))
    }
}
fn parse_instruction(
    opcode: u16,
    words: &[u32],
    parse_state: &mut ParseState,
) -> Result<Instruction> {
    match opcode {
        0u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Nop(OpNop {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        1u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Undef(OpUndef {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        2u16 => split_fn!({
            let (continued_source, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SourceContinued(OpSourceContinued {
                    continued_source,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        3u16 => split_fn!({
            let (source_language, words) = SourceLanguage::spirv_parse(words, parse_state)?;
            let (version, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (file, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            let (source, words) = Option::<LiteralString>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Source(OpSource {
                    source_language,
                    version,
                    file,
                    source,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        4u16 => split_fn!({
            let (extension, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SourceExtension(OpSourceExtension {
                    extension,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        5u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Name(OpName { target, name }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        6u16 => split_fn!({
            let (type_, words) = IdRef::spirv_parse(words, parse_state)?;
            let (member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemberName(OpMemberName {
                    type_,
                    member,
                    name,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        7u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (string, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::String(OpString { id_result, string }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        8u16 => split_fn!({
            let (file, words) = IdRef::spirv_parse(words, parse_state)?;
            let (line, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (column, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Line(OpLine { file, line, column }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        10u16 => split_fn!({
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Extension(OpExtension { name }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        11u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            parse_state.define_id(
                id_result,
                IdState::ExtensionInstructionSet(ExtensionInstructionSet::from(&*name)),
            )?;
            if words.is_empty() {
                Ok(Instruction::ExtInstImport(OpExtInstImport {
                    id_result,
                    name,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        12u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            let (set, words) = IdRef::spirv_parse(words, parse_state)?;
            let (instruction, words) = LiteralExtInstInteger::spirv_parse(words, parse_state)?;
            let extension_instruction_set;
            match parse_state.id_states[set.0 as usize].clone() {
                IdState::ExtensionInstructionSet(ExtensionInstructionSet::Other(_)) => {
                    let (operands, words) =
                        Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        return Ok(Instruction::ExtInst(OpExtInst {
                            id_result_type,
                            id_result,
                            set,
                            instruction,
                            operands,
                        }));
                    } else {
                        return Err(Error::InstructionTooLong);
                    }
                }
                IdState::ExtensionInstructionSet(v) => {
                    extension_instruction_set = v;
                }
                _ => return Err(Error::IdIsNotExtInstImport(set)),
            };
            match (extension_instruction_set, instruction) {
                (ExtensionInstructionSet::OpenCLStd, 0u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAcos(OpOpenCLStdAcos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 1u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAcosh(OpOpenCLStdAcosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 2u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAcospi(OpOpenCLStdAcospi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 3u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAsin(OpOpenCLStdAsin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 4u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAsinh(OpOpenCLStdAsinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 5u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAsinpi(OpOpenCLStdAsinpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 6u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtan(OpOpenCLStdAtan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 7u32) => split_fn!({
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtan2(OpOpenCLStdAtan2 {
                            id_result_type,
                            id_result,
                            set,
                            y,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 8u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtanh(OpOpenCLStdAtanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 9u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtanpi(OpOpenCLStdAtanpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 10u32) => split_fn!({
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtan2pi(OpOpenCLStdAtan2pi {
                            id_result_type,
                            id_result,
                            set,
                            y,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 11u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCbrt(OpOpenCLStdCbrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 12u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCeil(OpOpenCLStdCeil {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 13u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCopysign(OpOpenCLStdCopysign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 14u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCos(OpOpenCLStdCos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 15u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCosh(OpOpenCLStdCosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 16u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCospi(OpOpenCLStdCospi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 17u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdErfc(OpOpenCLStdErfc {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 18u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdErf(OpOpenCLStdErf {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 19u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExp(OpOpenCLStdExp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 20u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExp2(OpOpenCLStdExp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 21u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExp10(OpOpenCLStdExp10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 22u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExpm1(OpOpenCLStdExpm1 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 23u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFabs(OpOpenCLStdFabs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 24u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFdim(OpOpenCLStdFdim {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 25u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFloor(OpOpenCLStdFloor {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 26u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFma(OpOpenCLStdFma {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 27u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmax(OpOpenCLStdFmax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 28u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmin(OpOpenCLStdFmin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 29u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmod(OpOpenCLStdFmod {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 30u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (ptr, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFract(OpOpenCLStdFract {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            ptr,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 31u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (exp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFrexp(OpOpenCLStdFrexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            exp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 32u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHypot(OpOpenCLStdHypot {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 33u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdIlogb(OpOpenCLStdIlogb {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 34u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (k, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLdexp(OpOpenCLStdLdexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            k,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 35u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLgamma(OpOpenCLStdLgamma {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 36u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (signp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLgammaR(OpOpenCLStdLgammaR {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            signp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 37u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog(OpOpenCLStdLog {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 38u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog2(OpOpenCLStdLog2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 39u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog10(OpOpenCLStdLog10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 40u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog1p(OpOpenCLStdLog1p {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 41u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLogb(OpOpenCLStdLogb {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 42u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMad(OpOpenCLStdMad {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 43u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMaxmag(OpOpenCLStdMaxmag {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 44u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMinmag(OpOpenCLStdMinmag {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 45u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (iptr, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdModf(OpOpenCLStdModf {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            iptr,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 46u32) => split_fn!({
                    let (nancode, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNan(OpOpenCLStdNan {
                            id_result_type,
                            id_result,
                            set,
                            nancode,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 47u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNextafter(OpOpenCLStdNextafter {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 48u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPow(OpOpenCLStdPow {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 49u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPown(OpOpenCLStdPown {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 50u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPowr(OpOpenCLStdPowr {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 51u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRemainder(OpOpenCLStdRemainder {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 52u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (quo, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRemquo(OpOpenCLStdRemquo {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            quo,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 53u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRint(OpOpenCLStdRint {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 54u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRootn(OpOpenCLStdRootn {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 55u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRound(OpOpenCLStdRound {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 56u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRsqrt(OpOpenCLStdRsqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 57u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSin(OpOpenCLStdSin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 58u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (cosval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSincos(OpOpenCLStdSincos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            cosval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 59u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSinh(OpOpenCLStdSinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 60u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSinpi(OpOpenCLStdSinpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 61u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSqrt(OpOpenCLStdSqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 62u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTan(OpOpenCLStdTan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 63u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTanh(OpOpenCLStdTanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 64u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTanpi(OpOpenCLStdTanpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 65u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTgamma(OpOpenCLStdTgamma {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 66u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTrunc(OpOpenCLStdTrunc {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 67u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfCos(OpOpenCLStdHalfCos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 68u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfDivide(OpOpenCLStdHalfDivide {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 69u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfExp(OpOpenCLStdHalfExp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 70u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfExp2(OpOpenCLStdHalfExp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 71u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfExp10(OpOpenCLStdHalfExp10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 72u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfLog(OpOpenCLStdHalfLog {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 73u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfLog2(OpOpenCLStdHalfLog2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 74u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfLog10(OpOpenCLStdHalfLog10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 75u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfPowr(OpOpenCLStdHalfPowr {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 76u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfRecip(OpOpenCLStdHalfRecip {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 77u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfRsqrt(OpOpenCLStdHalfRsqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 78u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfSin(OpOpenCLStdHalfSin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 79u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfSqrt(OpOpenCLStdHalfSqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 80u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfTan(OpOpenCLStdHalfTan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 81u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeCos(OpOpenCLStdNativeCos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 82u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeDivide(
                            OpOpenCLStdNativeDivide {
                                id_result_type,
                                id_result,
                                set,
                                x,
                                y,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 83u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeExp(OpOpenCLStdNativeExp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 84u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeExp2(OpOpenCLStdNativeExp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 85u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeExp10(OpOpenCLStdNativeExp10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 86u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeLog(OpOpenCLStdNativeLog {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 87u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeLog2(OpOpenCLStdNativeLog2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 88u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeLog10(OpOpenCLStdNativeLog10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 89u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativePowr(OpOpenCLStdNativePowr {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 90u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeRecip(OpOpenCLStdNativeRecip {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 91u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeRsqrt(OpOpenCLStdNativeRsqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 92u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeSin(OpOpenCLStdNativeSin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 93u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeSqrt(OpOpenCLStdNativeSqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 94u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeTan(OpOpenCLStdNativeTan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 141u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSAbs(OpOpenCLStdSAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 142u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSAbsDiff(OpOpenCLStdSAbsDiff {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 143u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSAddSat(OpOpenCLStdSAddSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 144u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUAddSat(OpOpenCLStdUAddSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 145u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSHadd(OpOpenCLStdSHadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 146u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUHadd(OpOpenCLStdUHadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 147u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSRhadd(OpOpenCLStdSRhadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 148u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdURhadd(OpOpenCLStdURhadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 149u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (minval, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (maxval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSClamp(OpOpenCLStdSClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            minval,
                            maxval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 150u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (minval, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (maxval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUClamp(OpOpenCLStdUClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            minval,
                            maxval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 151u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdClz(OpOpenCLStdClz {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 152u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCtz(OpOpenCLStdCtz {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 153u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMadHi(OpOpenCLStdSMadHi {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 154u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMadSat(OpOpenCLStdUMadSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 155u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMadSat(OpOpenCLStdSMadSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 156u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMax(OpOpenCLStdSMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 157u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMax(OpOpenCLStdUMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 158u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMin(OpOpenCLStdSMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 159u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMin(OpOpenCLStdUMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 160u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMulHi(OpOpenCLStdSMulHi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 161u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRotate(OpOpenCLStdRotate {
                            id_result_type,
                            id_result,
                            set,
                            v,
                            i,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 162u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSSubSat(OpOpenCLStdSSubSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 163u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUSubSat(OpOpenCLStdUSubSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 164u32) => split_fn!({
                    let (hi, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (lo, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUUpsample(OpOpenCLStdUUpsample {
                            id_result_type,
                            id_result,
                            set,
                            hi,
                            lo,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 165u32) => split_fn!({
                    let (hi, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (lo, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSUpsample(OpOpenCLStdSUpsample {
                            id_result_type,
                            id_result,
                            set,
                            hi,
                            lo,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 166u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPopcount(OpOpenCLStdPopcount {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 167u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMad24(OpOpenCLStdSMad24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 168u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMad24(OpOpenCLStdUMad24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 169u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMul24(OpOpenCLStdSMul24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 170u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMul24(OpOpenCLStdUMul24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 201u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUAbs(OpOpenCLStdUAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 202u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUAbsDiff(OpOpenCLStdUAbsDiff {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 203u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMulHi(OpOpenCLStdUMulHi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 204u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMadHi(OpOpenCLStdUMadHi {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 95u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (minval, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (maxval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFclamp(OpOpenCLStdFclamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            minval,
                            maxval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 96u32) => split_fn!({
                    let (radians, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdDegrees(OpOpenCLStdDegrees {
                            id_result_type,
                            id_result,
                            set,
                            radians,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 97u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmaxCommon(OpOpenCLStdFmaxCommon {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 98u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFminCommon(OpOpenCLStdFminCommon {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 99u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMix(OpOpenCLStdMix {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            a,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 100u32) => split_fn!({
                    let (degrees, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRadians(OpOpenCLStdRadians {
                            id_result_type,
                            id_result,
                            set,
                            degrees,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 101u32) => split_fn!({
                    let (edge, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdStep(OpOpenCLStdStep {
                            id_result_type,
                            id_result,
                            set,
                            edge,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 102u32) => split_fn!({
                    let (edge0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (edge1, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSmoothstep(OpOpenCLStdSmoothstep {
                            id_result_type,
                            id_result,
                            set,
                            edge0,
                            edge1,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 103u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSign(OpOpenCLStdSign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 104u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCross(OpOpenCLStdCross {
                            id_result_type,
                            id_result,
                            set,
                            p0,
                            p1,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 105u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdDistance(OpOpenCLStdDistance {
                            id_result_type,
                            id_result,
                            set,
                            p0,
                            p1,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 106u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLength(OpOpenCLStdLength {
                            id_result_type,
                            id_result,
                            set,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 107u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNormalize(OpOpenCLStdNormalize {
                            id_result_type,
                            id_result,
                            set,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 108u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFastDistance(
                            OpOpenCLStdFastDistance {
                                id_result_type,
                                id_result,
                                set,
                                p0,
                                p1,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 109u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFastLength(OpOpenCLStdFastLength {
                            id_result_type,
                            id_result,
                            set,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 110u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFastNormalize(
                            OpOpenCLStdFastNormalize {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 186u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdBitselect(OpOpenCLStdBitselect {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 187u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSelect(OpOpenCLStdSelect {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 171u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadn(OpOpenCLStdVloadn {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 172u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoren(OpOpenCLStdVstoren {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 173u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadHalf(OpOpenCLStdVloadHalf {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 174u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadHalfn(OpOpenCLStdVloadHalfn {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 175u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalf(OpOpenCLStdVstoreHalf {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 176u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (mode, words) = FPRoundingMode::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalfR(OpOpenCLStdVstoreHalfR {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                            mode,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 177u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalfn(OpOpenCLStdVstoreHalfn {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 178u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (mode, words) = FPRoundingMode::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalfnR(
                            OpOpenCLStdVstoreHalfnR {
                                id_result_type,
                                id_result,
                                set,
                                data,
                                offset,
                                p,
                                mode,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 179u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadaHalfn(OpOpenCLStdVloadaHalfn {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 180u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreaHalfn(
                            OpOpenCLStdVstoreaHalfn {
                                id_result_type,
                                id_result,
                                set,
                                data,
                                offset,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 181u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (mode, words) = FPRoundingMode::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreaHalfnR(
                            OpOpenCLStdVstoreaHalfnR {
                                id_result_type,
                                id_result,
                                set,
                                data,
                                offset,
                                p,
                                mode,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 182u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (shuffle_mask, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdShuffle(OpOpenCLStdShuffle {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            shuffle_mask,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 183u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (shuffle_mask, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdShuffle2(OpOpenCLStdShuffle2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            shuffle_mask,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 184u32) => split_fn!({
                    let (format, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (additional_arguments, words) =
                        Vec::<IdRef>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPrintf(OpOpenCLStdPrintf {
                            id_result_type,
                            id_result,
                            set,
                            format,
                            additional_arguments,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 185u32) => split_fn!({
                    let (ptr, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (num_elements, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPrefetch(OpOpenCLStdPrefetch {
                            id_result_type,
                            id_result,
                            set,
                            ptr,
                            num_elements,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 1u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Round(OpGLSLStd450Round {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 2u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450RoundEven(OpGLSLStd450RoundEven {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 3u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Trunc(OpGLSLStd450Trunc {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 4u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FAbs(OpGLSLStd450FAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 5u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SAbs(OpGLSLStd450SAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 6u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FSign(OpGLSLStd450FSign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 7u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SSign(OpGLSLStd450SSign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 8u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Floor(OpGLSLStd450Floor {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 9u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Ceil(OpGLSLStd450Ceil {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 10u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Fract(OpGLSLStd450Fract {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 11u32) => split_fn!({
                    let (degrees, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Radians(OpGLSLStd450Radians {
                            id_result_type,
                            id_result,
                            set,
                            degrees,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 12u32) => split_fn!({
                    let (radians, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Degrees(OpGLSLStd450Degrees {
                            id_result_type,
                            id_result,
                            set,
                            radians,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 13u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Sin(OpGLSLStd450Sin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 14u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Cos(OpGLSLStd450Cos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 15u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Tan(OpGLSLStd450Tan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 16u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Asin(OpGLSLStd450Asin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 17u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Acos(OpGLSLStd450Acos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 18u32) => split_fn!({
                    let (y_over_x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Atan(OpGLSLStd450Atan {
                            id_result_type,
                            id_result,
                            set,
                            y_over_x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 19u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Sinh(OpGLSLStd450Sinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 20u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Cosh(OpGLSLStd450Cosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 21u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Tanh(OpGLSLStd450Tanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 22u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Asinh(OpGLSLStd450Asinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 23u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Acosh(OpGLSLStd450Acosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 24u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Atanh(OpGLSLStd450Atanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 25u32) => split_fn!({
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Atan2(OpGLSLStd450Atan2 {
                            id_result_type,
                            id_result,
                            set,
                            y,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 26u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Pow(OpGLSLStd450Pow {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 27u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Exp(OpGLSLStd450Exp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 28u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Log(OpGLSLStd450Log {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 29u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Exp2(OpGLSLStd450Exp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 30u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Log2(OpGLSLStd450Log2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 31u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Sqrt(OpGLSLStd450Sqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 32u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InverseSqrt(
                            OpGLSLStd450InverseSqrt {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 33u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Determinant(
                            OpGLSLStd450Determinant {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 34u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450MatrixInverse(
                            OpGLSLStd450MatrixInverse {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 35u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Modf(OpGLSLStd450Modf {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            i,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 36u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450ModfStruct(OpGLSLStd450ModfStruct {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 37u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FMin(OpGLSLStd450FMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 38u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UMin(OpGLSLStd450UMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 39u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SMin(OpGLSLStd450SMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 40u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FMax(OpGLSLStd450FMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 41u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UMax(OpGLSLStd450UMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 42u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SMax(OpGLSLStd450SMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 43u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FClamp(OpGLSLStd450FClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 44u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UClamp(OpGLSLStd450UClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 45u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SClamp(OpGLSLStd450SClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 46u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FMix(OpGLSLStd450FMix {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            a,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 47u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450IMix(OpGLSLStd450IMix {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            a,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 48u32) => split_fn!({
                    let (edge, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Step(OpGLSLStd450Step {
                            id_result_type,
                            id_result,
                            set,
                            edge,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 49u32) => split_fn!({
                    let (edge0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (edge1, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SmoothStep(OpGLSLStd450SmoothStep {
                            id_result_type,
                            id_result,
                            set,
                            edge0,
                            edge1,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 50u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Fma(OpGLSLStd450Fma {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 51u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (exp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Frexp(OpGLSLStd450Frexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            exp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 52u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FrexpStruct(
                            OpGLSLStd450FrexpStruct {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 53u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (exp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Ldexp(OpGLSLStd450Ldexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            exp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 54u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackSnorm4x8(
                            OpGLSLStd450PackSnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 55u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackUnorm4x8(
                            OpGLSLStd450PackUnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 56u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackSnorm2x16(
                            OpGLSLStd450PackSnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 57u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackUnorm2x16(
                            OpGLSLStd450PackUnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 58u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackHalf2x16(
                            OpGLSLStd450PackHalf2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 59u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackDouble2x32(
                            OpGLSLStd450PackDouble2x32 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 60u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackSnorm2x16(
                            OpGLSLStd450UnpackSnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 61u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackUnorm2x16(
                            OpGLSLStd450UnpackUnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 62u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackHalf2x16(
                            OpGLSLStd450UnpackHalf2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 63u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackSnorm4x8(
                            OpGLSLStd450UnpackSnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 64u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackUnorm4x8(
                            OpGLSLStd450UnpackUnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 65u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackDouble2x32(
                            OpGLSLStd450UnpackDouble2x32 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 66u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Length(OpGLSLStd450Length {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 67u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Distance(OpGLSLStd450Distance {
                            id_result_type,
                            id_result,
                            set,
                            p0,
                            p1,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 68u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Cross(OpGLSLStd450Cross {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 69u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Normalize(OpGLSLStd450Normalize {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 70u32) => split_fn!({
                    let (n, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (nref, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FaceForward(
                            OpGLSLStd450FaceForward {
                                id_result_type,
                                id_result,
                                set,
                                n,
                                i,
                                nref,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 71u32) => split_fn!({
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Reflect(OpGLSLStd450Reflect {
                            id_result_type,
                            id_result,
                            set,
                            i,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 72u32) => split_fn!({
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (eta, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Refract(OpGLSLStd450Refract {
                            id_result_type,
                            id_result,
                            set,
                            i,
                            n,
                            eta,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 73u32) => split_fn!({
                    let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FindILsb(OpGLSLStd450FindILsb {
                            id_result_type,
                            id_result,
                            set,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 74u32) => split_fn!({
                    let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FindSMsb(OpGLSLStd450FindSMsb {
                            id_result_type,
                            id_result,
                            set,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 75u32) => split_fn!({
                    let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FindUMsb(OpGLSLStd450FindUMsb {
                            id_result_type,
                            id_result,
                            set,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 76u32) => split_fn!({
                    let (interpolant, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InterpolateAtCentroid(
                            OpGLSLStd450InterpolateAtCentroid {
                                id_result_type,
                                id_result,
                                set,
                                interpolant,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 77u32) => split_fn!({
                    let (interpolant, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (sample, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InterpolateAtSample(
                            OpGLSLStd450InterpolateAtSample {
                                id_result_type,
                                id_result,
                                set,
                                interpolant,
                                sample,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 78u32) => split_fn!({
                    let (interpolant, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InterpolateAtOffset(
                            OpGLSLStd450InterpolateAtOffset {
                                id_result_type,
                                id_result,
                                set,
                                interpolant,
                                offset,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 79u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450NMin(OpGLSLStd450NMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 80u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450NMax(OpGLSLStd450NMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 81u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450NClamp(OpGLSLStd450NClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (extension_instruction_set, instruction) => Err(Error::UnknownExtensionOpcode(
                    extension_instruction_set,
                    instruction,
                )),
            }
        }),
        14u16 => split_fn!({
            let (addressing_model, words) = AddressingModel::spirv_parse(words, parse_state)?;
            let (memory_model, words) = MemoryModel::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemoryModel(OpMemoryModel {
                    addressing_model,
                    memory_model,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        15u16 => split_fn!({
            let (execution_model, words) = ExecutionModel::spirv_parse(words, parse_state)?;
            let (entry_point, words) = IdRef::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            let (interface, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::EntryPoint(OpEntryPoint {
                    execution_model,
                    entry_point,
                    name,
                    interface,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        16u16 => split_fn!({
            let (entry_point, words) = IdRef::spirv_parse(words, parse_state)?;
            let (mode, words) = ExecutionMode::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ExecutionMode(OpExecutionMode {
                    entry_point,
                    mode,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        17u16 => split_fn!({
            let (capability, words) = Capability::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Capability(OpCapability { capability }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        19u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeVoid(OpTypeVoid { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        20u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeBool(OpTypeBool { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        21u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (signedness, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let id_state = match width {
                8 | 16 | 32 => IdState::Type(IdStateType(BitWidth::Width32OrLess)),
                64 => IdState::Type(IdStateType(BitWidth::Width64)),
                _ => return Err(Error::UnsupportedIntSize),
            };
            parse_state.define_id(id_result, id_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeInt(OpTypeInt {
                    id_result,
                    width,
                    signedness,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        22u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let id_state = match width {
                16 | 32 => IdState::Type(IdStateType(BitWidth::Width32OrLess)),
                64 => IdState::Type(IdStateType(BitWidth::Width64)),
                _ => return Err(Error::UnsupportedFloatSize),
            };
            parse_state.define_id(id_result, id_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeFloat(OpTypeFloat { id_result, width }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        23u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (component_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component_count, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeVector(OpTypeVector {
                    id_result,
                    component_type,
                    component_count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        24u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (column_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (column_count, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeMatrix(OpTypeMatrix {
                    id_result,
                    column_type,
                    column_count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        25u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (dim, words) = Dim::spirv_parse(words, parse_state)?;
            let (depth, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (arrayed, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (ms, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (sampled, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (image_format, words) = ImageFormat::spirv_parse(words, parse_state)?;
            let (access_qualifier, words) =
                Option::<AccessQualifier>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeImage(OpTypeImage {
                    id_result,
                    sampled_type,
                    dim,
                    depth,
                    arrayed,
                    ms,
                    sampled,
                    image_format,
                    access_qualifier,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        26u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeSampler(OpTypeSampler { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        27u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image_type, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeSampledImage(OpTypeSampledImage {
                    id_result,
                    image_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        28u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (element_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (length, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeArray(OpTypeArray {
                    id_result,
                    element_type,
                    length,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        29u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (element_type, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeRuntimeArray(OpTypeRuntimeArray {
                    id_result,
                    element_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        30u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (member_types, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeStruct(OpTypeStruct {
                    id_result,
                    member_types,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        31u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (the_name_of_the_opaque_type, words) =
                LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeOpaque(OpTypeOpaque {
                    id_result,
                    the_name_of_the_opaque_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        32u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (storage_class, words) = StorageClass::spirv_parse(words, parse_state)?;
            let (type_, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypePointer(OpTypePointer {
                    id_result,
                    storage_class,
                    type_,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        33u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (return_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (parameter_types, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeFunction(OpTypeFunction {
                    id_result,
                    return_type,
                    parameter_types,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        34u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeEvent(OpTypeEvent { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        35u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeDeviceEvent(OpTypeDeviceEvent {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        36u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeReserveId(OpTypeReserveId { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        37u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeQueue(OpTypeQueue { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        38u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (qualifier, words) = AccessQualifier::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypePipe(OpTypePipe {
                    id_result,
                    qualifier,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        39u16 => split_fn!({
            let (pointer_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (storage_class, words) = StorageClass::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeForwardPointer(OpTypeForwardPointer {
                    pointer_type,
                    storage_class,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        41u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantTrue(OpConstantTrue {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        42u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantFalse(OpConstantFalse {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        43u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            match parse_state.get_type(id_result_type.0)? {
                IdStateType(BitWidth::Width32OrLess) => {
                    let (value, words) =
                        LiteralContextDependentNumber32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Constant32(OpConstant32 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                IdStateType(BitWidth::Width64) => {
                    let (value, words) =
                        LiteralContextDependentNumber64::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Constant64(OpConstant64 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
            }
        }),
        44u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (constituents, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantComposite(OpConstantComposite {
                    id_result_type,
                    id_result,
                    constituents,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        45u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampler_addressing_mode, words) =
                SamplerAddressingMode::spirv_parse(words, parse_state)?;
            let (param, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (sampler_filter_mode, words) = SamplerFilterMode::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantSampler(OpConstantSampler {
                    id_result_type,
                    id_result,
                    sampler_addressing_mode,
                    param,
                    sampler_filter_mode,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        46u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantNull(OpConstantNull {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        48u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantTrue(OpSpecConstantTrue {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        49u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantFalse(OpSpecConstantFalse {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        50u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            match parse_state.get_type(id_result_type.0)? {
                IdStateType(BitWidth::Width32OrLess) => {
                    let (value, words) =
                        LiteralContextDependentNumber32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::SpecConstant32(OpSpecConstant32 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                IdStateType(BitWidth::Width64) => {
                    let (value, words) =
                        LiteralContextDependentNumber64::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::SpecConstant64(OpSpecConstant64 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
            }
        }),
        51u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (constituents, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantComposite(
                    OpSpecConstantComposite {
                        id_result_type,
                        id_result,
                        constituents,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        52u16 => split_fn!({
            let (operation, words) = OpSpecConstantOp::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantOp(operation))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        54u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (function_control, words) = FunctionControl::spirv_parse(words, parse_state)?;
            let (function_type, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Function(OpFunction {
                    id_result_type,
                    id_result,
                    function_control,
                    function_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        55u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FunctionParameter(OpFunctionParameter {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        56u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::FunctionEnd(OpFunctionEnd {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        57u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (function, words) = IdRef::spirv_parse(words, parse_state)?;
            let (arguments, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FunctionCall(OpFunctionCall {
                    id_result_type,
                    id_result,
                    function,
                    arguments,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        59u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (storage_class, words) = StorageClass::spirv_parse(words, parse_state)?;
            let (initializer, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Variable(OpVariable {
                    id_result_type,
                    id_result,
                    storage_class,
                    initializer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        60u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (sample, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageTexelPointer(OpImageTexelPointer {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    sample,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        61u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Load(OpLoad {
                    id_result_type,
                    id_result,
                    pointer,
                    memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        62u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (object, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Store(OpStore {
                    pointer,
                    object,
                    memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        63u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (source, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            let (source_memory_access, words) =
                Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CopyMemory(OpCopyMemory {
                    target,
                    source,
                    memory_access,
                    source_memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        64u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (source, words) = IdRef::spirv_parse(words, parse_state)?;
            let (size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            let (source_memory_access, words) =
                Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CopyMemorySized(OpCopyMemorySized {
                    target,
                    source,
                    size,
                    memory_access,
                    source_memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        65u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AccessChain(OpAccessChain {
                    id_result_type,
                    id_result,
                    base,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        66u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::InBoundsAccessChain(OpInBoundsAccessChain {
                    id_result_type,
                    id_result,
                    base,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        67u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (element, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrAccessChain(OpPtrAccessChain {
                    id_result_type,
                    id_result,
                    base,
                    element,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        68u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (structure, words) = IdRef::spirv_parse(words, parse_state)?;
            let (array_member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ArrayLength(OpArrayLength {
                    id_result_type,
                    id_result,
                    structure,
                    array_member,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        69u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GenericPtrMemSemantics(
                    OpGenericPtrMemSemantics {
                        id_result_type,
                        id_result,
                        pointer,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        70u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (element, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::InBoundsPtrAccessChain(
                    OpInBoundsPtrAccessChain {
                        id_result_type,
                        id_result,
                        base,
                        element,
                        indexes,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        71u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Decorate(OpDecorate { target, decoration }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        72u16 => split_fn!({
            let (structure_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemberDecorate(OpMemberDecorate {
                    structure_type,
                    member,
                    decoration,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        73u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::DecorationGroup(OpDecorationGroup {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        74u16 => split_fn!({
            let (decoration_group, words) = IdRef::spirv_parse(words, parse_state)?;
            let (targets, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupDecorate(OpGroupDecorate {
                    decoration_group,
                    targets,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        75u16 => split_fn!({
            let (decoration_group, words) = IdRef::spirv_parse(words, parse_state)?;
            let (targets, words) = Vec::<PairIdRefLiteralInteger>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupMemberDecorate(OpGroupMemberDecorate {
                    decoration_group,
                    targets,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        77u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorExtractDynamic(OpVectorExtractDynamic {
                    id_result_type,
                    id_result,
                    vector,
                    index,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        78u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorInsertDynamic(OpVectorInsertDynamic {
                    id_result_type,
                    id_result,
                    vector,
                    component,
                    index,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        79u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
            let (components, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorShuffle(OpVectorShuffle {
                    id_result_type,
                    id_result,
                    vector_1,
                    vector_2,
                    components,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        80u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (constituents, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CompositeConstruct(OpCompositeConstruct {
                    id_result_type,
                    id_result,
                    constituents,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        81u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CompositeExtract(OpCompositeExtract {
                    id_result_type,
                    id_result,
                    composite,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        82u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (object, words) = IdRef::spirv_parse(words, parse_state)?;
            let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CompositeInsert(OpCompositeInsert {
                    id_result_type,
                    id_result,
                    object,
                    composite,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        83u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CopyObject(OpCopyObject {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        84u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Transpose(OpTranspose {
                    id_result_type,
                    id_result,
                    matrix,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        86u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (sampler, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SampledImage(OpSampledImage {
                    id_result_type,
                    id_result,
                    image,
                    sampler,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        87u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleImplicitLod(
                    OpImageSampleImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        88u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleExplicitLod(
                    OpImageSampleExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        89u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleDrefImplicitLod(
                    OpImageSampleDrefImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        90u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleDrefExplicitLod(
                    OpImageSampleDrefExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        91u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjImplicitLod(
                    OpImageSampleProjImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        92u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjExplicitLod(
                    OpImageSampleProjExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        93u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjDrefImplicitLod(
                    OpImageSampleProjDrefImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        94u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjDrefExplicitLod(
                    OpImageSampleProjDrefExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        95u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageFetch(OpImageFetch {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        96u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageGather(OpImageGather {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                    component,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        97u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageDrefGather(OpImageDrefGather {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                    d_ref,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        98u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageRead(OpImageRead {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        99u16 => split_fn!({
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (texel, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ImageWrite(OpImageWrite {
                    image,
                    coordinate,
                    texel,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        100u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Image(OpImage {
                    id_result_type,
                    id_result,
                    sampled_image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        101u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryFormat(OpImageQueryFormat {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        102u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryOrder(OpImageQueryOrder {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        103u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (level_of_detail, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQuerySizeLod(OpImageQuerySizeLod {
                    id_result_type,
                    id_result,
                    image,
                    level_of_detail,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        104u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQuerySize(OpImageQuerySize {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        105u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryLod(OpImageQueryLod {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        106u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryLevels(OpImageQueryLevels {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        107u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQuerySamples(OpImageQuerySamples {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        109u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertFToU(OpConvertFToU {
                    id_result_type,
                    id_result,
                    float_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        110u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertFToS(OpConvertFToS {
                    id_result_type,
                    id_result,
                    float_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        111u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertSToF(OpConvertSToF {
                    id_result_type,
                    id_result,
                    signed_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        112u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertUToF(OpConvertUToF {
                    id_result_type,
                    id_result,
                    unsigned_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        113u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UConvert(OpUConvert {
                    id_result_type,
                    id_result,
                    unsigned_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        114u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SConvert(OpSConvert {
                    id_result_type,
                    id_result,
                    signed_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        115u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FConvert(OpFConvert {
                    id_result_type,
                    id_result,
                    float_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        116u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::QuantizeToF16(OpQuantizeToF16 {
                    id_result_type,
                    id_result,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        117u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertPtrToU(OpConvertPtrToU {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        118u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SatConvertSToU(OpSatConvertSToU {
                    id_result_type,
                    id_result,
                    signed_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        119u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SatConvertUToS(OpSatConvertUToS {
                    id_result_type,
                    id_result,
                    unsigned_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        120u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (integer_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertUToPtr(OpConvertUToPtr {
                    id_result_type,
                    id_result,
                    integer_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        121u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrCastToGeneric(OpPtrCastToGeneric {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        122u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GenericCastToPtr(OpGenericCastToPtr {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        123u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (storage, words) = StorageClass::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GenericCastToPtrExplicit(
                    OpGenericCastToPtrExplicit {
                        id_result_type,
                        id_result,
                        pointer,
                        storage,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        124u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Bitcast(OpBitcast {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        126u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SNegate(OpSNegate {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        127u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FNegate(OpFNegate {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        128u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IAdd(OpIAdd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        129u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FAdd(OpFAdd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        130u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ISub(OpISub {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        131u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FSub(OpFSub {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        132u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IMul(OpIMul {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        133u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FMul(OpFMul {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        134u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UDiv(OpUDiv {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        135u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SDiv(OpSDiv {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        136u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FDiv(OpFDiv {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        137u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UMod(OpUMod {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        138u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SRem(OpSRem {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        139u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SMod(OpSMod {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        140u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FRem(OpFRem {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        141u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FMod(OpFMod {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        142u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (scalar, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorTimesScalar(OpVectorTimesScalar {
                    id_result_type,
                    id_result,
                    vector,
                    scalar,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        143u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            let (scalar, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::MatrixTimesScalar(OpMatrixTimesScalar {
                    id_result_type,
                    id_result,
                    matrix,
                    scalar,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        144u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorTimesMatrix(OpVectorTimesMatrix {
                    id_result_type,
                    id_result,
                    vector,
                    matrix,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        145u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::MatrixTimesVector(OpMatrixTimesVector {
                    id_result_type,
                    id_result,
                    matrix,
                    vector,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        146u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (left_matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            let (right_matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::MatrixTimesMatrix(OpMatrixTimesMatrix {
                    id_result_type,
                    id_result,
                    left_matrix,
                    right_matrix,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        147u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::OuterProduct(OpOuterProduct {
                    id_result_type,
                    id_result,
                    vector_1,
                    vector_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        148u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Dot(OpDot {
                    id_result_type,
                    id_result,
                    vector_1,
                    vector_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        149u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IAddCarry(OpIAddCarry {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        150u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ISubBorrow(OpISubBorrow {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        151u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UMulExtended(OpUMulExtended {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        152u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SMulExtended(OpSMulExtended {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        154u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Any(OpAny {
                    id_result_type,
                    id_result,
                    vector,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        155u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::All(OpAll {
                    id_result_type,
                    id_result,
                    vector,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        156u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsNan(OpIsNan {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        157u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsInf(OpIsInf {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        158u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsFinite(OpIsFinite {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        159u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsNormal(OpIsNormal {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        160u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SignBitSet(OpSignBitSet {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        161u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            let (y, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LessOrGreater(OpLessOrGreater {
                    id_result_type,
                    id_result,
                    x,
                    y,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        162u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            let (y, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Ordered(OpOrdered {
                    id_result_type,
                    id_result,
                    x,
                    y,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        163u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            let (y, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Unordered(OpUnordered {
                    id_result_type,
                    id_result,
                    x,
                    y,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        164u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalEqual(OpLogicalEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        165u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalNotEqual(OpLogicalNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        166u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalOr(OpLogicalOr {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        167u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalAnd(OpLogicalAnd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        168u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalNot(OpLogicalNot {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        169u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (condition, words) = IdRef::spirv_parse(words, parse_state)?;
            let (object_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (object_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Select(OpSelect {
                    id_result_type,
                    id_result,
                    condition,
                    object_1,
                    object_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        170u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IEqual(OpIEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        171u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::INotEqual(OpINotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        172u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UGreaterThan(OpUGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        173u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SGreaterThan(OpSGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        174u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UGreaterThanEqual(OpUGreaterThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        175u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SGreaterThanEqual(OpSGreaterThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        176u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ULessThan(OpULessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        177u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SLessThan(OpSLessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        178u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ULessThanEqual(OpULessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        179u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SLessThanEqual(OpSLessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        180u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdEqual(OpFOrdEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        181u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordEqual(OpFUnordEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        182u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdNotEqual(OpFOrdNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        183u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordNotEqual(OpFUnordNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        184u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdLessThan(OpFOrdLessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        185u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordLessThan(OpFUnordLessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        186u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdGreaterThan(OpFOrdGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        187u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordGreaterThan(OpFUnordGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        188u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdLessThanEqual(OpFOrdLessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        189u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordLessThanEqual(OpFUnordLessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        190u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdGreaterThanEqual(OpFOrdGreaterThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        191u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordGreaterThanEqual(
                    OpFUnordGreaterThanEqual {
                        id_result_type,
                        id_result,
                        operand_1,
                        operand_2,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        194u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ShiftRightLogical(OpShiftRightLogical {
                    id_result_type,
                    id_result,
                    base,
                    shift,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        195u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ShiftRightArithmetic(OpShiftRightArithmetic {
                    id_result_type,
                    id_result,
                    base,
                    shift,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        196u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ShiftLeftLogical(OpShiftLeftLogical {
                    id_result_type,
                    id_result,
                    base,
                    shift,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        197u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitwiseOr(OpBitwiseOr {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        198u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitwiseXor(OpBitwiseXor {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        199u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitwiseAnd(OpBitwiseAnd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        200u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Not(OpNot {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        201u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (insert, words) = IdRef::spirv_parse(words, parse_state)?;
            let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
            let (count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitFieldInsert(OpBitFieldInsert {
                    id_result_type,
                    id_result,
                    base,
                    insert,
                    offset,
                    count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        202u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
            let (count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitFieldSExtract(OpBitFieldSExtract {
                    id_result_type,
                    id_result,
                    base,
                    offset,
                    count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        203u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
            let (count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitFieldUExtract(OpBitFieldUExtract {
                    id_result_type,
                    id_result,
                    base,
                    offset,
                    count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        204u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitReverse(OpBitReverse {
                    id_result_type,
                    id_result,
                    base,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        205u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitCount(OpBitCount {
                    id_result_type,
                    id_result,
                    base,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        207u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdx(OpDPdx {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        208u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdy(OpDPdy {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        209u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Fwidth(OpFwidth {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        210u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdxFine(OpDPdxFine {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        211u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdyFine(OpDPdyFine {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        212u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FwidthFine(OpFwidthFine {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        213u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdxCoarse(OpDPdxCoarse {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        214u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdyCoarse(OpDPdyCoarse {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        215u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FwidthCoarse(OpFwidthCoarse {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        218u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::EmitVertex(OpEmitVertex {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        219u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::EndPrimitive(OpEndPrimitive {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        220u16 => split_fn!({
            let (stream, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::EmitStreamVertex(OpEmitStreamVertex { stream }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        221u16 => split_fn!({
            let (stream, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::EndStreamPrimitive(OpEndStreamPrimitive {
                    stream,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        224u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ControlBarrier(OpControlBarrier {
                    execution,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        225u16 => split_fn!({
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemoryBarrier(OpMemoryBarrier {
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        227u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicLoad(OpAtomicLoad {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        228u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::AtomicStore(OpAtomicStore {
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        229u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicExchange(OpAtomicExchange {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        230u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (equal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (unequal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (comparator, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicCompareExchange(
                    OpAtomicCompareExchange {
                        id_result_type,
                        id_result,
                        pointer,
                        memory,
                        equal,
                        unequal,
                        value,
                        comparator,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        231u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (equal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (unequal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (comparator, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicCompareExchangeWeak(
                    OpAtomicCompareExchangeWeak {
                        id_result_type,
                        id_result,
                        pointer,
                        memory,
                        equal,
                        unequal,
                        value,
                        comparator,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        232u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicIIncrement(OpAtomicIIncrement {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        233u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicIDecrement(OpAtomicIDecrement {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        234u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicIAdd(OpAtomicIAdd {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        235u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicISub(OpAtomicISub {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        236u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicSMin(OpAtomicSMin {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        237u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicUMin(OpAtomicUMin {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        238u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicSMax(OpAtomicSMax {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        239u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicUMax(OpAtomicUMax {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        240u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicAnd(OpAtomicAnd {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        241u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicOr(OpAtomicOr {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        242u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicXor(OpAtomicXor {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        245u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (variable_parent, words) = Vec::<PairIdRefIdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Phi(OpPhi {
                    id_result_type,
                    id_result,
                    variable_parent,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        246u16 => split_fn!({
            let (merge_block, words) = IdRef::spirv_parse(words, parse_state)?;
            let (continue_target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (loop_control, words) = LoopControl::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::LoopMerge(OpLoopMerge {
                    merge_block,
                    continue_target,
                    loop_control,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        247u16 => split_fn!({
            let (merge_block, words) = IdRef::spirv_parse(words, parse_state)?;
            let (selection_control, words) = SelectionControl::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SelectionMerge(OpSelectionMerge {
                    merge_block,
                    selection_control,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        248u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Label(OpLabel { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        249u16 => split_fn!({
            let (target_label, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Branch(OpBranch { target_label }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        250u16 => split_fn!({
            let (condition, words) = IdRef::spirv_parse(words, parse_state)?;
            let (true_label, words) = IdRef::spirv_parse(words, parse_state)?;
            let (false_label, words) = IdRef::spirv_parse(words, parse_state)?;
            let (branch_weights, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::BranchConditional(OpBranchConditional {
                    condition,
                    true_label,
                    false_label,
                    branch_weights,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        251u16 => split_fn!({
            let (selector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (default, words) = IdRef::spirv_parse(words, parse_state)?;
            match &parse_state.id_states[selector.0 as usize] {
                IdState::Value(IdStateValue(BitWidth::Width32OrLess)) => {
                    let (target, words) =
                        Vec::<PairLiteralInteger32IdRef>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Switch32(OpSwitch32 {
                            selector,
                            default,
                            target,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                IdState::Value(IdStateValue(BitWidth::Width64)) => {
                    let (target, words) =
                        Vec::<PairLiteralInteger64IdRef>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Switch64(OpSwitch64 {
                            selector,
                            default,
                            target,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                _ => Err(Error::SwitchSelectorIsInvalid(selector)),
            }
        }),
        252u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Kill(OpKill {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        253u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Return(OpReturn {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        254u16 => split_fn!({
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ReturnValue(OpReturnValue { value }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        255u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Unreachable(OpUnreachable {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        256u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::LifetimeStart(OpLifetimeStart {
                    pointer,
                    size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        257u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::LifetimeStop(OpLifetimeStop { pointer, size }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        259u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (destination, words) = IdRef::spirv_parse(words, parse_state)?;
            let (source, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_elements, words) = IdRef::spirv_parse(words, parse_state)?;
            let (stride, words) = IdRef::spirv_parse(words, parse_state)?;
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupAsyncCopy(OpGroupAsyncCopy {
                    id_result_type,
                    id_result,
                    execution,
                    destination,
                    source,
                    num_elements,
                    stride,
                    event,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        260u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (num_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (events_list, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupWaitEvents(OpGroupWaitEvents {
                    execution,
                    num_events,
                    events_list,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        261u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupAll(OpGroupAll {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        262u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupAny(OpGroupAny {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        263u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (local_id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupBroadcast(OpGroupBroadcast {
                    id_result_type,
                    id_result,
                    execution,
                    value,
                    local_id,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        264u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupIAdd(OpGroupIAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        265u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupFAdd(OpGroupFAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        266u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupFMin(OpGroupFMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        267u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupUMin(OpGroupUMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        268u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupSMin(OpGroupSMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        269u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupFMax(OpGroupFMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        270u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupUMax(OpGroupUMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        271u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupSMax(OpGroupSMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        274u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReadPipe(OpReadPipe {
                    id_result_type,
                    id_result,
                    pipe,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        275u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::WritePipe(OpWritePipe {
                    id_result_type,
                    id_result,
                    pipe,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        276u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReservedReadPipe(OpReservedReadPipe {
                    id_result_type,
                    id_result,
                    pipe,
                    reserve_id,
                    index,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        277u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReservedWritePipe(OpReservedWritePipe {
                    id_result_type,
                    id_result,
                    pipe,
                    reserve_id,
                    index,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        278u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReserveReadPipePackets(
                    OpReserveReadPipePackets {
                        id_result_type,
                        id_result,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        279u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReserveWritePipePackets(
                    OpReserveWritePipePackets {
                        id_result_type,
                        id_result,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        280u16 => split_fn!({
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CommitReadPipe(OpCommitReadPipe {
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        281u16 => split_fn!({
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CommitWritePipe(OpCommitWritePipe {
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        282u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsValidReserveId(OpIsValidReserveId {
                    id_result_type,
                    id_result,
                    reserve_id,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        283u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetNumPipePackets(OpGetNumPipePackets {
                    id_result_type,
                    id_result,
                    pipe,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        284u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetMaxPipePackets(OpGetMaxPipePackets {
                    id_result_type,
                    id_result,
                    pipe,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        285u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupReserveReadPipePackets(
                    OpGroupReserveReadPipePackets {
                        id_result_type,
                        id_result,
                        execution,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        286u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupReserveWritePipePackets(
                    OpGroupReserveWritePipePackets {
                        id_result_type,
                        id_result,
                        execution,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        287u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupCommitReadPipe(OpGroupCommitReadPipe {
                    execution,
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        288u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupCommitWritePipe(OpGroupCommitWritePipe {
                    execution,
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        291u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (queue, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (wait_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (ret_event, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::EnqueueMarker(OpEnqueueMarker {
                    id_result_type,
                    id_result,
                    queue,
                    num_events,
                    wait_events,
                    ret_event,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        292u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (queue, words) = IdRef::spirv_parse(words, parse_state)?;
            let (flags, words) = IdRef::spirv_parse(words, parse_state)?;
            let (nd_range, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (wait_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (ret_event, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            let (local_size, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::EnqueueKernel(OpEnqueueKernel {
                    id_result_type,
                    id_result,
                    queue,
                    flags,
                    nd_range,
                    num_events,
                    wait_events,
                    ret_event,
                    invoke,
                    param,
                    param_size,
                    param_align,
                    local_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        293u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (nd_range, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelNDrangeSubGroupCount(
                    OpGetKernelNDrangeSubGroupCount {
                        id_result_type,
                        id_result,
                        nd_range,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        294u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (nd_range, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelNDrangeMaxSubGroupSize(
                    OpGetKernelNDrangeMaxSubGroupSize {
                        id_result_type,
                        id_result,
                        nd_range,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        295u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelWorkGroupSize(
                    OpGetKernelWorkGroupSize {
                        id_result_type,
                        id_result,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        296u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelPreferredWorkGroupSizeMultiple(
                    OpGetKernelPreferredWorkGroupSizeMultiple {
                        id_result_type,
                        id_result,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        297u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::RetainEvent(OpRetainEvent { event }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        298u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ReleaseEvent(OpReleaseEvent { event }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        299u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CreateUserEvent(OpCreateUserEvent {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        300u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsValidEvent(OpIsValidEvent {
                    id_result_type,
                    id_result,
                    event,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        301u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            let (status, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SetUserEventStatus(OpSetUserEventStatus {
                    event,
                    status,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        302u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            let (profiling_info, words) = IdRef::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CaptureEventProfilingInfo(
                    OpCaptureEventProfilingInfo {
                        event,
                        profiling_info,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        303u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetDefaultQueue(OpGetDefaultQueue {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        304u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (global_work_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (local_work_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (global_work_offset, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BuildNDRange(OpBuildNDRange {
                    id_result_type,
                    id_result,
                    global_work_size,
                    local_work_size,
                    global_work_offset,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        305u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleImplicitLod(
                    OpImageSparseSampleImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        306u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleExplicitLod(
                    OpImageSparseSampleExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        307u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleDrefImplicitLod(
                    OpImageSparseSampleDrefImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        308u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleDrefExplicitLod(
                    OpImageSparseSampleDrefExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        313u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseFetch(OpImageSparseFetch {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        314u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseGather(OpImageSparseGather {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                    component,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        315u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseDrefGather(
                    OpImageSparseDrefGather {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        316u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (resident_code, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseTexelsResident(
                    OpImageSparseTexelsResident {
                        id_result_type,
                        id_result,
                        resident_code,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        317u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::NoLine(OpNoLine {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        318u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicFlagTestAndSet(OpAtomicFlagTestAndSet {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        319u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::AtomicFlagClear(OpAtomicFlagClear {
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        320u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseRead(OpImageSparseRead {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        321u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SizeOf(OpSizeOf {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        322u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypePipeStorage(OpTypePipeStorage {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        323u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (packet_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (capacity, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantPipeStorage(OpConstantPipeStorage {
                    id_result_type,
                    id_result,
                    packet_size,
                    packet_alignment,
                    capacity,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        324u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe_storage, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CreatePipeFromPipeStorage(
                    OpCreatePipeFromPipeStorage {
                        id_result_type,
                        id_result,
                        pipe_storage,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        325u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (subgroup_count, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelLocalSizeForSubgroupCount(
                    OpGetKernelLocalSizeForSubgroupCount {
                        id_result_type,
                        id_result,
                        subgroup_count,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        326u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelMaxNumSubgroups(
                    OpGetKernelMaxNumSubgroups {
                        id_result_type,
                        id_result,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        327u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeNamedBarrier(OpTypeNamedBarrier {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        328u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (subgroup_count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::NamedBarrierInitialize(
                    OpNamedBarrierInitialize {
                        id_result_type,
                        id_result,
                        subgroup_count,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        329u16 => split_fn!({
            let (named_barrier, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemoryNamedBarrier(OpMemoryNamedBarrier {
                    named_barrier,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        330u16 => split_fn!({
            let (process, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ModuleProcessed(OpModuleProcessed { process }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        331u16 => split_fn!({
            let (entry_point, words) = IdRef::spirv_parse(words, parse_state)?;
            let (mode, words) = ExecutionMode::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ExecutionModeId(OpExecutionModeId {
                    entry_point,
                    mode,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        332u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::DecorateId(OpDecorateId { target, decoration }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        333u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformElect(OpGroupNonUniformElect {
                    id_result_type,
                    id_result,
                    execution,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        334u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformAll(OpGroupNonUniformAll {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        335u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformAny(OpGroupNonUniformAny {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        336u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformAllEqual(
                    OpGroupNonUniformAllEqual {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        337u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBroadcast(
                    OpGroupNonUniformBroadcast {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        id,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        338u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBroadcastFirst(
                    OpGroupNonUniformBroadcastFirst {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        339u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallot(
                    OpGroupNonUniformBallot {
                        id_result_type,
                        id_result,
                        execution,
                        predicate,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        340u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformInverseBallot(
                    OpGroupNonUniformInverseBallot {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        341u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotBitExtract(
                    OpGroupNonUniformBallotBitExtract {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        index,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        342u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotBitCount(
                    OpGroupNonUniformBallotBitCount {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        343u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotFindLSB(
                    OpGroupNonUniformBallotFindLSB {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        344u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotFindMSB(
                    OpGroupNonUniformBallotFindMSB {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        345u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffle(
                    OpGroupNonUniformShuffle {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        id,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        346u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (mask, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffleXor(
                    OpGroupNonUniformShuffleXor {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        mask,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        347u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (delta, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffleUp(
                    OpGroupNonUniformShuffleUp {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        delta,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        348u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (delta, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffleDown(
                    OpGroupNonUniformShuffleDown {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        delta,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        349u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformIAdd(OpGroupNonUniformIAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        350u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFAdd(OpGroupNonUniformFAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        351u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformIMul(OpGroupNonUniformIMul {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        352u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFMul(OpGroupNonUniformFMul {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        353u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformSMin(OpGroupNonUniformSMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        354u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformUMin(OpGroupNonUniformUMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        355u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFMin(OpGroupNonUniformFMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        356u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformSMax(OpGroupNonUniformSMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        357u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformUMax(OpGroupNonUniformUMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        358u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFMax(OpGroupNonUniformFMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        359u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBitwiseAnd(
                    OpGroupNonUniformBitwiseAnd {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        360u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBitwiseOr(
                    OpGroupNonUniformBitwiseOr {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        361u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBitwiseXor(
                    OpGroupNonUniformBitwiseXor {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        362u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformLogicalAnd(
                    OpGroupNonUniformLogicalAnd {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        363u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformLogicalOr(
                    OpGroupNonUniformLogicalOr {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        364u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformLogicalXor(
                    OpGroupNonUniformLogicalXor {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        365u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformQuadBroadcast(
                    OpGroupNonUniformQuadBroadcast {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        index,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        366u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (direction, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformQuadSwap(
                    OpGroupNonUniformQuadSwap {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        direction,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        400u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CopyLogical(OpCopyLogical {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        401u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrEqual(OpPtrEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        402u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrNotEqual(OpPtrNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        403u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrDiff(OpPtrDiff {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        5632u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::DecorateString(OpDecorateString {
                    target,
                    decoration,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        5633u16 => split_fn!({
            let (struct_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemberDecorateString(OpMemberDecorateString {
                    struct_type,
                    member,
                    decoration,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        opcode => Err(Error::UnknownOpcode(opcode)),
    }
}
impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Instruction::Nop(OpNop {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpNop")?;
                writeln!(f)
            }),
            Instruction::Undef(OpUndef {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUndef"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SourceContinued(OpSourceContinued { continued_source }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSourceContinued"
                )?;
                continued_source.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Source(OpSource {
                source_language,
                version,
                file,
                source,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpSource")?;
                source_language.spirv_display(f)?;
                version.spirv_display(f)?;
                file.spirv_display(f)?;
                source.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SourceExtension(OpSourceExtension { extension }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSourceExtension"
                )?;
                extension.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Name(OpName { target, name }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpName")?;
                target.spirv_display(f)?;
                name.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemberName(OpMemberName {
                type_,
                member,
                name,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpMemberName")?;
                type_.spirv_display(f)?;
                member.spirv_display(f)?;
                name.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::String(OpString { id_result, string }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpString"
                )?;
                string.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Line(OpLine { file, line, column }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpLine")?;
                file.spirv_display(f)?;
                line.spirv_display(f)?;
                column.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Extension(OpExtension { name }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpExtension")?;
                name.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ExtInstImport(OpExtInstImport { id_result, name }) => split_fn!({
                writeln!(
                    f,
                    "{}{} {:?}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpExtInstImport",
                    name
                )
            }),
            Instruction::ExtInst(OpExtInst {
                id_result_type,
                id_result,
                set,
                instruction,
                operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpExtInst"
                )?;
                id_result_type.spirv_display(f)?;
                set.spirv_display(f)?;
                instruction.spirv_display(f)?;
                operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemoryModel(OpMemoryModel {
                addressing_model,
                memory_model,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpMemoryModel")?;
                addressing_model.spirv_display(f)?;
                memory_model.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EntryPoint(OpEntryPoint {
                execution_model,
                entry_point,
                name,
                interface,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpEntryPoint")?;
                execution_model.spirv_display(f)?;
                entry_point.spirv_display(f)?;
                name.spirv_display(f)?;
                interface.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ExecutionMode(OpExecutionMode { entry_point, mode }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpExecutionMode"
                )?;
                entry_point.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Capability(OpCapability { capability }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpCapability")?;
                capability.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeVoid(OpTypeVoid { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeVoid"
                )?;
                writeln!(f)
            }),
            Instruction::TypeBool(OpTypeBool { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeBool"
                )?;
                writeln!(f)
            }),
            Instruction::TypeInt(OpTypeInt {
                id_result,
                width,
                signedness,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeInt"
                )?;
                width.spirv_display(f)?;
                signedness.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeFloat(OpTypeFloat { id_result, width }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeFloat"
                )?;
                width.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeVector(OpTypeVector {
                id_result,
                component_type,
                component_count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeVector"
                )?;
                component_type.spirv_display(f)?;
                component_count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeMatrix(OpTypeMatrix {
                id_result,
                column_type,
                column_count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeMatrix"
                )?;
                column_type.spirv_display(f)?;
                column_count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeImage(OpTypeImage {
                id_result,
                sampled_type,
                dim,
                depth,
                arrayed,
                ms,
                sampled,
                image_format,
                access_qualifier,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeImage"
                )?;
                sampled_type.spirv_display(f)?;
                dim.spirv_display(f)?;
                depth.spirv_display(f)?;
                arrayed.spirv_display(f)?;
                ms.spirv_display(f)?;
                sampled.spirv_display(f)?;
                image_format.spirv_display(f)?;
                access_qualifier.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeSampler(OpTypeSampler { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeSampler"
                )?;
                writeln!(f)
            }),
            Instruction::TypeSampledImage(OpTypeSampledImage {
                id_result,
                image_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeSampledImage"
                )?;
                image_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeArray(OpTypeArray {
                id_result,
                element_type,
                length,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeArray"
                )?;
                element_type.spirv_display(f)?;
                length.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeRuntimeArray(OpTypeRuntimeArray {
                id_result,
                element_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeRuntimeArray"
                )?;
                element_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeStruct(OpTypeStruct {
                id_result,
                member_types,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeStruct"
                )?;
                member_types.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeOpaque(OpTypeOpaque {
                id_result,
                the_name_of_the_opaque_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeOpaque"
                )?;
                the_name_of_the_opaque_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypePointer(OpTypePointer {
                id_result,
                storage_class,
                type_,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypePointer"
                )?;
                storage_class.spirv_display(f)?;
                type_.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeFunction(OpTypeFunction {
                id_result,
                return_type,
                parameter_types,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeFunction"
                )?;
                return_type.spirv_display(f)?;
                parameter_types.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeEvent(OpTypeEvent { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeEvent"
                )?;
                writeln!(f)
            }),
            Instruction::TypeDeviceEvent(OpTypeDeviceEvent { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeDeviceEvent"
                )?;
                writeln!(f)
            }),
            Instruction::TypeReserveId(OpTypeReserveId { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeReserveId"
                )?;
                writeln!(f)
            }),
            Instruction::TypeQueue(OpTypeQueue { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeQueue"
                )?;
                writeln!(f)
            }),
            Instruction::TypePipe(OpTypePipe {
                id_result,
                qualifier,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypePipe"
                )?;
                qualifier.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeForwardPointer(OpTypeForwardPointer {
                pointer_type,
                storage_class,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpTypeForwardPointer"
                )?;
                pointer_type.spirv_display(f)?;
                storage_class.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantTrue(OpConstantTrue {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantTrue"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantFalse(OpConstantFalse {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantFalse"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Constant32(OpConstant32 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#010X}", value)
            }),
            Instruction::Constant64(OpConstant64 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#018X}", value)
            }),
            Instruction::ConstantComposite(OpConstantComposite {
                id_result_type,
                id_result,
                constituents,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantComposite"
                )?;
                id_result_type.spirv_display(f)?;
                constituents.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantSampler(OpConstantSampler {
                id_result_type,
                id_result,
                sampler_addressing_mode,
                param,
                sampler_filter_mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantSampler"
                )?;
                id_result_type.spirv_display(f)?;
                sampler_addressing_mode.spirv_display(f)?;
                param.spirv_display(f)?;
                sampler_filter_mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantNull(OpConstantNull {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantNull"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstantTrue(OpSpecConstantTrue {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantTrue"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstantFalse(OpSpecConstantFalse {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantFalse"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstant32(OpSpecConstant32 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#010X}", value)
            }),
            Instruction::SpecConstant64(OpSpecConstant64 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#018X}", value)
            }),
            Instruction::SpecConstantComposite(OpSpecConstantComposite {
                id_result_type,
                id_result,
                constituents,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantComposite"
                )?;
                id_result_type.spirv_display(f)?;
                constituents.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstantOp(operation) => fmt::Display::fmt(operation, f),
            Instruction::Function(OpFunction {
                id_result_type,
                id_result,
                function_control,
                function_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFunction"
                )?;
                id_result_type.spirv_display(f)?;
                function_control.spirv_display(f)?;
                function_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FunctionParameter(OpFunctionParameter {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFunctionParameter"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FunctionEnd(OpFunctionEnd {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpFunctionEnd")?;
                writeln!(f)
            }),
            Instruction::FunctionCall(OpFunctionCall {
                id_result_type,
                id_result,
                function,
                arguments,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFunctionCall"
                )?;
                id_result_type.spirv_display(f)?;
                function.spirv_display(f)?;
                arguments.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Variable(OpVariable {
                id_result_type,
                id_result,
                storage_class,
                initializer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVariable"
                )?;
                id_result_type.spirv_display(f)?;
                storage_class.spirv_display(f)?;
                initializer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageTexelPointer(OpImageTexelPointer {
                id_result_type,
                id_result,
                image,
                coordinate,
                sample,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageTexelPointer"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                sample.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Load(OpLoad {
                id_result_type,
                id_result,
                pointer,
                memory_access,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLoad"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Store(OpStore {
                pointer,
                object,
                memory_access,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpStore")?;
                pointer.spirv_display(f)?;
                object.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyMemory(OpCopyMemory {
                target,
                source,
                memory_access,
                source_memory_access,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpCopyMemory")?;
                target.spirv_display(f)?;
                source.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                source_memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyMemorySized(OpCopyMemorySized {
                target,
                source,
                size,
                memory_access,
                source_memory_access,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCopyMemorySized"
                )?;
                target.spirv_display(f)?;
                source.spirv_display(f)?;
                size.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                source_memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AccessChain(OpAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::InBoundsAccessChain(OpInBoundsAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpInBoundsAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrAccessChain(OpPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ArrayLength(OpArrayLength {
                id_result_type,
                id_result,
                structure,
                array_member,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpArrayLength"
                )?;
                id_result_type.spirv_display(f)?;
                structure.spirv_display(f)?;
                array_member.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GenericPtrMemSemantics(OpGenericPtrMemSemantics {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGenericPtrMemSemantics"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::InBoundsPtrAccessChain(OpInBoundsPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpInBoundsPtrAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Decorate(OpDecorate { target, decoration }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpDecorate")?;
                target.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemberDecorate(OpMemberDecorate {
                structure_type,
                member,
                decoration,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemberDecorate"
                )?;
                structure_type.spirv_display(f)?;
                member.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DecorationGroup(OpDecorationGroup { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDecorationGroup"
                )?;
                writeln!(f)
            }),
            Instruction::GroupDecorate(OpGroupDecorate {
                decoration_group,
                targets,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupDecorate"
                )?;
                decoration_group.spirv_display(f)?;
                targets.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupMemberDecorate(OpGroupMemberDecorate {
                decoration_group,
                targets,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupMemberDecorate"
                )?;
                decoration_group.spirv_display(f)?;
                targets.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorExtractDynamic(OpVectorExtractDynamic {
                id_result_type,
                id_result,
                vector,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorExtractDynamic"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorInsertDynamic(OpVectorInsertDynamic {
                id_result_type,
                id_result,
                vector,
                component,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorInsertDynamic"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                component.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorShuffle(OpVectorShuffle {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
                components,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorShuffle"
                )?;
                id_result_type.spirv_display(f)?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                components.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CompositeConstruct(OpCompositeConstruct {
                id_result_type,
                id_result,
                constituents,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCompositeConstruct"
                )?;
                id_result_type.spirv_display(f)?;
                constituents.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CompositeExtract(OpCompositeExtract {
                id_result_type,
                id_result,
                composite,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCompositeExtract"
                )?;
                id_result_type.spirv_display(f)?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CompositeInsert(OpCompositeInsert {
                id_result_type,
                id_result,
                object,
                composite,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCompositeInsert"
                )?;
                id_result_type.spirv_display(f)?;
                object.spirv_display(f)?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyObject(OpCopyObject {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCopyObject"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Transpose(OpTranspose {
                id_result_type,
                id_result,
                matrix,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTranspose"
                )?;
                id_result_type.spirv_display(f)?;
                matrix.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SampledImage(OpSampledImage {
                id_result_type,
                id_result,
                image,
                sampler,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSampledImage"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                sampler.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleImplicitLod(OpImageSampleImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleExplicitLod(OpImageSampleExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleDrefImplicitLod(OpImageSampleDrefImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleDrefImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleDrefExplicitLod(OpImageSampleDrefExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleDrefExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjImplicitLod(OpImageSampleProjImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjExplicitLod(OpImageSampleProjExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjDrefImplicitLod(OpImageSampleProjDrefImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjDrefImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjDrefExplicitLod(OpImageSampleProjDrefExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjDrefExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageFetch(OpImageFetch {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageFetch"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageGather(OpImageGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                component,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                component.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageDrefGather(OpImageDrefGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageDrefGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageRead(OpImageRead {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageRead"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageWrite(OpImageWrite {
                image,
                coordinate,
                texel,
                image_operands,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpImageWrite")?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                texel.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Image(OpImage {
                id_result_type,
                id_result,
                sampled_image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImage"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryFormat(OpImageQueryFormat {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryFormat"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryOrder(OpImageQueryOrder {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryOrder"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQuerySizeLod(OpImageQuerySizeLod {
                id_result_type,
                id_result,
                image,
                level_of_detail,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQuerySizeLod"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                level_of_detail.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQuerySize(OpImageQuerySize {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQuerySize"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryLod(OpImageQueryLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryLevels(OpImageQueryLevels {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryLevels"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQuerySamples(OpImageQuerySamples {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQuerySamples"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertFToU(OpConvertFToU {
                id_result_type,
                id_result,
                float_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertFToU"
                )?;
                id_result_type.spirv_display(f)?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertFToS(OpConvertFToS {
                id_result_type,
                id_result,
                float_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertFToS"
                )?;
                id_result_type.spirv_display(f)?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertSToF(OpConvertSToF {
                id_result_type,
                id_result,
                signed_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertSToF"
                )?;
                id_result_type.spirv_display(f)?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertUToF(OpConvertUToF {
                id_result_type,
                id_result,
                unsigned_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertUToF"
                )?;
                id_result_type.spirv_display(f)?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UConvert(OpUConvert {
                id_result_type,
                id_result,
                unsigned_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUConvert"
                )?;
                id_result_type.spirv_display(f)?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SConvert(OpSConvert {
                id_result_type,
                id_result,
                signed_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSConvert"
                )?;
                id_result_type.spirv_display(f)?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FConvert(OpFConvert {
                id_result_type,
                id_result,
                float_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFConvert"
                )?;
                id_result_type.spirv_display(f)?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::QuantizeToF16(OpQuantizeToF16 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpQuantizeToF16"
                )?;
                id_result_type.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertPtrToU(OpConvertPtrToU {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertPtrToU"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SatConvertSToU(OpSatConvertSToU {
                id_result_type,
                id_result,
                signed_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSatConvertSToU"
                )?;
                id_result_type.spirv_display(f)?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SatConvertUToS(OpSatConvertUToS {
                id_result_type,
                id_result,
                unsigned_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSatConvertUToS"
                )?;
                id_result_type.spirv_display(f)?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertUToPtr(OpConvertUToPtr {
                id_result_type,
                id_result,
                integer_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertUToPtr"
                )?;
                id_result_type.spirv_display(f)?;
                integer_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrCastToGeneric(OpPtrCastToGeneric {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrCastToGeneric"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GenericCastToPtr(OpGenericCastToPtr {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGenericCastToPtr"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GenericCastToPtrExplicit(OpGenericCastToPtrExplicit {
                id_result_type,
                id_result,
                pointer,
                storage,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGenericCastToPtrExplicit"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                storage.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Bitcast(OpBitcast {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitcast"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SNegate(OpSNegate {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSNegate"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FNegate(OpFNegate {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFNegate"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IAdd(OpIAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FAdd(OpFAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFAdd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ISub(OpISub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpISub"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FSub(OpFSub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFSub"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IMul(OpIMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIMul"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FMul(OpFMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFMul"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UDiv(OpUDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUDiv"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SDiv(OpSDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSDiv"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FDiv(OpFDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFDiv"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UMod(OpUMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUMod"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SRem(OpSRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSRem"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SMod(OpSMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSMod"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FRem(OpFRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFRem"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FMod(OpFMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFMod"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorTimesScalar(OpVectorTimesScalar {
                id_result_type,
                id_result,
                vector,
                scalar,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorTimesScalar"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                scalar.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MatrixTimesScalar(OpMatrixTimesScalar {
                id_result_type,
                id_result,
                matrix,
                scalar,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpMatrixTimesScalar"
                )?;
                id_result_type.spirv_display(f)?;
                matrix.spirv_display(f)?;
                scalar.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorTimesMatrix(OpVectorTimesMatrix {
                id_result_type,
                id_result,
                vector,
                matrix,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorTimesMatrix"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                matrix.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MatrixTimesVector(OpMatrixTimesVector {
                id_result_type,
                id_result,
                matrix,
                vector,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpMatrixTimesVector"
                )?;
                id_result_type.spirv_display(f)?;
                matrix.spirv_display(f)?;
                vector.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MatrixTimesMatrix(OpMatrixTimesMatrix {
                id_result_type,
                id_result,
                left_matrix,
                right_matrix,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpMatrixTimesMatrix"
                )?;
                id_result_type.spirv_display(f)?;
                left_matrix.spirv_display(f)?;
                right_matrix.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OuterProduct(OpOuterProduct {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpOuterProduct"
                )?;
                id_result_type.spirv_display(f)?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Dot(OpDot {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDot"
                )?;
                id_result_type.spirv_display(f)?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IAddCarry(OpIAddCarry {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIAddCarry"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ISubBorrow(OpISubBorrow {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpISubBorrow"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UMulExtended(OpUMulExtended {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUMulExtended"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SMulExtended(OpSMulExtended {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSMulExtended"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Any(OpAny {
                id_result_type,
                id_result,
                vector,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAny"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::All(OpAll {
                id_result_type,
                id_result,
                vector,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAll"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsNan(OpIsNan {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsNan"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsInf(OpIsInf {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsInf"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsFinite(OpIsFinite {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsFinite"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsNormal(OpIsNormal {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsNormal"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SignBitSet(OpSignBitSet {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSignBitSet"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LessOrGreater(OpLessOrGreater {
                id_result_type,
                id_result,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLessOrGreater"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Ordered(OpOrdered {
                id_result_type,
                id_result,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpOrdered"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Unordered(OpUnordered {
                id_result_type,
                id_result,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUnordered"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalEqual(OpLogicalEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalNotEqual(OpLogicalNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalOr(OpLogicalOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalOr"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalAnd(OpLogicalAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalAnd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalNot(OpLogicalNot {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalNot"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Select(OpSelect {
                id_result_type,
                id_result,
                condition,
                object_1,
                object_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSelect"
                )?;
                id_result_type.spirv_display(f)?;
                condition.spirv_display(f)?;
                object_1.spirv_display(f)?;
                object_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IEqual(OpIEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::INotEqual(OpINotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpINotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UGreaterThan(OpUGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SGreaterThan(OpSGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UGreaterThanEqual(OpUGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SGreaterThanEqual(OpSGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ULessThan(OpULessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpULessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SLessThan(OpSLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSLessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ULessThanEqual(OpULessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpULessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SLessThanEqual(OpSLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSLessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdEqual(OpFOrdEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordEqual(OpFUnordEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdNotEqual(OpFOrdNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordNotEqual(OpFUnordNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdLessThan(OpFOrdLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdLessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordLessThan(OpFUnordLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordLessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdGreaterThan(OpFOrdGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordGreaterThan(OpFUnordGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdLessThanEqual(OpFOrdLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdLessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordLessThanEqual(OpFUnordLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordLessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdGreaterThanEqual(OpFOrdGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordGreaterThanEqual(OpFUnordGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ShiftRightLogical(OpShiftRightLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpShiftRightLogical"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ShiftRightArithmetic(OpShiftRightArithmetic {
                id_result_type,
                id_result,
                base,
                shift,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpShiftRightArithmetic"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ShiftLeftLogical(OpShiftLeftLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpShiftLeftLogical"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitwiseOr(OpBitwiseOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitwiseOr"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitwiseXor(OpBitwiseXor {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitwiseXor"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitwiseAnd(OpBitwiseAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitwiseAnd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Not(OpNot {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpNot"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitFieldInsert(OpBitFieldInsert {
                id_result_type,
                id_result,
                base,
                insert,
                offset,
                count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitFieldInsert"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                insert.spirv_display(f)?;
                offset.spirv_display(f)?;
                count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitFieldSExtract(OpBitFieldSExtract {
                id_result_type,
                id_result,
                base,
                offset,
                count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitFieldSExtract"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                offset.spirv_display(f)?;
                count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitFieldUExtract(OpBitFieldUExtract {
                id_result_type,
                id_result,
                base,
                offset,
                count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitFieldUExtract"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                offset.spirv_display(f)?;
                count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitReverse(OpBitReverse {
                id_result_type,
                id_result,
                base,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitReverse"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitCount(OpBitCount {
                id_result_type,
                id_result,
                base,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitCount"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdx(OpDPdx {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdx"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdy(OpDPdy {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdy"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Fwidth(OpFwidth {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFwidth"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdxFine(OpDPdxFine {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdxFine"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdyFine(OpDPdyFine {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdyFine"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FwidthFine(OpFwidthFine {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFwidthFine"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdxCoarse(OpDPdxCoarse {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdxCoarse"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdyCoarse(OpDPdyCoarse {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdyCoarse"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FwidthCoarse(OpFwidthCoarse {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFwidthCoarse"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EmitVertex(OpEmitVertex {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpEmitVertex")?;
                writeln!(f)
            }),
            Instruction::EndPrimitive(OpEndPrimitive {}) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpEndPrimitive"
                )?;
                writeln!(f)
            }),
            Instruction::EmitStreamVertex(OpEmitStreamVertex { stream }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpEmitStreamVertex"
                )?;
                stream.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EndStreamPrimitive(OpEndStreamPrimitive { stream }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpEndStreamPrimitive"
                )?;
                stream.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ControlBarrier(OpControlBarrier {
                execution,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpControlBarrier"
                )?;
                execution.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemoryBarrier(OpMemoryBarrier { memory, semantics }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemoryBarrier"
                )?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicLoad(OpAtomicLoad {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicLoad"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicStore(OpAtomicStore {
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpAtomicStore")?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicExchange(OpAtomicExchange {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicExchange"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicCompareExchange(OpAtomicCompareExchange {
                id_result_type,
                id_result,
                pointer,
                memory,
                equal,
                unequal,
                value,
                comparator,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicCompareExchange"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                equal.spirv_display(f)?;
                unequal.spirv_display(f)?;
                value.spirv_display(f)?;
                comparator.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicCompareExchangeWeak(OpAtomicCompareExchangeWeak {
                id_result_type,
                id_result,
                pointer,
                memory,
                equal,
                unequal,
                value,
                comparator,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicCompareExchangeWeak"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                equal.spirv_display(f)?;
                unequal.spirv_display(f)?;
                value.spirv_display(f)?;
                comparator.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicIIncrement(OpAtomicIIncrement {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicIIncrement"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicIDecrement(OpAtomicIDecrement {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicIDecrement"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicIAdd(OpAtomicIAdd {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicISub(OpAtomicISub {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicISub"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicSMin(OpAtomicSMin {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicSMin"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicUMin(OpAtomicUMin {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicUMin"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicSMax(OpAtomicSMax {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicSMax"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicUMax(OpAtomicUMax {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicUMax"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicAnd(OpAtomicAnd {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicAnd"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicOr(OpAtomicOr {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicOr"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicXor(OpAtomicXor {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicXor"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Phi(OpPhi {
                id_result_type,
                id_result,
                variable_parent,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPhi"
                )?;
                id_result_type.spirv_display(f)?;
                variable_parent.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LoopMerge(OpLoopMerge {
                merge_block,
                continue_target,
                loop_control,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpLoopMerge")?;
                merge_block.spirv_display(f)?;
                continue_target.spirv_display(f)?;
                loop_control.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SelectionMerge(OpSelectionMerge {
                merge_block,
                selection_control,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSelectionMerge"
                )?;
                merge_block.spirv_display(f)?;
                selection_control.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Label(OpLabel { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLabel"
                )?;
                writeln!(f)
            }),
            Instruction::Branch(OpBranch { target_label }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpBranch")?;
                target_label.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BranchConditional(OpBranchConditional {
                condition,
                true_label,
                false_label,
                branch_weights,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpBranchConditional"
                )?;
                condition.spirv_display(f)?;
                true_label.spirv_display(f)?;
                false_label.spirv_display(f)?;
                branch_weights.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Switch32(OpSwitch32 {
                selector,
                default,
                target,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpSwitch")?;
                selector.spirv_display(f)?;
                default.spirv_display(f)?;
                target.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Switch64(OpSwitch64 {
                selector,
                default,
                target,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpSwitch")?;
                selector.spirv_display(f)?;
                default.spirv_display(f)?;
                target.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Kill(OpKill {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpKill")?;
                writeln!(f)
            }),
            Instruction::Return(OpReturn {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpReturn")?;
                writeln!(f)
            }),
            Instruction::ReturnValue(OpReturnValue { value }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpReturnValue")?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Unreachable(OpUnreachable {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpUnreachable")?;
                writeln!(f)
            }),
            Instruction::LifetimeStart(OpLifetimeStart { pointer, size }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpLifetimeStart"
                )?;
                pointer.spirv_display(f)?;
                size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LifetimeStop(OpLifetimeStop { pointer, size }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpLifetimeStop"
                )?;
                pointer.spirv_display(f)?;
                size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupAsyncCopy(OpGroupAsyncCopy {
                id_result_type,
                id_result,
                execution,
                destination,
                source,
                num_elements,
                stride,
                event,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupAsyncCopy"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                destination.spirv_display(f)?;
                source.spirv_display(f)?;
                num_elements.spirv_display(f)?;
                stride.spirv_display(f)?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupWaitEvents(OpGroupWaitEvents {
                execution,
                num_events,
                events_list,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupWaitEvents"
                )?;
                execution.spirv_display(f)?;
                num_events.spirv_display(f)?;
                events_list.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupAll(OpGroupAll {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupAll"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupAny(OpGroupAny {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupAny"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupBroadcast(OpGroupBroadcast {
                id_result_type,
                id_result,
                execution,
                value,
                local_id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupBroadcast"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                local_id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupIAdd(OpGroupIAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupFAdd(OpGroupFAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupFAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupFMin(OpGroupFMin {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupFMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupUMin(OpGroupUMin {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupUMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupSMin(OpGroupSMin {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupSMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupFMax(OpGroupFMax {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupFMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupUMax(OpGroupUMax {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupUMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupSMax(OpGroupSMax {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupSMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReadPipe(OpReadPipe {
                id_result_type,
                id_result,
                pipe,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReadPipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::WritePipe(OpWritePipe {
                id_result_type,
                id_result,
                pipe,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpWritePipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReservedReadPipe(OpReservedReadPipe {
                id_result_type,
                id_result,
                pipe,
                reserve_id,
                index,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReservedReadPipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                index.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReservedWritePipe(OpReservedWritePipe {
                id_result_type,
                id_result,
                pipe,
                reserve_id,
                index,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReservedWritePipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                index.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReserveReadPipePackets(OpReserveReadPipePackets {
                id_result_type,
                id_result,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReserveReadPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReserveWritePipePackets(OpReserveWritePipePackets {
                id_result_type,
                id_result,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReserveWritePipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CommitReadPipe(OpCommitReadPipe {
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCommitReadPipe"
                )?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CommitWritePipe(OpCommitWritePipe {
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCommitWritePipe"
                )?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsValidReserveId(OpIsValidReserveId {
                id_result_type,
                id_result,
                reserve_id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsValidReserveId"
                )?;
                id_result_type.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetNumPipePackets(OpGetNumPipePackets {
                id_result_type,
                id_result,
                pipe,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetNumPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetMaxPipePackets(OpGetMaxPipePackets {
                id_result_type,
                id_result,
                pipe,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetMaxPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupReserveReadPipePackets(OpGroupReserveReadPipePackets {
                id_result_type,
                id_result,
                execution,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupReserveReadPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupReserveWritePipePackets(OpGroupReserveWritePipePackets {
                id_result_type,
                id_result,
                execution,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupReserveWritePipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupCommitReadPipe(OpGroupCommitReadPipe {
                execution,
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupCommitReadPipe"
                )?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupCommitWritePipe(OpGroupCommitWritePipe {
                execution,
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupCommitWritePipe"
                )?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EnqueueMarker(OpEnqueueMarker {
                id_result_type,
                id_result,
                queue,
                num_events,
                wait_events,
                ret_event,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpEnqueueMarker"
                )?;
                id_result_type.spirv_display(f)?;
                queue.spirv_display(f)?;
                num_events.spirv_display(f)?;
                wait_events.spirv_display(f)?;
                ret_event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EnqueueKernel(OpEnqueueKernel {
                id_result_type,
                id_result,
                queue,
                flags,
                nd_range,
                num_events,
                wait_events,
                ret_event,
                invoke,
                param,
                param_size,
                param_align,
                local_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpEnqueueKernel"
                )?;
                id_result_type.spirv_display(f)?;
                queue.spirv_display(f)?;
                flags.spirv_display(f)?;
                nd_range.spirv_display(f)?;
                num_events.spirv_display(f)?;
                wait_events.spirv_display(f)?;
                ret_event.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                local_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelNDrangeSubGroupCount(OpGetKernelNDrangeSubGroupCount {
                id_result_type,
                id_result,
                nd_range,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelNDrangeSubGroupCount"
                )?;
                id_result_type.spirv_display(f)?;
                nd_range.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelNDrangeMaxSubGroupSize(OpGetKernelNDrangeMaxSubGroupSize {
                id_result_type,
                id_result,
                nd_range,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelNDrangeMaxSubGroupSize"
                )?;
                id_result_type.spirv_display(f)?;
                nd_range.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelWorkGroupSize(OpGetKernelWorkGroupSize {
                id_result_type,
                id_result,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelWorkGroupSize"
                )?;
                id_result_type.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelPreferredWorkGroupSizeMultiple(
                OpGetKernelPreferredWorkGroupSizeMultiple {
                    id_result_type,
                    id_result,
                    invoke,
                    param,
                    param_size,
                    param_align,
                },
            ) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelPreferredWorkGroupSizeMultiple"
                )?;
                id_result_type.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::RetainEvent(OpRetainEvent { event }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpRetainEvent")?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReleaseEvent(OpReleaseEvent { event }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpReleaseEvent"
                )?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CreateUserEvent(OpCreateUserEvent {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCreateUserEvent"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsValidEvent(OpIsValidEvent {
                id_result_type,
                id_result,
                event,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsValidEvent"
                )?;
                id_result_type.spirv_display(f)?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SetUserEventStatus(OpSetUserEventStatus { event, status }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSetUserEventStatus"
                )?;
                event.spirv_display(f)?;
                status.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CaptureEventProfilingInfo(OpCaptureEventProfilingInfo {
                event,
                profiling_info,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCaptureEventProfilingInfo"
                )?;
                event.spirv_display(f)?;
                profiling_info.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetDefaultQueue(OpGetDefaultQueue {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetDefaultQueue"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BuildNDRange(OpBuildNDRange {
                id_result_type,
                id_result,
                global_work_size,
                local_work_size,
                global_work_offset,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBuildNDRange"
                )?;
                id_result_type.spirv_display(f)?;
                global_work_size.spirv_display(f)?;
                local_work_size.spirv_display(f)?;
                global_work_offset.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleImplicitLod(OpImageSparseSampleImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleExplicitLod(OpImageSparseSampleExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleDrefImplicitLod(OpImageSparseSampleDrefImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleDrefImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleDrefExplicitLod(OpImageSparseSampleDrefExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleDrefExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseFetch(OpImageSparseFetch {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseFetch"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseGather(OpImageSparseGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                component,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                component.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseDrefGather(OpImageSparseDrefGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseDrefGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseTexelsResident(OpImageSparseTexelsResident {
                id_result_type,
                id_result,
                resident_code,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseTexelsResident"
                )?;
                id_result_type.spirv_display(f)?;
                resident_code.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::NoLine(OpNoLine {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpNoLine")?;
                writeln!(f)
            }),
            Instruction::AtomicFlagTestAndSet(OpAtomicFlagTestAndSet {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicFlagTestAndSet"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicFlagClear(OpAtomicFlagClear {
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpAtomicFlagClear"
                )?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseRead(OpImageSparseRead {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseRead"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SizeOf(OpSizeOf {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSizeOf"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypePipeStorage(OpTypePipeStorage { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypePipeStorage"
                )?;
                writeln!(f)
            }),
            Instruction::ConstantPipeStorage(OpConstantPipeStorage {
                id_result_type,
                id_result,
                packet_size,
                packet_alignment,
                capacity,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantPipeStorage"
                )?;
                id_result_type.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                capacity.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CreatePipeFromPipeStorage(OpCreatePipeFromPipeStorage {
                id_result_type,
                id_result,
                pipe_storage,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCreatePipeFromPipeStorage"
                )?;
                id_result_type.spirv_display(f)?;
                pipe_storage.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelLocalSizeForSubgroupCount(
                OpGetKernelLocalSizeForSubgroupCount {
                    id_result_type,
                    id_result,
                    subgroup_count,
                    invoke,
                    param,
                    param_size,
                    param_align,
                },
            ) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelLocalSizeForSubgroupCount"
                )?;
                id_result_type.spirv_display(f)?;
                subgroup_count.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelMaxNumSubgroups(OpGetKernelMaxNumSubgroups {
                id_result_type,
                id_result,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelMaxNumSubgroups"
                )?;
                id_result_type.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeNamedBarrier(OpTypeNamedBarrier { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeNamedBarrier"
                )?;
                writeln!(f)
            }),
            Instruction::NamedBarrierInitialize(OpNamedBarrierInitialize {
                id_result_type,
                id_result,
                subgroup_count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpNamedBarrierInitialize"
                )?;
                id_result_type.spirv_display(f)?;
                subgroup_count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemoryNamedBarrier(OpMemoryNamedBarrier {
                named_barrier,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemoryNamedBarrier"
                )?;
                named_barrier.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ModuleProcessed(OpModuleProcessed { process }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpModuleProcessed"
                )?;
                process.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ExecutionModeId(OpExecutionModeId { entry_point, mode }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpExecutionModeId"
                )?;
                entry_point.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DecorateId(OpDecorateId { target, decoration }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpDecorateId")?;
                target.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformElect(OpGroupNonUniformElect {
                id_result_type,
                id_result,
                execution,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformElect"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformAll(OpGroupNonUniformAll {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformAll"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformAny(OpGroupNonUniformAny {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformAny"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformAllEqual(OpGroupNonUniformAllEqual {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformAllEqual"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBroadcast(OpGroupNonUniformBroadcast {
                id_result_type,
                id_result,
                execution,
                value,
                id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBroadcast"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBroadcastFirst(OpGroupNonUniformBroadcastFirst {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBroadcastFirst"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallot(OpGroupNonUniformBallot {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallot"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformInverseBallot(OpGroupNonUniformInverseBallot {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformInverseBallot"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotBitExtract(OpGroupNonUniformBallotBitExtract {
                id_result_type,
                id_result,
                execution,
                value,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotBitExtract"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotBitCount(OpGroupNonUniformBallotBitCount {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotBitCount"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotFindLSB(OpGroupNonUniformBallotFindLSB {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotFindLSB"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotFindMSB(OpGroupNonUniformBallotFindMSB {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotFindMSB"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffle(OpGroupNonUniformShuffle {
                id_result_type,
                id_result,
                execution,
                value,
                id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffle"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffleXor(OpGroupNonUniformShuffleXor {
                id_result_type,
                id_result,
                execution,
                value,
                mask,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffleXor"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                mask.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffleUp(OpGroupNonUniformShuffleUp {
                id_result_type,
                id_result,
                execution,
                value,
                delta,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffleUp"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                delta.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffleDown(OpGroupNonUniformShuffleDown {
                id_result_type,
                id_result,
                execution,
                value,
                delta,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffleDown"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                delta.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformIAdd(OpGroupNonUniformIAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFAdd(OpGroupNonUniformFAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformIMul(OpGroupNonUniformIMul {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformIMul"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFMul(OpGroupNonUniformFMul {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFMul"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformSMin(OpGroupNonUniformSMin {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformSMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformUMin(OpGroupNonUniformUMin {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformUMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFMin(OpGroupNonUniformFMin {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformSMax(OpGroupNonUniformSMax {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformSMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformUMax(OpGroupNonUniformUMax {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformUMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFMax(OpGroupNonUniformFMax {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBitwiseAnd(OpGroupNonUniformBitwiseAnd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBitwiseAnd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBitwiseOr(OpGroupNonUniformBitwiseOr {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBitwiseOr"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBitwiseXor(OpGroupNonUniformBitwiseXor {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBitwiseXor"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformLogicalAnd(OpGroupNonUniformLogicalAnd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformLogicalAnd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformLogicalOr(OpGroupNonUniformLogicalOr {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformLogicalOr"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformLogicalXor(OpGroupNonUniformLogicalXor {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformLogicalXor"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformQuadBroadcast(OpGroupNonUniformQuadBroadcast {
                id_result_type,
                id_result,
                execution,
                value,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformQuadBroadcast"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformQuadSwap(OpGroupNonUniformQuadSwap {
                id_result_type,
                id_result,
                execution,
                value,
                direction,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformQuadSwap"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                direction.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyLogical(OpCopyLogical {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCopyLogical"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrEqual(OpPtrEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrNotEqual(OpPtrNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrDiff(OpPtrDiff {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrDiff"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DecorateString(OpDecorateString { target, decoration }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpDecorateString"
                )?;
                target.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemberDecorateString(OpMemberDecorateString {
                struct_type,
                member,
                decoration,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemberDecorateString"
                )?;
                struct_type.spirv_display(f)?;
                member.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAcos(OpOpenCLStdAcos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "acos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAcosh(OpOpenCLStdAcosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "acosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAcospi(OpOpenCLStdAcospi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "acospi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAsin(OpOpenCLStdAsin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "asin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAsinh(OpOpenCLStdAsinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "asinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAsinpi(OpOpenCLStdAsinpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "asinpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtan(OpOpenCLStdAtan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtan2(OpOpenCLStdAtan2 {
                id_result_type,
                id_result,
                set,
                y,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atan2",
                )?;
                y.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtanh(OpOpenCLStdAtanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtanpi(OpOpenCLStdAtanpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atanpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtan2pi(OpOpenCLStdAtan2pi {
                id_result_type,
                id_result,
                set,
                y,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atan2pi",
                )?;
                y.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCbrt(OpOpenCLStdCbrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cbrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCeil(OpOpenCLStdCeil {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ceil",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCopysign(OpOpenCLStdCopysign {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "copysign",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCos(OpOpenCLStdCos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCosh(OpOpenCLStdCosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCospi(OpOpenCLStdCospi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cospi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdErfc(OpOpenCLStdErfc {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "erfc",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdErf(OpOpenCLStdErf {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "erf",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExp(OpOpenCLStdExp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExp2(OpOpenCLStdExp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExp10(OpOpenCLStdExp10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "exp10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExpm1(OpOpenCLStdExpm1 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "expm1",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFabs(OpOpenCLStdFabs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fabs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFdim(OpOpenCLStdFdim {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fdim",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFloor(OpOpenCLStdFloor {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "floor",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFma(OpOpenCLStdFma {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fma",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmax(OpOpenCLStdFmax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmin(OpOpenCLStdFmin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmod(OpOpenCLStdFmod {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmod",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFract(OpOpenCLStdFract {
                id_result_type,
                id_result,
                set,
                x,
                ptr,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fract",
                )?;
                x.spirv_display(f)?;
                ptr.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFrexp(OpOpenCLStdFrexp {
                id_result_type,
                id_result,
                set,
                x,
                exp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "frexp",
                )?;
                x.spirv_display(f)?;
                exp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHypot(OpOpenCLStdHypot {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "hypot",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdIlogb(OpOpenCLStdIlogb {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ilogb",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLdexp(OpOpenCLStdLdexp {
                id_result_type,
                id_result,
                set,
                x,
                k,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ldexp",
                )?;
                x.spirv_display(f)?;
                k.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLgamma(OpOpenCLStdLgamma {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "lgamma",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLgammaR(OpOpenCLStdLgammaR {
                id_result_type,
                id_result,
                set,
                x,
                signp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "lgamma_r",
                )?;
                x.spirv_display(f)?;
                signp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog(OpOpenCLStdLog {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog2(OpOpenCLStdLog2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog10(OpOpenCLStdLog10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog1p(OpOpenCLStdLog1p {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log1p",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLogb(OpOpenCLStdLogb {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "logb",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMad(OpOpenCLStdMad {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "mad",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMaxmag(OpOpenCLStdMaxmag {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "maxmag",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMinmag(OpOpenCLStdMinmag {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "minmag",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdModf(OpOpenCLStdModf {
                id_result_type,
                id_result,
                set,
                x,
                iptr,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "modf",
                )?;
                x.spirv_display(f)?;
                iptr.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNan(OpOpenCLStdNan {
                id_result_type,
                id_result,
                set,
                nancode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "nan",
                )?;
                nancode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNextafter(OpOpenCLStdNextafter {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "nextafter",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPow(OpOpenCLStdPow {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "pow",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPown(OpOpenCLStdPown {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "pown",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPowr(OpOpenCLStdPowr {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "powr",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRemainder(OpOpenCLStdRemainder {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "remainder",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRemquo(OpOpenCLStdRemquo {
                id_result_type,
                id_result,
                set,
                x,
                y,
                quo,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "remquo",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                quo.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRint(OpOpenCLStdRint {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rint",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRootn(OpOpenCLStdRootn {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rootn",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRound(OpOpenCLStdRound {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "round",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRsqrt(OpOpenCLStdRsqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rsqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSin(OpOpenCLStdSin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSincos(OpOpenCLStdSincos {
                id_result_type,
                id_result,
                set,
                x,
                cosval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sincos",
                )?;
                x.spirv_display(f)?;
                cosval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSinh(OpOpenCLStdSinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSinpi(OpOpenCLStdSinpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sinpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSqrt(OpOpenCLStdSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTan(OpOpenCLStdTan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTanh(OpOpenCLStdTanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTanpi(OpOpenCLStdTanpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tanpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTgamma(OpOpenCLStdTgamma {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tgamma",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTrunc(OpOpenCLStdTrunc {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "trunc",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfCos(OpOpenCLStdHalfCos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfDivide(OpOpenCLStdHalfDivide {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_divide",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfExp(OpOpenCLStdHalfExp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfExp2(OpOpenCLStdHalfExp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfExp10(OpOpenCLStdHalfExp10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_exp10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfLog(OpOpenCLStdHalfLog {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfLog2(OpOpenCLStdHalfLog2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfLog10(OpOpenCLStdHalfLog10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_log10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfPowr(OpOpenCLStdHalfPowr {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_powr",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfRecip(OpOpenCLStdHalfRecip {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_recip",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfRsqrt(OpOpenCLStdHalfRsqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_rsqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfSin(OpOpenCLStdHalfSin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfSqrt(OpOpenCLStdHalfSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfTan(OpOpenCLStdHalfTan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeCos(OpOpenCLStdNativeCos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeDivide(OpOpenCLStdNativeDivide {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_divide",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeExp(OpOpenCLStdNativeExp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeExp2(OpOpenCLStdNativeExp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeExp10(OpOpenCLStdNativeExp10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_exp10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeLog(OpOpenCLStdNativeLog {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeLog2(OpOpenCLStdNativeLog2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeLog10(OpOpenCLStdNativeLog10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_log10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativePowr(OpOpenCLStdNativePowr {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_powr",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeRecip(OpOpenCLStdNativeRecip {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_recip",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeRsqrt(OpOpenCLStdNativeRsqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_rsqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeSin(OpOpenCLStdNativeSin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeSqrt(OpOpenCLStdNativeSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeTan(OpOpenCLStdNativeTan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSAbs(OpOpenCLStdSAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_abs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSAbsDiff(OpOpenCLStdSAbsDiff {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_abs_diff",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSAddSat(OpOpenCLStdSAddSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_add_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUAddSat(OpOpenCLStdUAddSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_add_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSHadd(OpOpenCLStdSHadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_hadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUHadd(OpOpenCLStdUHadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_hadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSRhadd(OpOpenCLStdSRhadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_rhadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdURhadd(OpOpenCLStdURhadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_rhadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSClamp(OpOpenCLStdSClamp {
                id_result_type,
                id_result,
                set,
                x,
                minval,
                maxval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_clamp",
                )?;
                x.spirv_display(f)?;
                minval.spirv_display(f)?;
                maxval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUClamp(OpOpenCLStdUClamp {
                id_result_type,
                id_result,
                set,
                x,
                minval,
                maxval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_clamp",
                )?;
                x.spirv_display(f)?;
                minval.spirv_display(f)?;
                maxval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdClz(OpOpenCLStdClz {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "clz",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCtz(OpOpenCLStdCtz {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ctz",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMadHi(OpOpenCLStdSMadHi {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mad_hi",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMadSat(OpOpenCLStdUMadSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mad_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMadSat(OpOpenCLStdSMadSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mad_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMax(OpOpenCLStdSMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_max",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMax(OpOpenCLStdUMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_max",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMin(OpOpenCLStdSMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_min",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMin(OpOpenCLStdUMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_min",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMulHi(OpOpenCLStdSMulHi {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mul_hi",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRotate(OpOpenCLStdRotate {
                id_result_type,
                id_result,
                set,
                v,
                i,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rotate",
                )?;
                v.spirv_display(f)?;
                i.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSSubSat(OpOpenCLStdSSubSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_sub_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUSubSat(OpOpenCLStdUSubSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_sub_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUUpsample(OpOpenCLStdUUpsample {
                id_result_type,
                id_result,
                set,
                hi,
                lo,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_upsample",
                )?;
                hi.spirv_display(f)?;
                lo.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSUpsample(OpOpenCLStdSUpsample {
                id_result_type,
                id_result,
                set,
                hi,
                lo,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_upsample",
                )?;
                hi.spirv_display(f)?;
                lo.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPopcount(OpOpenCLStdPopcount {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "popcount",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMad24(OpOpenCLStdSMad24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mad24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMad24(OpOpenCLStdUMad24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mad24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMul24(OpOpenCLStdSMul24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mul24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMul24(OpOpenCLStdUMul24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mul24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUAbs(OpOpenCLStdUAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_abs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUAbsDiff(OpOpenCLStdUAbsDiff {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_abs_diff",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMulHi(OpOpenCLStdUMulHi {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mul_hi",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMadHi(OpOpenCLStdUMadHi {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mad_hi",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFclamp(OpOpenCLStdFclamp {
                id_result_type,
                id_result,
                set,
                x,
                minval,
                maxval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fclamp",
                )?;
                x.spirv_display(f)?;
                minval.spirv_display(f)?;
                maxval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdDegrees(OpOpenCLStdDegrees {
                id_result_type,
                id_result,
                set,
                radians,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "degrees",
                )?;
                radians.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmaxCommon(OpOpenCLStdFmaxCommon {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmax_common",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFminCommon(OpOpenCLStdFminCommon {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmin_common",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMix(OpOpenCLStdMix {
                id_result_type,
                id_result,
                set,
                x,
                y,
                a,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "mix",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                a.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRadians(OpOpenCLStdRadians {
                id_result_type,
                id_result,
                set,
                degrees,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "radians",
                )?;
                degrees.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdStep(OpOpenCLStdStep {
                id_result_type,
                id_result,
                set,
                edge,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "step",
                )?;
                edge.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSmoothstep(OpOpenCLStdSmoothstep {
                id_result_type,
                id_result,
                set,
                edge0,
                edge1,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "smoothstep",
                )?;
                edge0.spirv_display(f)?;
                edge1.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSign(OpOpenCLStdSign {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sign",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCross(OpOpenCLStdCross {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cross",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdDistance(OpOpenCLStdDistance {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "distance",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLength(OpOpenCLStdLength {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "length",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNormalize(OpOpenCLStdNormalize {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "normalize",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFastDistance(OpOpenCLStdFastDistance {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fast_distance",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFastLength(OpOpenCLStdFastLength {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fast_length",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFastNormalize(OpOpenCLStdFastNormalize {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fast_normalize",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdBitselect(OpOpenCLStdBitselect {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "bitselect",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSelect(OpOpenCLStdSelect {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "select",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadn(OpOpenCLStdVloadn {
                id_result_type,
                id_result,
                set,
                offset,
                p,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vloadn",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoren(OpOpenCLStdVstoren {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstoren",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadHalf(OpOpenCLStdVloadHalf {
                id_result_type,
                id_result,
                set,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vload_half",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadHalfn(OpOpenCLStdVloadHalfn {
                id_result_type,
                id_result,
                set,
                offset,
                p,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vload_halfn",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalf(OpOpenCLStdVstoreHalf {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_half",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalfR(OpOpenCLStdVstoreHalfR {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
                mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_half_r",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalfn(OpOpenCLStdVstoreHalfn {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_halfn",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalfnR(OpOpenCLStdVstoreHalfnR {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
                mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_halfn_r",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadaHalfn(OpOpenCLStdVloadaHalfn {
                id_result_type,
                id_result,
                set,
                offset,
                p,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vloada_halfn",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreaHalfn(OpOpenCLStdVstoreaHalfn {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstorea_halfn",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreaHalfnR(OpOpenCLStdVstoreaHalfnR {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
                mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstorea_halfn_r",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdShuffle(OpOpenCLStdShuffle {
                id_result_type,
                id_result,
                set,
                x,
                shuffle_mask,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "shuffle",
                )?;
                x.spirv_display(f)?;
                shuffle_mask.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdShuffle2(OpOpenCLStdShuffle2 {
                id_result_type,
                id_result,
                set,
                x,
                y,
                shuffle_mask,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "shuffle2",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                shuffle_mask.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPrintf(OpOpenCLStdPrintf {
                id_result_type,
                id_result,
                set,
                format,
                additional_arguments,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "printf",
                )?;
                format.spirv_display(f)?;
                additional_arguments.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPrefetch(OpOpenCLStdPrefetch {
                id_result_type,
                id_result,
                set,
                ptr,
                num_elements,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "prefetch",
                )?;
                ptr.spirv_display(f)?;
                num_elements.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Round(OpGLSLStd450Round {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Round",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450RoundEven(OpGLSLStd450RoundEven {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "RoundEven",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Trunc(OpGLSLStd450Trunc {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Trunc",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FAbs(OpGLSLStd450FAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FAbs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SAbs(OpGLSLStd450SAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SAbs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FSign(OpGLSLStd450FSign {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FSign",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SSign(OpGLSLStd450SSign {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SSign",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Floor(OpGLSLStd450Floor {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Floor",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Ceil(OpGLSLStd450Ceil {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Ceil",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Fract(OpGLSLStd450Fract {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Fract",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Radians(OpGLSLStd450Radians {
                id_result_type,
                id_result,
                set,
                degrees,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Radians",
                )?;
                degrees.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Degrees(OpGLSLStd450Degrees {
                id_result_type,
                id_result,
                set,
                radians,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Degrees",
                )?;
                radians.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Sin(OpGLSLStd450Sin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Cos(OpGLSLStd450Cos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Tan(OpGLSLStd450Tan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Asin(OpGLSLStd450Asin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Asin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Acos(OpGLSLStd450Acos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Acos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Atan(OpGLSLStd450Atan {
                id_result_type,
                id_result,
                set,
                y_over_x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Atan",
                )?;
                y_over_x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Sinh(OpGLSLStd450Sinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Sinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Cosh(OpGLSLStd450Cosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Cosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Tanh(OpGLSLStd450Tanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Tanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Asinh(OpGLSLStd450Asinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Asinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Acosh(OpGLSLStd450Acosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Acosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Atanh(OpGLSLStd450Atanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Atanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Atan2(OpGLSLStd450Atan2 {
                id_result_type,
                id_result,
                set,
                y,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Atan2",
                )?;
                y.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Pow(OpGLSLStd450Pow {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Pow",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Exp(OpGLSLStd450Exp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Log(OpGLSLStd450Log {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Exp2(OpGLSLStd450Exp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Log2(OpGLSLStd450Log2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Sqrt(OpGLSLStd450Sqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InverseSqrt(OpGLSLStd450InverseSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InverseSqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Determinant(OpGLSLStd450Determinant {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Determinant",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450MatrixInverse(OpGLSLStd450MatrixInverse {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "MatrixInverse",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Modf(OpGLSLStd450Modf {
                id_result_type,
                id_result,
                set,
                x,
                i,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Modf",
                )?;
                x.spirv_display(f)?;
                i.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450ModfStruct(OpGLSLStd450ModfStruct {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ModfStruct",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FMin(OpGLSLStd450FMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UMin(OpGLSLStd450UMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SMin(OpGLSLStd450SMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FMax(OpGLSLStd450FMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UMax(OpGLSLStd450UMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SMax(OpGLSLStd450SMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FClamp(OpGLSLStd450FClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UClamp(OpGLSLStd450UClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SClamp(OpGLSLStd450SClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FMix(OpGLSLStd450FMix {
                id_result_type,
                id_result,
                set,
                x,
                y,
                a,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FMix",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                a.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450IMix(OpGLSLStd450IMix {
                id_result_type,
                id_result,
                set,
                x,
                y,
                a,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "IMix",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                a.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Step(OpGLSLStd450Step {
                id_result_type,
                id_result,
                set,
                edge,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Step",
                )?;
                edge.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SmoothStep(OpGLSLStd450SmoothStep {
                id_result_type,
                id_result,
                set,
                edge0,
                edge1,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SmoothStep",
                )?;
                edge0.spirv_display(f)?;
                edge1.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Fma(OpGLSLStd450Fma {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Fma",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Frexp(OpGLSLStd450Frexp {
                id_result_type,
                id_result,
                set,
                x,
                exp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Frexp",
                )?;
                x.spirv_display(f)?;
                exp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FrexpStruct(OpGLSLStd450FrexpStruct {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FrexpStruct",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Ldexp(OpGLSLStd450Ldexp {
                id_result_type,
                id_result,
                set,
                x,
                exp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Ldexp",
                )?;
                x.spirv_display(f)?;
                exp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackSnorm4x8(OpGLSLStd450PackSnorm4x8 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackSnorm4x8",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackUnorm4x8(OpGLSLStd450PackUnorm4x8 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackUnorm4x8",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackSnorm2x16(OpGLSLStd450PackSnorm2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackSnorm2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackUnorm2x16(OpGLSLStd450PackUnorm2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackUnorm2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackHalf2x16(OpGLSLStd450PackHalf2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackHalf2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackDouble2x32(OpGLSLStd450PackDouble2x32 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackDouble2x32",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackSnorm2x16(OpGLSLStd450UnpackSnorm2x16 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackSnorm2x16",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackUnorm2x16(OpGLSLStd450UnpackUnorm2x16 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackUnorm2x16",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackHalf2x16(OpGLSLStd450UnpackHalf2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackHalf2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackSnorm4x8(OpGLSLStd450UnpackSnorm4x8 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackSnorm4x8",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackUnorm4x8(OpGLSLStd450UnpackUnorm4x8 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackUnorm4x8",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackDouble2x32(OpGLSLStd450UnpackDouble2x32 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackDouble2x32",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Length(OpGLSLStd450Length {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Length",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Distance(OpGLSLStd450Distance {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Distance",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Cross(OpGLSLStd450Cross {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Cross",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Normalize(OpGLSLStd450Normalize {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Normalize",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FaceForward(OpGLSLStd450FaceForward {
                id_result_type,
                id_result,
                set,
                n,
                i,
                nref,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FaceForward",
                )?;
                n.spirv_display(f)?;
                i.spirv_display(f)?;
                nref.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Reflect(OpGLSLStd450Reflect {
                id_result_type,
                id_result,
                set,
                i,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Reflect",
                )?;
                i.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Refract(OpGLSLStd450Refract {
                id_result_type,
                id_result,
                set,
                i,
                n,
                eta,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Refract",
                )?;
                i.spirv_display(f)?;
                n.spirv_display(f)?;
                eta.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FindILsb(OpGLSLStd450FindILsb {
                id_result_type,
                id_result,
                set,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FindILsb",
                )?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FindSMsb(OpGLSLStd450FindSMsb {
                id_result_type,
                id_result,
                set,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FindSMsb",
                )?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FindUMsb(OpGLSLStd450FindUMsb {
                id_result_type,
                id_result,
                set,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FindUMsb",
                )?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InterpolateAtCentroid(OpGLSLStd450InterpolateAtCentroid {
                id_result_type,
                id_result,
                set,
                interpolant,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InterpolateAtCentroid",
                )?;
                interpolant.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InterpolateAtSample(OpGLSLStd450InterpolateAtSample {
                id_result_type,
                id_result,
                set,
                interpolant,
                sample,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InterpolateAtSample",
                )?;
                interpolant.spirv_display(f)?;
                sample.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InterpolateAtOffset(OpGLSLStd450InterpolateAtOffset {
                id_result_type,
                id_result,
                set,
                interpolant,
                offset,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InterpolateAtOffset",
                )?;
                interpolant.spirv_display(f)?;
                offset.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450NMin(OpGLSLStd450NMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "NMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450NMax(OpGLSLStd450NMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "NMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450NClamp(OpGLSLStd450NClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "NClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
        }
    }
}
impl SPIRVParse for OpSpecConstantOp {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
        let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
        let (opcode, words) = u32::spirv_parse(words, parse_state)?;
        match opcode {
            65u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::AccessChain(OpAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            66u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::InBoundsAccessChain(OpInBoundsAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            67u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (element, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::PtrAccessChain(OpPtrAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            element,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            70u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (element, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::InBoundsPtrAccessChain(OpInBoundsPtrAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            element,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            79u32 => {
                let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
                let (components, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::VectorShuffle(OpVectorShuffle {
                            id_result_type,
                            id_result,
                            vector_1,
                            vector_2,
                            components,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            81u32 => {
                let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::CompositeExtract(OpCompositeExtract {
                            id_result_type,
                            id_result,
                            composite,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            82u32 => {
                let (object, words) = IdRef::spirv_parse(words, parse_state)?;
                let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::CompositeInsert(OpCompositeInsert {
                            id_result_type,
                            id_result,
                            object,
                            composite,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            109u32 => {
                let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertFToU(OpConvertFToU {
                            id_result_type,
                            id_result,
                            float_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            110u32 => {
                let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertFToS(OpConvertFToS {
                            id_result_type,
                            id_result,
                            float_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            111u32 => {
                let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertSToF(OpConvertSToF {
                            id_result_type,
                            id_result,
                            signed_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            112u32 => {
                let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertUToF(OpConvertUToF {
                            id_result_type,
                            id_result,
                            unsigned_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            113u32 => {
                let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UConvert(OpUConvert {
                            id_result_type,
                            id_result,
                            unsigned_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            114u32 => {
                let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SConvert(OpSConvert {
                            id_result_type,
                            id_result,
                            signed_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            115u32 => {
                let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FConvert(OpFConvert {
                            id_result_type,
                            id_result,
                            float_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            116u32 => {
                let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::QuantizeToF16(OpQuantizeToF16 {
                            id_result_type,
                            id_result,
                            value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            117u32 => {
                let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertPtrToU(OpConvertPtrToU {
                            id_result_type,
                            id_result,
                            pointer,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            120u32 => {
                let (integer_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertUToPtr(OpConvertUToPtr {
                            id_result_type,
                            id_result,
                            integer_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            121u32 => {
                let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::PtrCastToGeneric(OpPtrCastToGeneric {
                            id_result_type,
                            id_result,
                            pointer,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            122u32 => {
                let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::GenericCastToPtr(OpGenericCastToPtr {
                            id_result_type,
                            id_result,
                            pointer,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            124u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::Bitcast(OpBitcast {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            126u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SNegate(OpSNegate {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            127u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FNegate(OpFNegate {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            128u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::IAdd(OpIAdd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            129u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FAdd(OpFAdd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            130u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ISub(OpISub {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            131u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FSub(OpFSub {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            132u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::IMul(OpIMul {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            133u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FMul(OpFMul {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            134u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UDiv(OpUDiv {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            135u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SDiv(OpSDiv {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            136u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FDiv(OpFDiv {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            137u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UMod(OpUMod {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            138u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SRem(OpSRem {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            139u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SMod(OpSMod {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            140u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FRem(OpFRem {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            141u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FMod(OpFMod {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            164u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalEqual(OpLogicalEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            165u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalNotEqual(OpLogicalNotEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            166u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalOr(OpLogicalOr {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            167u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalAnd(OpLogicalAnd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            168u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalNot(OpLogicalNot {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            169u32 => {
                let (condition, words) = IdRef::spirv_parse(words, parse_state)?;
                let (object_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (object_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::Select(OpSelect {
                            id_result_type,
                            id_result,
                            condition,
                            object_1,
                            object_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            170u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::IEqual(OpIEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            171u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::INotEqual(OpINotEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            172u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UGreaterThan(OpUGreaterThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            173u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SGreaterThan(OpSGreaterThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            174u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UGreaterThanEqual(OpUGreaterThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            175u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SGreaterThanEqual(OpSGreaterThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            176u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ULessThan(OpULessThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            177u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SLessThan(OpSLessThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            178u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ULessThanEqual(OpULessThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            179u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SLessThanEqual(OpSLessThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            194u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ShiftRightLogical(OpShiftRightLogical {
                            id_result_type,
                            id_result,
                            base,
                            shift,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            195u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ShiftRightArithmetic(OpShiftRightArithmetic {
                            id_result_type,
                            id_result,
                            base,
                            shift,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            196u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ShiftLeftLogical(OpShiftLeftLogical {
                            id_result_type,
                            id_result,
                            base,
                            shift,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            197u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::BitwiseOr(OpBitwiseOr {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            198u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::BitwiseXor(OpBitwiseXor {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            199u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::BitwiseAnd(OpBitwiseAnd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            200u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::Not(OpNot {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            opcode => Err(Error::UnknownSpecConstantOpcode(opcode)),
        }
    }
}
pub const OPEN_CL_STD_VERSION: u32 = 100u32;
pub const OPEN_CL_STD_REVISION: u32 = 2u32;
pub const GLSL_STD_450_VERSION: u32 = 100u32;
pub const GLSL_STD_450_REVISION: u32 = 2u32;
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum ExtensionInstructionSet {
    OpenCLStd,
    GLSLStd450,
    Other(String),
}
impl<'a> From<Cow<'a, str>> for ExtensionInstructionSet {
    fn from(s: Cow<'a, str>) -> ExtensionInstructionSet {
        match s.as_ref() {
            "OpenCL.std" => return ExtensionInstructionSet::OpenCLStd,
            "GLSL.std.450" => return ExtensionInstructionSet::GLSLStd450,
            _ => {}
        }
        ExtensionInstructionSet::Other(s.into_owned())
    }
}
impl Deref for ExtensionInstructionSet {
    type Target = str;
    fn deref(&self) -> &str {
        match self {
            ExtensionInstructionSet::OpenCLStd => "OpenCL.std",
            ExtensionInstructionSet::GLSLStd450 => "GLSL.std.450",
            ExtensionInstructionSet::Other(s) => &**s,
        }
    }
}
impl AsRef<str> for ExtensionInstructionSet {
    fn as_ref(&self) -> &str {
        &**self
    }
}
impl From<ExtensionInstructionSet> for String {
    fn from(v: ExtensionInstructionSet) -> String {
        match v {
            ExtensionInstructionSet::Other(v) => v,
            v => String::from(v.as_ref()),
        }
    }
}
impl<'a> From<&'a str> for ExtensionInstructionSet {
    fn from(s: &'a str) -> Self {
        Cow::Borrowed(s).into()
    }
}
impl From<String> for ExtensionInstructionSet {
    fn from(s: String) -> Self {
        Self::from(Cow::Owned(s))
    }
}
impl fmt::Display for ExtensionInstructionSet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let s: &str = &**self;
        fmt::Display::fmt(s, f)
    }
}
#[cfg(test)]
mod input_file_tests {
    use sha2::{Digest, Sha256};
    use std::fs;
    use std::io::{BufRead, BufReader};
    use std::path::Path;
    #[doc = r" note: using lines() to prevent line-endings from affecting hash when checked out on windows vs. unix"]
    fn input_file_test(path: &str, digest: &[u8]) {
        let path = Path::new(env!("CARGO_MANIFEST_DIR")).join(path);
        println!("checking input file: {}", path.display());
        println!(
            "expected hash: {}",
            digest
                .iter()
                .map(|byte| format!("{:02X}", byte))
                .collect::<String>()
        );
        let file = fs::File::open(&path)
            .map_err(|err| format!("can't open file {}: {}", path.display(), err))
            .unwrap();
        let mut hasher = Sha256::new();
        for line in BufReader::new(file).lines() {
            hasher.input(line.unwrap());
            hasher.input(b"\n");
        }
        assert_eq!(digest, hasher.result().as_ref(), "hash doesn't match");
    }
    #[test]
    fn input_file_tests() {
        println!("checking that generated code is up to date -- update by running:");
        println!("cargo build --features=spirv-parser-generator");
        input_file_test ( "../spirv-parser-generator/src/ast.rs" , b"A\xDF\x03\xF41\xF3\xD2\xCB)\xF0\xB3\xB8t\xF9N\x1B\xDB\xAB\xE3\xAFq\x0BDu\x8E\xE1\xEF\xEARf\xEC\xF7" ) ;
        input_file_test ( "../spirv-parser-generator/src/generate.rs" , b"\xAFSnh\xC7\xD1\xDF\xFC0n\x9B\xA0\xA0\xE2g\x0F\xB7\x07\xC2\xE3\xBBW\x90\t<\xE5\xD5\xDF\x1E\xEA\xBD\xD8" ) ;
        input_file_test(
            "../spirv-parser-generator/src/lib.rs",
            b"\x888%yc\xB7\x1F5\xE8\xC6\xFDI\xA7\xA7e\xC4\x08\x91Ub\x07\0|\xF6j\x9C\xCA/\xF6Kb\xD0",
        );
        input_file_test ( "../spirv-parser-generator/src/util.rs" , b"\xB6\x92f\xB0*\x8D\xB4\xA7\xA0\x194\x12\xCC\xCDg\x8B\xDB\xB3\xCA\xF4\xE2)\xDE\xE3\x03Hw]\x13\xB1w\xEB" ) ;
        input_file_test ( "../spirv-parser-generator/Cargo.toml" , b"\xB2\xBB?\xE5\xB5\xB3\xED\x96]\x8Cj\xDDM+\xB0\xFB\xC9\xBB\xAB\xF8\tH\x02\xFF\xA7\x05\xD3\x0E\xDE\x98\r\x02" ) ;
        input_file_test ( "../external/SPIRV-Headers/include/spirv/unified1/spirv.core.grammar.json" , b"\xA0\xE8!\x91\xFBV\x81\x041Ra\xCB\xCE\r6\xBC\xCCD\xAE34\xECT\x82\xC0\x150S\x97\xEF\x06\xA5" ) ;
        input_file_test(
            "../external/SPIRV-Headers/include/spirv/unified1/extinst.opencl.std.100.grammar.json",
            b"\xB6\xBE2H\xAF\x8EaP3.\xC5\xD9\xDF.W\x8B6MX\x8Cv%3\x83\x1BuP\xF6\x07\xA7?\xF8",
        );
        input_file_test ( "../external/SPIRV-Headers/include/spirv/unified1/extinst.glsl.std.450.grammar.json" , b";\xCFx\xC1;q\xA9\xEB\xBAQ\xE8\x90\xC5_A\xA5\xE0\xF4{\xA2\x83\xBC|\x08\xFD~\x13D\xEA_G\xA6" ) ;
    }
}
