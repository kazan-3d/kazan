// automatically generated file -- update by running:
// cargo build --features=spirv-parser-generator
//
// Copyright (c) 2014-2016 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and/or associated documentation files (the "Materials"),
// to deal in the Materials without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Materials, and to permit persons to whom the
// Materials are furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Materials.
//
// MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
// STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
// HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
// IN THE MATERIALS.
use alloc::borrow::Cow;
use alloc::string::FromUtf8Error;
use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use core::mem;
use core::ops::Deref;
use core::result;
use core::str::Utf8Error;
macro_rules! split_fn {
    ($body:expr) => {
        (|| $body)()
    };
}
trait SPIRVParse: Sized {
    fn spirv_parse<'a>(words: &'a [u32], parse_state: &mut ParseState)
        -> Result<(Self, &'a [u32])>;
}
trait SPIRVDisplay {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result;
}
impl<T: SPIRVParse> SPIRVParse for Option<T> {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        if words.is_empty() {
            Ok((None, words))
        } else {
            let (value, words) = T::spirv_parse(words, parse_state)?;
            Ok((Some(value), words))
        }
    }
}
impl<T: SPIRVDisplay> SPIRVDisplay for Option<T> {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Some(v) => v.spirv_display(f),
            None => Ok(()),
        }
    }
}
impl<T: SPIRVParse> SPIRVParse for Vec<T> {
    fn spirv_parse<'a>(
        mut words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let mut retval = Vec::new();
        while !words.is_empty() {
            let result = T::spirv_parse(words, parse_state)?;
            words = result.1;
            retval.push(result.0);
        }
        Ok((retval, words))
    }
}
impl<T: SPIRVDisplay> SPIRVDisplay for Vec<T> {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for i in self {
            i.spirv_display(f)?;
        }
        Ok(())
    }
}
impl<A: SPIRVParse, B: SPIRVParse> SPIRVParse for (A, B) {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (a, words) = A::spirv_parse(words, parse_state)?;
        let (b, words) = B::spirv_parse(words, parse_state)?;
        Ok(((a, b), words))
    }
}
impl<A: SPIRVDisplay, B: SPIRVDisplay> SPIRVDisplay for (A, B) {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)?;
        self.1.spirv_display(f)
    }
}
const BYTES_PER_WORD: usize = 4;
struct ByteIterator<'a> {
    current_word: [u8; BYTES_PER_WORD],
    current_word_index: usize,
    words: &'a [u32],
}
impl<'a> ByteIterator<'a> {
    fn new(words: &'a [u32]) -> Self {
        Self {
            current_word: [0; BYTES_PER_WORD],
            current_word_index: BYTES_PER_WORD,
            words,
        }
    }
    fn take_unread_words(&mut self) -> &'a [u32] {
        mem::replace(&mut self.words, &[])
    }
}
impl<'a> Iterator for ByteIterator<'a> {
    type Item = u8;
    fn next(&mut self) -> Option<u8> {
        if self.current_word_index >= BYTES_PER_WORD {
            let (&current_word, words) = self.words.split_first()?;
            self.words = words;
            self.current_word = unsafe { mem::transmute(current_word.to_le()) };
            self.current_word_index = 0;
        }
        let byte = self.current_word[self.current_word_index];
        self.current_word_index += 1;
        Some(byte)
    }
}
impl SPIRVParse for String {
    fn spirv_parse<'a>(
        words: &'a [u32],
        _parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let mut byte_count_excluding_null_terminator = None;
        for (index, byte) in ByteIterator::new(words).enumerate() {
            if byte == 0 {
                byte_count_excluding_null_terminator = Some(index);
                break;
            }
        }
        let byte_count_excluding_null_terminator =
            byte_count_excluding_null_terminator.ok_or(Error::InstructionPrematurelyEnded)?;
        let mut bytes = Vec::with_capacity(byte_count_excluding_null_terminator);
        let mut byte_iter = ByteIterator::new(words);
        for _ in 0..byte_count_excluding_null_terminator {
            let byte = byte_iter.next().unwrap();
            bytes.push(byte);
        }
        let _null_terminator = byte_iter.next().unwrap();
        let words = byte_iter.take_unread_words();
        for v in byte_iter {
            if v != 0 {
                return Err(Error::InvalidStringTermination);
            }
        }
        assert_eq!(bytes.len(), byte_count_excluding_null_terminator);
        Ok((String::from_utf8(bytes)?, words))
    }
}
impl SPIRVDisplay for String {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {:?}", self)
    }
}
impl SPIRVParse for u32 {
    fn spirv_parse<'a>(
        words: &'a [u32],
        _parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (&value, words) = words
            .split_first()
            .ok_or(Error::InstructionPrematurelyEnded)?;
        Ok((value, words))
    }
}
impl SPIRVDisplay for u32 {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {}", self)
    }
}
impl SPIRVParse for u64 {
    fn spirv_parse<'a>(
        words: &'a [u32],
        _parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (&low, words) = words
            .split_first()
            .ok_or(Error::InstructionPrematurelyEnded)?;
        let (&high, words) = words
            .split_first()
            .ok_or(Error::InstructionPrematurelyEnded)?;
        Ok(((u64::from(high) << 32) | u64::from(low), words))
    }
}
impl SPIRVDisplay for u64 {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {}", self)
    }
}
impl SPIRVParse for IdRef {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (value, words) = u32::spirv_parse(words, parse_state)?;
        if value == 0 || value as usize >= parse_state.id_states.len() {
            Err(Error::IdOutOfBounds(value))
        } else {
            Ok((IdRef(value), words))
        }
    }
}
impl SPIRVDisplay for IdRef {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, " {}", self)
    }
}
pub const MAGIC_NUMBER: u32 = 119734787u32;
pub const MAJOR_VERSION: u32 = 1u32;
pub const MINOR_VERSION: u32 = 5u32;
pub const REVISION: u32 = 1u32;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperands {
    pub bias: Option<ImageOperandsBias>,
    pub lod: Option<ImageOperandsLod>,
    pub grad: Option<ImageOperandsGrad>,
    pub const_offset: Option<ImageOperandsConstOffset>,
    pub offset: Option<ImageOperandsOffset>,
    pub const_offsets: Option<ImageOperandsConstOffsets>,
    pub sample: Option<ImageOperandsSample>,
    pub min_lod: Option<ImageOperandsMinLod>,
    pub make_texel_available: Option<ImageOperandsMakeTexelAvailable>,
    pub make_texel_available_khr: Option<ImageOperandsMakeTexelAvailableKHR>,
    pub make_texel_visible: Option<ImageOperandsMakeTexelVisible>,
    pub make_texel_visible_khr: Option<ImageOperandsMakeTexelVisibleKHR>,
    pub non_private_texel: Option<ImageOperandsNonPrivateTexel>,
    pub non_private_texel_khr: Option<ImageOperandsNonPrivateTexelKHR>,
    pub volatile_texel: Option<ImageOperandsVolatileTexel>,
    pub volatile_texel_khr: Option<ImageOperandsVolatileTexelKHR>,
    pub sign_extend: Option<ImageOperandsSignExtend>,
    pub zero_extend: Option<ImageOperandsZeroExtend>,
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsBias(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsLod(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsGrad(pub IdRef, pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsConstOffset(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsOffset(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsConstOffsets(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsSample(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMinLod(pub IdRef);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelAvailable(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelAvailableKHR(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelVisible(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsMakeTexelVisibleKHR(pub IdScope);
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsNonPrivateTexel;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsNonPrivateTexelKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsVolatileTexel;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsVolatileTexelKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsSignExtend;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct ImageOperandsZeroExtend;
impl SPIRVParse for ImageOperands {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (bias, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsBias(parameter_0)), words)
        } else {
            (None, words)
        };
        let (lod, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsLod(parameter_0)), words)
        } else {
            (None, words)
        };
        let (grad, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            let (parameter_1, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsGrad(parameter_0, parameter_1)), words)
        } else {
            (None, words)
        };
        let (const_offset, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsConstOffset(parameter_0)), words)
        } else {
            (None, words)
        };
        let (offset, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsOffset(parameter_0)), words)
        } else {
            (None, words)
        };
        let (const_offsets, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsConstOffsets(parameter_0)), words)
        } else {
            (None, words)
        };
        let (sample, words) = if (mask & 64u32) != 0 {
            mask &= !64u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsSample(parameter_0)), words)
        } else {
            (None, words)
        };
        let (min_lod, words) = if (mask & 128u32) != 0 {
            mask &= !128u32;
            let (parameter_0, words) = IdRef::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMinLod(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_available, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelAvailable(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_available_khr, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelAvailableKHR(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_visible, words) = if (mask & 512u32) != 0 {
            mask &= !512u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelVisible(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_texel_visible_khr, words) = if (mask & 512u32) != 0 {
            mask &= !512u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(ImageOperandsMakeTexelVisibleKHR(parameter_0)), words)
        } else {
            (None, words)
        };
        let (non_private_texel, words) = if (mask & 1024u32) != 0 {
            mask &= !1024u32;
            (Some(ImageOperandsNonPrivateTexel), words)
        } else {
            (None, words)
        };
        let (non_private_texel_khr, words) = if (mask & 1024u32) != 0 {
            mask &= !1024u32;
            (Some(ImageOperandsNonPrivateTexelKHR), words)
        } else {
            (None, words)
        };
        let (volatile_texel, words) = if (mask & 2048u32) != 0 {
            mask &= !2048u32;
            (Some(ImageOperandsVolatileTexel), words)
        } else {
            (None, words)
        };
        let (volatile_texel_khr, words) = if (mask & 2048u32) != 0 {
            mask &= !2048u32;
            (Some(ImageOperandsVolatileTexelKHR), words)
        } else {
            (None, words)
        };
        let (sign_extend, words) = if (mask & 4096u32) != 0 {
            mask &= !4096u32;
            (Some(ImageOperandsSignExtend), words)
        } else {
            (None, words)
        };
        let (zero_extend, words) = if (mask & 8192u32) != 0 {
            mask &= !8192u32;
            (Some(ImageOperandsZeroExtend), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    bias,
                    lod,
                    grad,
                    const_offset,
                    offset,
                    const_offsets,
                    sample,
                    min_lod,
                    make_texel_available,
                    make_texel_available_khr,
                    make_texel_visible,
                    make_texel_visible_khr,
                    non_private_texel,
                    non_private_texel_khr,
                    volatile_texel,
                    volatile_texel_khr,
                    sign_extend,
                    zero_extend,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for ImageOperands {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.bias.is_some() {
            if any_members {
                write!(f, "|{}", "Bias")?;
            } else {
                write!(f, " {}", "Bias")?;
                any_members = true;
            }
        }
        if self.lod.is_some() {
            if any_members {
                write!(f, "|{}", "Lod")?;
            } else {
                write!(f, " {}", "Lod")?;
                any_members = true;
            }
        }
        if self.grad.is_some() {
            if any_members {
                write!(f, "|{}", "Grad")?;
            } else {
                write!(f, " {}", "Grad")?;
                any_members = true;
            }
        }
        if self.const_offset.is_some() {
            if any_members {
                write!(f, "|{}", "ConstOffset")?;
            } else {
                write!(f, " {}", "ConstOffset")?;
                any_members = true;
            }
        }
        if self.offset.is_some() {
            if any_members {
                write!(f, "|{}", "Offset")?;
            } else {
                write!(f, " {}", "Offset")?;
                any_members = true;
            }
        }
        if self.const_offsets.is_some() {
            if any_members {
                write!(f, "|{}", "ConstOffsets")?;
            } else {
                write!(f, " {}", "ConstOffsets")?;
                any_members = true;
            }
        }
        if self.sample.is_some() {
            if any_members {
                write!(f, "|{}", "Sample")?;
            } else {
                write!(f, " {}", "Sample")?;
                any_members = true;
            }
        }
        if self.min_lod.is_some() {
            if any_members {
                write!(f, "|{}", "MinLod")?;
            } else {
                write!(f, " {}", "MinLod")?;
                any_members = true;
            }
        }
        if self.make_texel_available.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelAvailable")?;
            } else {
                write!(f, " {}", "MakeTexelAvailable")?;
                any_members = true;
            }
        }
        if self.make_texel_available_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelAvailableKHR")?;
            } else {
                write!(f, " {}", "MakeTexelAvailableKHR")?;
                any_members = true;
            }
        }
        if self.make_texel_visible.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelVisible")?;
            } else {
                write!(f, " {}", "MakeTexelVisible")?;
                any_members = true;
            }
        }
        if self.make_texel_visible_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeTexelVisibleKHR")?;
            } else {
                write!(f, " {}", "MakeTexelVisibleKHR")?;
                any_members = true;
            }
        }
        if self.non_private_texel.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivateTexel")?;
            } else {
                write!(f, " {}", "NonPrivateTexel")?;
                any_members = true;
            }
        }
        if self.non_private_texel_khr.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivateTexelKHR")?;
            } else {
                write!(f, " {}", "NonPrivateTexelKHR")?;
                any_members = true;
            }
        }
        if self.volatile_texel.is_some() {
            if any_members {
                write!(f, "|{}", "VolatileTexel")?;
            } else {
                write!(f, " {}", "VolatileTexel")?;
                any_members = true;
            }
        }
        if self.volatile_texel_khr.is_some() {
            if any_members {
                write!(f, "|{}", "VolatileTexelKHR")?;
            } else {
                write!(f, " {}", "VolatileTexelKHR")?;
                any_members = true;
            }
        }
        if self.sign_extend.is_some() {
            if any_members {
                write!(f, "|{}", "SignExtend")?;
            } else {
                write!(f, " {}", "SignExtend")?;
                any_members = true;
            }
        }
        if self.zero_extend.is_some() {
            if any_members {
                write!(f, "|{}", "ZeroExtend")?;
            } else {
                write!(f, " {}", "ZeroExtend")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        if let Some(ImageOperandsBias(parameter_0)) = &self.bias {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsLod(parameter_0)) = &self.lod {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsGrad(parameter_0, parameter_1)) = &self.grad {
            parameter_0.spirv_display(f)?;
            parameter_1.spirv_display(f)?;
        }
        if let Some(ImageOperandsConstOffset(parameter_0)) = &self.const_offset {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsOffset(parameter_0)) = &self.offset {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsConstOffsets(parameter_0)) = &self.const_offsets {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsSample(parameter_0)) = &self.sample {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMinLod(parameter_0)) = &self.min_lod {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelAvailable(parameter_0)) = &self.make_texel_available {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelAvailableKHR(parameter_0)) =
            &self.make_texel_available_khr
        {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelVisible(parameter_0)) = &self.make_texel_visible {
            parameter_0.spirv_display(f)?;
        }
        if let Some(ImageOperandsMakeTexelVisibleKHR(parameter_0)) = &self.make_texel_visible_khr {
            parameter_0.spirv_display(f)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathMode {
    pub not_nan: Option<FPFastMathModeNotNaN>,
    pub not_inf: Option<FPFastMathModeNotInf>,
    pub nsz: Option<FPFastMathModeNSZ>,
    pub allow_recip: Option<FPFastMathModeAllowRecip>,
    pub fast: Option<FPFastMathModeFast>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeNotNaN;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeNotInf;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeNSZ;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeAllowRecip;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FPFastMathModeFast;
impl SPIRVParse for FPFastMathMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (not_nan, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(FPFastMathModeNotNaN), words)
        } else {
            (None, words)
        };
        let (not_inf, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(FPFastMathModeNotInf), words)
        } else {
            (None, words)
        };
        let (nsz, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(FPFastMathModeNSZ), words)
        } else {
            (None, words)
        };
        let (allow_recip, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            (Some(FPFastMathModeAllowRecip), words)
        } else {
            (None, words)
        };
        let (fast, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            (Some(FPFastMathModeFast), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    not_nan,
                    not_inf,
                    nsz,
                    allow_recip,
                    fast,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for FPFastMathMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.not_nan.is_some() {
            if any_members {
                write!(f, "|{}", "NotNaN")?;
            } else {
                write!(f, " {}", "NotNaN")?;
                any_members = true;
            }
        }
        if self.not_inf.is_some() {
            if any_members {
                write!(f, "|{}", "NotInf")?;
            } else {
                write!(f, " {}", "NotInf")?;
                any_members = true;
            }
        }
        if self.nsz.is_some() {
            if any_members {
                write!(f, "|{}", "NSZ")?;
            } else {
                write!(f, " {}", "NSZ")?;
                any_members = true;
            }
        }
        if self.allow_recip.is_some() {
            if any_members {
                write!(f, "|{}", "AllowRecip")?;
            } else {
                write!(f, " {}", "AllowRecip")?;
                any_members = true;
            }
        }
        if self.fast.is_some() {
            if any_members {
                write!(f, "|{}", "Fast")?;
            } else {
                write!(f, " {}", "Fast")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct SelectionControl {
    pub flatten: Option<SelectionControlFlatten>,
    pub dont_flatten: Option<SelectionControlDontFlatten>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct SelectionControlFlatten;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct SelectionControlDontFlatten;
impl SPIRVParse for SelectionControl {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (flatten, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(SelectionControlFlatten), words)
        } else {
            (None, words)
        };
        let (dont_flatten, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(SelectionControlDontFlatten), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    flatten,
                    dont_flatten,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for SelectionControl {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.flatten.is_some() {
            if any_members {
                write!(f, "|{}", "Flatten")?;
            } else {
                write!(f, " {}", "Flatten")?;
                any_members = true;
            }
        }
        if self.dont_flatten.is_some() {
            if any_members {
                write!(f, "|{}", "DontFlatten")?;
            } else {
                write!(f, " {}", "DontFlatten")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControl {
    pub unroll: Option<LoopControlUnroll>,
    pub dont_unroll: Option<LoopControlDontUnroll>,
    pub dependency_infinite: Option<LoopControlDependencyInfinite>,
    pub dependency_length: Option<LoopControlDependencyLength>,
    pub min_iterations: Option<LoopControlMinIterations>,
    pub max_iterations: Option<LoopControlMaxIterations>,
    pub iteration_multiple: Option<LoopControlIterationMultiple>,
    pub peel_count: Option<LoopControlPeelCount>,
    pub partial_count: Option<LoopControlPartialCount>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlUnroll;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlDontUnroll;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlDependencyInfinite;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlDependencyLength(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlMinIterations(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlMaxIterations(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlIterationMultiple(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlPeelCount(pub LiteralInteger32);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct LoopControlPartialCount(pub LiteralInteger32);
impl SPIRVParse for LoopControl {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (unroll, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(LoopControlUnroll), words)
        } else {
            (None, words)
        };
        let (dont_unroll, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(LoopControlDontUnroll), words)
        } else {
            (None, words)
        };
        let (dependency_infinite, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(LoopControlDependencyInfinite), words)
        } else {
            (None, words)
        };
        let (dependency_length, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlDependencyLength(parameter_0)), words)
        } else {
            (None, words)
        };
        let (min_iterations, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlMinIterations(parameter_0)), words)
        } else {
            (None, words)
        };
        let (max_iterations, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlMaxIterations(parameter_0)), words)
        } else {
            (None, words)
        };
        let (iteration_multiple, words) = if (mask & 64u32) != 0 {
            mask &= !64u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlIterationMultiple(parameter_0)), words)
        } else {
            (None, words)
        };
        let (peel_count, words) = if (mask & 128u32) != 0 {
            mask &= !128u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlPeelCount(parameter_0)), words)
        } else {
            (None, words)
        };
        let (partial_count, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(LoopControlPartialCount(parameter_0)), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    unroll,
                    dont_unroll,
                    dependency_infinite,
                    dependency_length,
                    min_iterations,
                    max_iterations,
                    iteration_multiple,
                    peel_count,
                    partial_count,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for LoopControl {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.unroll.is_some() {
            if any_members {
                write!(f, "|{}", "Unroll")?;
            } else {
                write!(f, " {}", "Unroll")?;
                any_members = true;
            }
        }
        if self.dont_unroll.is_some() {
            if any_members {
                write!(f, "|{}", "DontUnroll")?;
            } else {
                write!(f, " {}", "DontUnroll")?;
                any_members = true;
            }
        }
        if self.dependency_infinite.is_some() {
            if any_members {
                write!(f, "|{}", "DependencyInfinite")?;
            } else {
                write!(f, " {}", "DependencyInfinite")?;
                any_members = true;
            }
        }
        if self.dependency_length.is_some() {
            if any_members {
                write!(f, "|{}", "DependencyLength")?;
            } else {
                write!(f, " {}", "DependencyLength")?;
                any_members = true;
            }
        }
        if self.min_iterations.is_some() {
            if any_members {
                write!(f, "|{}", "MinIterations")?;
            } else {
                write!(f, " {}", "MinIterations")?;
                any_members = true;
            }
        }
        if self.max_iterations.is_some() {
            if any_members {
                write!(f, "|{}", "MaxIterations")?;
            } else {
                write!(f, " {}", "MaxIterations")?;
                any_members = true;
            }
        }
        if self.iteration_multiple.is_some() {
            if any_members {
                write!(f, "|{}", "IterationMultiple")?;
            } else {
                write!(f, " {}", "IterationMultiple")?;
                any_members = true;
            }
        }
        if self.peel_count.is_some() {
            if any_members {
                write!(f, "|{}", "PeelCount")?;
            } else {
                write!(f, " {}", "PeelCount")?;
                any_members = true;
            }
        }
        if self.partial_count.is_some() {
            if any_members {
                write!(f, "|{}", "PartialCount")?;
            } else {
                write!(f, " {}", "PartialCount")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        if let Some(LoopControlDependencyLength(parameter_0)) = &self.dependency_length {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlMinIterations(parameter_0)) = &self.min_iterations {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlMaxIterations(parameter_0)) = &self.max_iterations {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlIterationMultiple(parameter_0)) = &self.iteration_multiple {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlPeelCount(parameter_0)) = &self.peel_count {
            parameter_0.spirv_display(f)?;
        }
        if let Some(LoopControlPartialCount(parameter_0)) = &self.partial_count {
            parameter_0.spirv_display(f)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControl {
    pub inline: Option<FunctionControlInline>,
    pub dont_inline: Option<FunctionControlDontInline>,
    pub pure_: Option<FunctionControlPure>,
    pub const_: Option<FunctionControlConst>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlInline;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlDontInline;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlPure;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct FunctionControlConst;
impl SPIRVParse for FunctionControl {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (inline, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(FunctionControlInline), words)
        } else {
            (None, words)
        };
        let (dont_inline, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(FunctionControlDontInline), words)
        } else {
            (None, words)
        };
        let (pure_, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(FunctionControlPure), words)
        } else {
            (None, words)
        };
        let (const_, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            (Some(FunctionControlConst), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    inline,
                    dont_inline,
                    pure_,
                    const_,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for FunctionControl {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.inline.is_some() {
            if any_members {
                write!(f, "|{}", "Inline")?;
            } else {
                write!(f, " {}", "Inline")?;
                any_members = true;
            }
        }
        if self.dont_inline.is_some() {
            if any_members {
                write!(f, "|{}", "DontInline")?;
            } else {
                write!(f, " {}", "DontInline")?;
                any_members = true;
            }
        }
        if self.pure_.is_some() {
            if any_members {
                write!(f, "|{}", "Pure")?;
            } else {
                write!(f, " {}", "Pure")?;
                any_members = true;
            }
        }
        if self.const_.is_some() {
            if any_members {
                write!(f, "|{}", "Const")?;
            } else {
                write!(f, " {}", "Const")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemantics {
    pub acquire: Option<MemorySemanticsAcquire>,
    pub release: Option<MemorySemanticsRelease>,
    pub acquire_release: Option<MemorySemanticsAcquireRelease>,
    pub sequentially_consistent: Option<MemorySemanticsSequentiallyConsistent>,
    pub uniform_memory: Option<MemorySemanticsUniformMemory>,
    pub subgroup_memory: Option<MemorySemanticsSubgroupMemory>,
    pub workgroup_memory: Option<MemorySemanticsWorkgroupMemory>,
    pub cross_workgroup_memory: Option<MemorySemanticsCrossWorkgroupMemory>,
    pub atomic_counter_memory: Option<MemorySemanticsAtomicCounterMemory>,
    pub image_memory: Option<MemorySemanticsImageMemory>,
    pub output_memory: Option<MemorySemanticsOutputMemory>,
    pub output_memory_khr: Option<MemorySemanticsOutputMemoryKHR>,
    pub make_available: Option<MemorySemanticsMakeAvailable>,
    pub make_available_khr: Option<MemorySemanticsMakeAvailableKHR>,
    pub make_visible: Option<MemorySemanticsMakeVisible>,
    pub make_visible_khr: Option<MemorySemanticsMakeVisibleKHR>,
    pub volatile: Option<MemorySemanticsVolatile>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsAcquire;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsRelease;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsAcquireRelease;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsSequentiallyConsistent;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsUniformMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsSubgroupMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsWorkgroupMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsCrossWorkgroupMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsAtomicCounterMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsImageMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsOutputMemory;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsOutputMemoryKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeAvailable;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeAvailableKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeVisible;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsMakeVisibleKHR;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemorySemanticsVolatile;
impl SPIRVParse for MemorySemantics {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (acquire, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            (Some(MemorySemanticsAcquire), words)
        } else {
            (None, words)
        };
        let (release, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(MemorySemanticsRelease), words)
        } else {
            (None, words)
        };
        let (acquire_release, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            (Some(MemorySemanticsAcquireRelease), words)
        } else {
            (None, words)
        };
        let (sequentially_consistent, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            (Some(MemorySemanticsSequentiallyConsistent), words)
        } else {
            (None, words)
        };
        let (uniform_memory, words) = if (mask & 64u32) != 0 {
            mask &= !64u32;
            (Some(MemorySemanticsUniformMemory), words)
        } else {
            (None, words)
        };
        let (subgroup_memory, words) = if (mask & 128u32) != 0 {
            mask &= !128u32;
            (Some(MemorySemanticsSubgroupMemory), words)
        } else {
            (None, words)
        };
        let (workgroup_memory, words) = if (mask & 256u32) != 0 {
            mask &= !256u32;
            (Some(MemorySemanticsWorkgroupMemory), words)
        } else {
            (None, words)
        };
        let (cross_workgroup_memory, words) = if (mask & 512u32) != 0 {
            mask &= !512u32;
            (Some(MemorySemanticsCrossWorkgroupMemory), words)
        } else {
            (None, words)
        };
        let (atomic_counter_memory, words) = if (mask & 1024u32) != 0 {
            mask &= !1024u32;
            (Some(MemorySemanticsAtomicCounterMemory), words)
        } else {
            (None, words)
        };
        let (image_memory, words) = if (mask & 2048u32) != 0 {
            mask &= !2048u32;
            (Some(MemorySemanticsImageMemory), words)
        } else {
            (None, words)
        };
        let (output_memory, words) = if (mask & 4096u32) != 0 {
            mask &= !4096u32;
            (Some(MemorySemanticsOutputMemory), words)
        } else {
            (None, words)
        };
        let (output_memory_khr, words) = if (mask & 4096u32) != 0 {
            mask &= !4096u32;
            (Some(MemorySemanticsOutputMemoryKHR), words)
        } else {
            (None, words)
        };
        let (make_available, words) = if (mask & 8192u32) != 0 {
            mask &= !8192u32;
            (Some(MemorySemanticsMakeAvailable), words)
        } else {
            (None, words)
        };
        let (make_available_khr, words) = if (mask & 8192u32) != 0 {
            mask &= !8192u32;
            (Some(MemorySemanticsMakeAvailableKHR), words)
        } else {
            (None, words)
        };
        let (make_visible, words) = if (mask & 16384u32) != 0 {
            mask &= !16384u32;
            (Some(MemorySemanticsMakeVisible), words)
        } else {
            (None, words)
        };
        let (make_visible_khr, words) = if (mask & 16384u32) != 0 {
            mask &= !16384u32;
            (Some(MemorySemanticsMakeVisibleKHR), words)
        } else {
            (None, words)
        };
        let (volatile, words) = if (mask & 32768u32) != 0 {
            mask &= !32768u32;
            (Some(MemorySemanticsVolatile), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    acquire,
                    release,
                    acquire_release,
                    sequentially_consistent,
                    uniform_memory,
                    subgroup_memory,
                    workgroup_memory,
                    cross_workgroup_memory,
                    atomic_counter_memory,
                    image_memory,
                    output_memory,
                    output_memory_khr,
                    make_available,
                    make_available_khr,
                    make_visible,
                    make_visible_khr,
                    volatile,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for MemorySemantics {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.acquire.is_some() {
            if any_members {
                write!(f, "|{}", "Acquire")?;
            } else {
                write!(f, " {}", "Acquire")?;
                any_members = true;
            }
        }
        if self.release.is_some() {
            if any_members {
                write!(f, "|{}", "Release")?;
            } else {
                write!(f, " {}", "Release")?;
                any_members = true;
            }
        }
        if self.acquire_release.is_some() {
            if any_members {
                write!(f, "|{}", "AcquireRelease")?;
            } else {
                write!(f, " {}", "AcquireRelease")?;
                any_members = true;
            }
        }
        if self.sequentially_consistent.is_some() {
            if any_members {
                write!(f, "|{}", "SequentiallyConsistent")?;
            } else {
                write!(f, " {}", "SequentiallyConsistent")?;
                any_members = true;
            }
        }
        if self.uniform_memory.is_some() {
            if any_members {
                write!(f, "|{}", "UniformMemory")?;
            } else {
                write!(f, " {}", "UniformMemory")?;
                any_members = true;
            }
        }
        if self.subgroup_memory.is_some() {
            if any_members {
                write!(f, "|{}", "SubgroupMemory")?;
            } else {
                write!(f, " {}", "SubgroupMemory")?;
                any_members = true;
            }
        }
        if self.workgroup_memory.is_some() {
            if any_members {
                write!(f, "|{}", "WorkgroupMemory")?;
            } else {
                write!(f, " {}", "WorkgroupMemory")?;
                any_members = true;
            }
        }
        if self.cross_workgroup_memory.is_some() {
            if any_members {
                write!(f, "|{}", "CrossWorkgroupMemory")?;
            } else {
                write!(f, " {}", "CrossWorkgroupMemory")?;
                any_members = true;
            }
        }
        if self.atomic_counter_memory.is_some() {
            if any_members {
                write!(f, "|{}", "AtomicCounterMemory")?;
            } else {
                write!(f, " {}", "AtomicCounterMemory")?;
                any_members = true;
            }
        }
        if self.image_memory.is_some() {
            if any_members {
                write!(f, "|{}", "ImageMemory")?;
            } else {
                write!(f, " {}", "ImageMemory")?;
                any_members = true;
            }
        }
        if self.output_memory.is_some() {
            if any_members {
                write!(f, "|{}", "OutputMemory")?;
            } else {
                write!(f, " {}", "OutputMemory")?;
                any_members = true;
            }
        }
        if self.output_memory_khr.is_some() {
            if any_members {
                write!(f, "|{}", "OutputMemoryKHR")?;
            } else {
                write!(f, " {}", "OutputMemoryKHR")?;
                any_members = true;
            }
        }
        if self.make_available.is_some() {
            if any_members {
                write!(f, "|{}", "MakeAvailable")?;
            } else {
                write!(f, " {}", "MakeAvailable")?;
                any_members = true;
            }
        }
        if self.make_available_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeAvailableKHR")?;
            } else {
                write!(f, " {}", "MakeAvailableKHR")?;
                any_members = true;
            }
        }
        if self.make_visible.is_some() {
            if any_members {
                write!(f, "|{}", "MakeVisible")?;
            } else {
                write!(f, " {}", "MakeVisible")?;
                any_members = true;
            }
        }
        if self.make_visible_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakeVisibleKHR")?;
            } else {
                write!(f, " {}", "MakeVisibleKHR")?;
                any_members = true;
            }
        }
        if self.volatile.is_some() {
            if any_members {
                write!(f, "|{}", "Volatile")?;
            } else {
                write!(f, " {}", "Volatile")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccess {
    pub volatile: Option<MemoryAccessVolatile>,
    pub aligned: Option<MemoryAccessAligned>,
    pub nontemporal: Option<MemoryAccessNontemporal>,
    pub make_pointer_available: Option<MemoryAccessMakePointerAvailable>,
    pub make_pointer_available_khr: Option<MemoryAccessMakePointerAvailableKHR>,
    pub make_pointer_visible: Option<MemoryAccessMakePointerVisible>,
    pub make_pointer_visible_khr: Option<MemoryAccessMakePointerVisibleKHR>,
    pub non_private_pointer: Option<MemoryAccessNonPrivatePointer>,
    pub non_private_pointer_khr: Option<MemoryAccessNonPrivatePointerKHR>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessVolatile;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessAligned(pub LiteralInteger32);
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessNontemporal;
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerAvailable(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerAvailableKHR(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerVisible(pub IdScope);
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessMakePointerVisibleKHR(pub IdScope);
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessNonPrivatePointer;
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct MemoryAccessNonPrivatePointerKHR;
impl SPIRVParse for MemoryAccess {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (volatile, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(MemoryAccessVolatile), words)
        } else {
            (None, words)
        };
        let (aligned, words) = if (mask & 2u32) != 0 {
            mask &= !2u32;
            let (parameter_0, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessAligned(parameter_0)), words)
        } else {
            (None, words)
        };
        let (nontemporal, words) = if (mask & 4u32) != 0 {
            mask &= !4u32;
            (Some(MemoryAccessNontemporal), words)
        } else {
            (None, words)
        };
        let (make_pointer_available, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessMakePointerAvailable(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_pointer_available_khr, words) = if (mask & 8u32) != 0 {
            mask &= !8u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (
                Some(MemoryAccessMakePointerAvailableKHR(parameter_0)),
                words,
            )
        } else {
            (None, words)
        };
        let (make_pointer_visible, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessMakePointerVisible(parameter_0)), words)
        } else {
            (None, words)
        };
        let (make_pointer_visible_khr, words) = if (mask & 16u32) != 0 {
            mask &= !16u32;
            let (parameter_0, words) = IdScope::spirv_parse(words, parse_state)?;
            (Some(MemoryAccessMakePointerVisibleKHR(parameter_0)), words)
        } else {
            (None, words)
        };
        let (non_private_pointer, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            (Some(MemoryAccessNonPrivatePointer), words)
        } else {
            (None, words)
        };
        let (non_private_pointer_khr, words) = if (mask & 32u32) != 0 {
            mask &= !32u32;
            (Some(MemoryAccessNonPrivatePointerKHR), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((
                Self {
                    volatile,
                    aligned,
                    nontemporal,
                    make_pointer_available,
                    make_pointer_available_khr,
                    make_pointer_visible,
                    make_pointer_visible_khr,
                    non_private_pointer,
                    non_private_pointer_khr,
                },
                words,
            ))
        }
    }
}
impl SPIRVDisplay for MemoryAccess {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.volatile.is_some() {
            if any_members {
                write!(f, "|{}", "Volatile")?;
            } else {
                write!(f, " {}", "Volatile")?;
                any_members = true;
            }
        }
        if self.aligned.is_some() {
            if any_members {
                write!(f, "|{}", "Aligned")?;
            } else {
                write!(f, " {}", "Aligned")?;
                any_members = true;
            }
        }
        if self.nontemporal.is_some() {
            if any_members {
                write!(f, "|{}", "Nontemporal")?;
            } else {
                write!(f, " {}", "Nontemporal")?;
                any_members = true;
            }
        }
        if self.make_pointer_available.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerAvailable")?;
            } else {
                write!(f, " {}", "MakePointerAvailable")?;
                any_members = true;
            }
        }
        if self.make_pointer_available_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerAvailableKHR")?;
            } else {
                write!(f, " {}", "MakePointerAvailableKHR")?;
                any_members = true;
            }
        }
        if self.make_pointer_visible.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerVisible")?;
            } else {
                write!(f, " {}", "MakePointerVisible")?;
                any_members = true;
            }
        }
        if self.make_pointer_visible_khr.is_some() {
            if any_members {
                write!(f, "|{}", "MakePointerVisibleKHR")?;
            } else {
                write!(f, " {}", "MakePointerVisibleKHR")?;
                any_members = true;
            }
        }
        if self.non_private_pointer.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivatePointer")?;
            } else {
                write!(f, " {}", "NonPrivatePointer")?;
                any_members = true;
            }
        }
        if self.non_private_pointer_khr.is_some() {
            if any_members {
                write!(f, "|{}", "NonPrivatePointerKHR")?;
            } else {
                write!(f, " {}", "NonPrivatePointerKHR")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        if let Some(MemoryAccessAligned(parameter_0)) = &self.aligned {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerAvailable(parameter_0)) = &self.make_pointer_available {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerAvailableKHR(parameter_0)) =
            &self.make_pointer_available_khr
        {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerVisible(parameter_0)) = &self.make_pointer_visible {
            parameter_0.spirv_display(f)?;
        }
        if let Some(MemoryAccessMakePointerVisibleKHR(parameter_0)) = &self.make_pointer_visible_khr
        {
            parameter_0.spirv_display(f)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct KernelProfilingInfo {
    pub cmd_exec_time: Option<KernelProfilingInfoCmdExecTime>,
}
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
pub struct KernelProfilingInfoCmdExecTime;
impl SPIRVParse for KernelProfilingInfo {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (mut mask, words) = u32::spirv_parse(words, parse_state)?;
        let (cmd_exec_time, words) = if (mask & 1u32) != 0 {
            mask &= !1u32;
            (Some(KernelProfilingInfoCmdExecTime), words)
        } else {
            (None, words)
        };
        if mask != 0 {
            Err(Error::InvalidEnumValue)
        } else {
            Ok((Self { cmd_exec_time }, words))
        }
    }
}
impl SPIRVDisplay for KernelProfilingInfo {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut any_members = false;
        if self.cmd_exec_time.is_some() {
            if any_members {
                write!(f, "|{}", "CmdExecTime")?;
            } else {
                write!(f, " {}", "CmdExecTime")?;
                any_members = true;
            }
        }
        if !any_members {
            write!(f, " {}", "None")?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum SourceLanguage {
    Unknown,
    ESSL,
    GLSL,
    OpenCLC,
    OpenCLCPP,
    HLSL,
}
impl SPIRVParse for SourceLanguage {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((SourceLanguage::Unknown, words)),
            1u32 => Ok((SourceLanguage::ESSL, words)),
            2u32 => Ok((SourceLanguage::GLSL, words)),
            3u32 => Ok((SourceLanguage::OpenCLC, words)),
            4u32 => Ok((SourceLanguage::OpenCLCPP, words)),
            5u32 => Ok((SourceLanguage::HLSL, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for SourceLanguage {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SourceLanguage::Unknown => write!(f, " {}", "Unknown"),
            SourceLanguage::ESSL => write!(f, " {}", "ESSL"),
            SourceLanguage::GLSL => write!(f, " {}", "GLSL"),
            SourceLanguage::OpenCLC => write!(f, " {}", "OpenCL_C"),
            SourceLanguage::OpenCLCPP => write!(f, " {}", "OpenCL_CPP"),
            SourceLanguage::HLSL => write!(f, " {}", "HLSL"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ExecutionModel {
    Vertex,
    TessellationControl,
    TessellationEvaluation,
    Geometry,
    Fragment,
    GLCompute,
    Kernel,
}
impl SPIRVParse for ExecutionModel {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ExecutionModel::Vertex, words)),
            1u32 => Ok((ExecutionModel::TessellationControl, words)),
            2u32 => Ok((ExecutionModel::TessellationEvaluation, words)),
            3u32 => Ok((ExecutionModel::Geometry, words)),
            4u32 => Ok((ExecutionModel::Fragment, words)),
            5u32 => Ok((ExecutionModel::GLCompute, words)),
            6u32 => Ok((ExecutionModel::Kernel, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ExecutionModel {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ExecutionModel::Vertex => write!(f, " {}", "Vertex"),
            ExecutionModel::TessellationControl => write!(f, " {}", "TessellationControl"),
            ExecutionModel::TessellationEvaluation => write!(f, " {}", "TessellationEvaluation"),
            ExecutionModel::Geometry => write!(f, " {}", "Geometry"),
            ExecutionModel::Fragment => write!(f, " {}", "Fragment"),
            ExecutionModel::GLCompute => write!(f, " {}", "GLCompute"),
            ExecutionModel::Kernel => write!(f, " {}", "Kernel"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum AddressingModel {
    Logical,
    Physical32,
    Physical64,
    PhysicalStorageBuffer64,
}
impl SPIRVParse for AddressingModel {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((AddressingModel::Logical, words)),
            1u32 => Ok((AddressingModel::Physical32, words)),
            2u32 => Ok((AddressingModel::Physical64, words)),
            5348u32 => Ok((AddressingModel::PhysicalStorageBuffer64, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for AddressingModel {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AddressingModel::Logical => write!(f, " {}", "Logical"),
            AddressingModel::Physical32 => write!(f, " {}", "Physical32"),
            AddressingModel::Physical64 => write!(f, " {}", "Physical64"),
            AddressingModel::PhysicalStorageBuffer64 => write!(f, " {}", "PhysicalStorageBuffer64"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum MemoryModel {
    Simple,
    GLSL450,
    OpenCL,
    Vulkan,
}
impl SPIRVParse for MemoryModel {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((MemoryModel::Simple, words)),
            1u32 => Ok((MemoryModel::GLSL450, words)),
            2u32 => Ok((MemoryModel::OpenCL, words)),
            3u32 => Ok((MemoryModel::Vulkan, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for MemoryModel {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MemoryModel::Simple => write!(f, " {}", "Simple"),
            MemoryModel::GLSL450 => write!(f, " {}", "GLSL450"),
            MemoryModel::OpenCL => write!(f, " {}", "OpenCL"),
            MemoryModel::Vulkan => write!(f, " {}", "Vulkan"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub enum ExecutionMode {
    Invocations {
        number_of_invocation_invocations: LiteralInteger32,
    },
    SpacingEqual,
    SpacingFractionalEven,
    SpacingFractionalOdd,
    VertexOrderCw,
    VertexOrderCcw,
    PixelCenterInteger,
    OriginUpperLeft,
    OriginLowerLeft,
    EarlyFragmentTests,
    PointMode,
    Xfb,
    DepthReplacing,
    DepthGreater,
    DepthLess,
    DepthUnchanged,
    LocalSize {
        x_size: LiteralInteger32,
        y_size: LiteralInteger32,
        z_size: LiteralInteger32,
    },
    LocalSizeHint {
        x_size: LiteralInteger32,
        y_size: LiteralInteger32,
        z_size: LiteralInteger32,
    },
    InputPoints,
    InputLines,
    InputLinesAdjacency,
    Triangles,
    InputTrianglesAdjacency,
    Quads,
    Isolines,
    OutputVertices {
        vertex_count: LiteralInteger32,
    },
    OutputPoints,
    OutputLineStrip,
    OutputTriangleStrip,
    VecTypeHint {
        vector_type: LiteralInteger32,
    },
    ContractionOff,
    Initializer,
    Finalizer,
    SubgroupSize {
        subgroup_size: LiteralInteger32,
    },
    SubgroupsPerWorkgroup {
        subgroups_per_workgroup: LiteralInteger32,
    },
    SubgroupsPerWorkgroupId {
        subgroups_per_workgroup: IdRef,
    },
    LocalSizeId {
        x_size: IdRef,
        y_size: IdRef,
        z_size: IdRef,
    },
    LocalSizeHintId {
        local_size_hint: IdRef,
    },
    DenormPreserve {
        target_width: LiteralInteger32,
    },
    DenormFlushToZero {
        target_width: LiteralInteger32,
    },
    SignedZeroInfNanPreserve {
        target_width: LiteralInteger32,
    },
    RoundingModeRTE {
        target_width: LiteralInteger32,
    },
    RoundingModeRTZ {
        target_width: LiteralInteger32,
    },
}
impl SPIRVParse for ExecutionMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => {
                let (number_of_invocation_invocations, words) =
                    LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::Invocations {
                        number_of_invocation_invocations,
                    },
                    words,
                ))
            }
            1u32 => Ok((ExecutionMode::SpacingEqual, words)),
            2u32 => Ok((ExecutionMode::SpacingFractionalEven, words)),
            3u32 => Ok((ExecutionMode::SpacingFractionalOdd, words)),
            4u32 => Ok((ExecutionMode::VertexOrderCw, words)),
            5u32 => Ok((ExecutionMode::VertexOrderCcw, words)),
            6u32 => Ok((ExecutionMode::PixelCenterInteger, words)),
            7u32 => Ok((ExecutionMode::OriginUpperLeft, words)),
            8u32 => Ok((ExecutionMode::OriginLowerLeft, words)),
            9u32 => Ok((ExecutionMode::EarlyFragmentTests, words)),
            10u32 => Ok((ExecutionMode::PointMode, words)),
            11u32 => Ok((ExecutionMode::Xfb, words)),
            12u32 => Ok((ExecutionMode::DepthReplacing, words)),
            14u32 => Ok((ExecutionMode::DepthGreater, words)),
            15u32 => Ok((ExecutionMode::DepthLess, words)),
            16u32 => Ok((ExecutionMode::DepthUnchanged, words)),
            17u32 => {
                let (x_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (y_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (z_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSize {
                        x_size,
                        y_size,
                        z_size,
                    },
                    words,
                ))
            }
            18u32 => {
                let (x_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (y_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                let (z_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSizeHint {
                        x_size,
                        y_size,
                        z_size,
                    },
                    words,
                ))
            }
            19u32 => Ok((ExecutionMode::InputPoints, words)),
            20u32 => Ok((ExecutionMode::InputLines, words)),
            21u32 => Ok((ExecutionMode::InputLinesAdjacency, words)),
            22u32 => Ok((ExecutionMode::Triangles, words)),
            23u32 => Ok((ExecutionMode::InputTrianglesAdjacency, words)),
            24u32 => Ok((ExecutionMode::Quads, words)),
            25u32 => Ok((ExecutionMode::Isolines, words)),
            26u32 => {
                let (vertex_count, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::OutputVertices { vertex_count }, words))
            }
            27u32 => Ok((ExecutionMode::OutputPoints, words)),
            28u32 => Ok((ExecutionMode::OutputLineStrip, words)),
            29u32 => Ok((ExecutionMode::OutputTriangleStrip, words)),
            30u32 => {
                let (vector_type, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::VecTypeHint { vector_type }, words))
            }
            31u32 => Ok((ExecutionMode::ContractionOff, words)),
            33u32 => Ok((ExecutionMode::Initializer, words)),
            34u32 => Ok((ExecutionMode::Finalizer, words)),
            35u32 => {
                let (subgroup_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::SubgroupSize { subgroup_size }, words))
            }
            36u32 => {
                let (subgroups_per_workgroup, words) =
                    LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SubgroupsPerWorkgroup {
                        subgroups_per_workgroup,
                    },
                    words,
                ))
            }
            37u32 => {
                let (subgroups_per_workgroup, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SubgroupsPerWorkgroupId {
                        subgroups_per_workgroup,
                    },
                    words,
                ))
            }
            38u32 => {
                let (x_size, words) = IdRef::spirv_parse(words, parse_state)?;
                let (y_size, words) = IdRef::spirv_parse(words, parse_state)?;
                let (z_size, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::LocalSizeId {
                        x_size,
                        y_size,
                        z_size,
                    },
                    words,
                ))
            }
            39u32 => {
                let (local_size_hint, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::LocalSizeHintId { local_size_hint }, words))
            }
            4459u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::DenormPreserve { target_width }, words))
            }
            4460u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::DenormFlushToZero { target_width }, words))
            }
            4461u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    ExecutionMode::SignedZeroInfNanPreserve { target_width },
                    words,
                ))
            }
            4462u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::RoundingModeRTE { target_width }, words))
            }
            4463u32 => {
                let (target_width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((ExecutionMode::RoundingModeRTZ { target_width }, words))
            }
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ExecutionMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ExecutionMode::Invocations {
                number_of_invocation_invocations,
            } => {
                write!(f, " {}", "Invocations")?;
                number_of_invocation_invocations.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SpacingEqual => write!(f, " {}", "SpacingEqual"),
            ExecutionMode::SpacingFractionalEven => write!(f, " {}", "SpacingFractionalEven"),
            ExecutionMode::SpacingFractionalOdd => write!(f, " {}", "SpacingFractionalOdd"),
            ExecutionMode::VertexOrderCw => write!(f, " {}", "VertexOrderCw"),
            ExecutionMode::VertexOrderCcw => write!(f, " {}", "VertexOrderCcw"),
            ExecutionMode::PixelCenterInteger => write!(f, " {}", "PixelCenterInteger"),
            ExecutionMode::OriginUpperLeft => write!(f, " {}", "OriginUpperLeft"),
            ExecutionMode::OriginLowerLeft => write!(f, " {}", "OriginLowerLeft"),
            ExecutionMode::EarlyFragmentTests => write!(f, " {}", "EarlyFragmentTests"),
            ExecutionMode::PointMode => write!(f, " {}", "PointMode"),
            ExecutionMode::Xfb => write!(f, " {}", "Xfb"),
            ExecutionMode::DepthReplacing => write!(f, " {}", "DepthReplacing"),
            ExecutionMode::DepthGreater => write!(f, " {}", "DepthGreater"),
            ExecutionMode::DepthLess => write!(f, " {}", "DepthLess"),
            ExecutionMode::DepthUnchanged => write!(f, " {}", "DepthUnchanged"),
            ExecutionMode::LocalSize {
                x_size,
                y_size,
                z_size,
            } => {
                write!(f, " {}", "LocalSize")?;
                x_size.spirv_display(f)?;
                y_size.spirv_display(f)?;
                z_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::LocalSizeHint {
                x_size,
                y_size,
                z_size,
            } => {
                write!(f, " {}", "LocalSizeHint")?;
                x_size.spirv_display(f)?;
                y_size.spirv_display(f)?;
                z_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::InputPoints => write!(f, " {}", "InputPoints"),
            ExecutionMode::InputLines => write!(f, " {}", "InputLines"),
            ExecutionMode::InputLinesAdjacency => write!(f, " {}", "InputLinesAdjacency"),
            ExecutionMode::Triangles => write!(f, " {}", "Triangles"),
            ExecutionMode::InputTrianglesAdjacency => write!(f, " {}", "InputTrianglesAdjacency"),
            ExecutionMode::Quads => write!(f, " {}", "Quads"),
            ExecutionMode::Isolines => write!(f, " {}", "Isolines"),
            ExecutionMode::OutputVertices { vertex_count } => {
                write!(f, " {}", "OutputVertices")?;
                vertex_count.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::OutputPoints => write!(f, " {}", "OutputPoints"),
            ExecutionMode::OutputLineStrip => write!(f, " {}", "OutputLineStrip"),
            ExecutionMode::OutputTriangleStrip => write!(f, " {}", "OutputTriangleStrip"),
            ExecutionMode::VecTypeHint { vector_type } => {
                write!(f, " {}", "VecTypeHint")?;
                vector_type.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::ContractionOff => write!(f, " {}", "ContractionOff"),
            ExecutionMode::Initializer => write!(f, " {}", "Initializer"),
            ExecutionMode::Finalizer => write!(f, " {}", "Finalizer"),
            ExecutionMode::SubgroupSize { subgroup_size } => {
                write!(f, " {}", "SubgroupSize")?;
                subgroup_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SubgroupsPerWorkgroup {
                subgroups_per_workgroup,
            } => {
                write!(f, " {}", "SubgroupsPerWorkgroup")?;
                subgroups_per_workgroup.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SubgroupsPerWorkgroupId {
                subgroups_per_workgroup,
            } => {
                write!(f, " {}", "SubgroupsPerWorkgroupId")?;
                subgroups_per_workgroup.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::LocalSizeId {
                x_size,
                y_size,
                z_size,
            } => {
                write!(f, " {}", "LocalSizeId")?;
                x_size.spirv_display(f)?;
                y_size.spirv_display(f)?;
                z_size.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::LocalSizeHintId { local_size_hint } => {
                write!(f, " {}", "LocalSizeHintId")?;
                local_size_hint.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::DenormPreserve { target_width } => {
                write!(f, " {}", "DenormPreserve")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::DenormFlushToZero { target_width } => {
                write!(f, " {}", "DenormFlushToZero")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::SignedZeroInfNanPreserve { target_width } => {
                write!(f, " {}", "SignedZeroInfNanPreserve")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::RoundingModeRTE { target_width } => {
                write!(f, " {}", "RoundingModeRTE")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
            ExecutionMode::RoundingModeRTZ { target_width } => {
                write!(f, " {}", "RoundingModeRTZ")?;
                target_width.spirv_display(f)?;
                Ok(())
            }
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum StorageClass {
    UniformConstant,
    Input,
    Uniform,
    Output,
    Workgroup,
    CrossWorkgroup,
    Private,
    Function,
    Generic,
    PushConstant,
    AtomicCounter,
    Image,
    StorageBuffer,
    PhysicalStorageBuffer,
}
impl SPIRVParse for StorageClass {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((StorageClass::UniformConstant, words)),
            1u32 => Ok((StorageClass::Input, words)),
            2u32 => Ok((StorageClass::Uniform, words)),
            3u32 => Ok((StorageClass::Output, words)),
            4u32 => Ok((StorageClass::Workgroup, words)),
            5u32 => Ok((StorageClass::CrossWorkgroup, words)),
            6u32 => Ok((StorageClass::Private, words)),
            7u32 => Ok((StorageClass::Function, words)),
            8u32 => Ok((StorageClass::Generic, words)),
            9u32 => Ok((StorageClass::PushConstant, words)),
            10u32 => Ok((StorageClass::AtomicCounter, words)),
            11u32 => Ok((StorageClass::Image, words)),
            12u32 => Ok((StorageClass::StorageBuffer, words)),
            5349u32 => Ok((StorageClass::PhysicalStorageBuffer, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for StorageClass {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            StorageClass::UniformConstant => write!(f, " {}", "UniformConstant"),
            StorageClass::Input => write!(f, " {}", "Input"),
            StorageClass::Uniform => write!(f, " {}", "Uniform"),
            StorageClass::Output => write!(f, " {}", "Output"),
            StorageClass::Workgroup => write!(f, " {}", "Workgroup"),
            StorageClass::CrossWorkgroup => write!(f, " {}", "CrossWorkgroup"),
            StorageClass::Private => write!(f, " {}", "Private"),
            StorageClass::Function => write!(f, " {}", "Function"),
            StorageClass::Generic => write!(f, " {}", "Generic"),
            StorageClass::PushConstant => write!(f, " {}", "PushConstant"),
            StorageClass::AtomicCounter => write!(f, " {}", "AtomicCounter"),
            StorageClass::Image => write!(f, " {}", "Image"),
            StorageClass::StorageBuffer => write!(f, " {}", "StorageBuffer"),
            StorageClass::PhysicalStorageBuffer => write!(f, " {}", "PhysicalStorageBuffer"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum Dim {
    Dim1D,
    Dim2D,
    Dim3D,
    Cube,
    Rect,
    Buffer,
    SubpassData,
}
impl SPIRVParse for Dim {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Dim::Dim1D, words)),
            1u32 => Ok((Dim::Dim2D, words)),
            2u32 => Ok((Dim::Dim3D, words)),
            3u32 => Ok((Dim::Cube, words)),
            4u32 => Ok((Dim::Rect, words)),
            5u32 => Ok((Dim::Buffer, words)),
            6u32 => Ok((Dim::SubpassData, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Dim {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Dim::Dim1D => write!(f, " {}", "1D"),
            Dim::Dim2D => write!(f, " {}", "2D"),
            Dim::Dim3D => write!(f, " {}", "3D"),
            Dim::Cube => write!(f, " {}", "Cube"),
            Dim::Rect => write!(f, " {}", "Rect"),
            Dim::Buffer => write!(f, " {}", "Buffer"),
            Dim::SubpassData => write!(f, " {}", "SubpassData"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum SamplerAddressingMode {
    None,
    ClampToEdge,
    Clamp,
    Repeat,
    RepeatMirrored,
}
impl SPIRVParse for SamplerAddressingMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((SamplerAddressingMode::None, words)),
            1u32 => Ok((SamplerAddressingMode::ClampToEdge, words)),
            2u32 => Ok((SamplerAddressingMode::Clamp, words)),
            3u32 => Ok((SamplerAddressingMode::Repeat, words)),
            4u32 => Ok((SamplerAddressingMode::RepeatMirrored, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for SamplerAddressingMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SamplerAddressingMode::None => write!(f, " {}", "None"),
            SamplerAddressingMode::ClampToEdge => write!(f, " {}", "ClampToEdge"),
            SamplerAddressingMode::Clamp => write!(f, " {}", "Clamp"),
            SamplerAddressingMode::Repeat => write!(f, " {}", "Repeat"),
            SamplerAddressingMode::RepeatMirrored => write!(f, " {}", "RepeatMirrored"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum SamplerFilterMode {
    Nearest,
    Linear,
}
impl SPIRVParse for SamplerFilterMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((SamplerFilterMode::Nearest, words)),
            1u32 => Ok((SamplerFilterMode::Linear, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for SamplerFilterMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SamplerFilterMode::Nearest => write!(f, " {}", "Nearest"),
            SamplerFilterMode::Linear => write!(f, " {}", "Linear"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ImageFormat {
    Unknown,
    Rgba32f,
    Rgba16f,
    R32f,
    Rgba8,
    Rgba8Snorm,
    Rg32f,
    Rg16f,
    R11fG11fB10f,
    R16f,
    Rgba16,
    Rgb10A2,
    Rg16,
    Rg8,
    R16,
    R8,
    Rgba16Snorm,
    Rg16Snorm,
    Rg8Snorm,
    R16Snorm,
    R8Snorm,
    Rgba32i,
    Rgba16i,
    Rgba8i,
    R32i,
    Rg32i,
    Rg16i,
    Rg8i,
    R16i,
    R8i,
    Rgba32ui,
    Rgba16ui,
    Rgba8ui,
    R32ui,
    Rgb10a2ui,
    Rg32ui,
    Rg16ui,
    Rg8ui,
    R16ui,
    R8ui,
}
impl SPIRVParse for ImageFormat {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ImageFormat::Unknown, words)),
            1u32 => Ok((ImageFormat::Rgba32f, words)),
            2u32 => Ok((ImageFormat::Rgba16f, words)),
            3u32 => Ok((ImageFormat::R32f, words)),
            4u32 => Ok((ImageFormat::Rgba8, words)),
            5u32 => Ok((ImageFormat::Rgba8Snorm, words)),
            6u32 => Ok((ImageFormat::Rg32f, words)),
            7u32 => Ok((ImageFormat::Rg16f, words)),
            8u32 => Ok((ImageFormat::R11fG11fB10f, words)),
            9u32 => Ok((ImageFormat::R16f, words)),
            10u32 => Ok((ImageFormat::Rgba16, words)),
            11u32 => Ok((ImageFormat::Rgb10A2, words)),
            12u32 => Ok((ImageFormat::Rg16, words)),
            13u32 => Ok((ImageFormat::Rg8, words)),
            14u32 => Ok((ImageFormat::R16, words)),
            15u32 => Ok((ImageFormat::R8, words)),
            16u32 => Ok((ImageFormat::Rgba16Snorm, words)),
            17u32 => Ok((ImageFormat::Rg16Snorm, words)),
            18u32 => Ok((ImageFormat::Rg8Snorm, words)),
            19u32 => Ok((ImageFormat::R16Snorm, words)),
            20u32 => Ok((ImageFormat::R8Snorm, words)),
            21u32 => Ok((ImageFormat::Rgba32i, words)),
            22u32 => Ok((ImageFormat::Rgba16i, words)),
            23u32 => Ok((ImageFormat::Rgba8i, words)),
            24u32 => Ok((ImageFormat::R32i, words)),
            25u32 => Ok((ImageFormat::Rg32i, words)),
            26u32 => Ok((ImageFormat::Rg16i, words)),
            27u32 => Ok((ImageFormat::Rg8i, words)),
            28u32 => Ok((ImageFormat::R16i, words)),
            29u32 => Ok((ImageFormat::R8i, words)),
            30u32 => Ok((ImageFormat::Rgba32ui, words)),
            31u32 => Ok((ImageFormat::Rgba16ui, words)),
            32u32 => Ok((ImageFormat::Rgba8ui, words)),
            33u32 => Ok((ImageFormat::R32ui, words)),
            34u32 => Ok((ImageFormat::Rgb10a2ui, words)),
            35u32 => Ok((ImageFormat::Rg32ui, words)),
            36u32 => Ok((ImageFormat::Rg16ui, words)),
            37u32 => Ok((ImageFormat::Rg8ui, words)),
            38u32 => Ok((ImageFormat::R16ui, words)),
            39u32 => Ok((ImageFormat::R8ui, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ImageFormat {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ImageFormat::Unknown => write!(f, " {}", "Unknown"),
            ImageFormat::Rgba32f => write!(f, " {}", "Rgba32f"),
            ImageFormat::Rgba16f => write!(f, " {}", "Rgba16f"),
            ImageFormat::R32f => write!(f, " {}", "R32f"),
            ImageFormat::Rgba8 => write!(f, " {}", "Rgba8"),
            ImageFormat::Rgba8Snorm => write!(f, " {}", "Rgba8Snorm"),
            ImageFormat::Rg32f => write!(f, " {}", "Rg32f"),
            ImageFormat::Rg16f => write!(f, " {}", "Rg16f"),
            ImageFormat::R11fG11fB10f => write!(f, " {}", "R11fG11fB10f"),
            ImageFormat::R16f => write!(f, " {}", "R16f"),
            ImageFormat::Rgba16 => write!(f, " {}", "Rgba16"),
            ImageFormat::Rgb10A2 => write!(f, " {}", "Rgb10A2"),
            ImageFormat::Rg16 => write!(f, " {}", "Rg16"),
            ImageFormat::Rg8 => write!(f, " {}", "Rg8"),
            ImageFormat::R16 => write!(f, " {}", "R16"),
            ImageFormat::R8 => write!(f, " {}", "R8"),
            ImageFormat::Rgba16Snorm => write!(f, " {}", "Rgba16Snorm"),
            ImageFormat::Rg16Snorm => write!(f, " {}", "Rg16Snorm"),
            ImageFormat::Rg8Snorm => write!(f, " {}", "Rg8Snorm"),
            ImageFormat::R16Snorm => write!(f, " {}", "R16Snorm"),
            ImageFormat::R8Snorm => write!(f, " {}", "R8Snorm"),
            ImageFormat::Rgba32i => write!(f, " {}", "Rgba32i"),
            ImageFormat::Rgba16i => write!(f, " {}", "Rgba16i"),
            ImageFormat::Rgba8i => write!(f, " {}", "Rgba8i"),
            ImageFormat::R32i => write!(f, " {}", "R32i"),
            ImageFormat::Rg32i => write!(f, " {}", "Rg32i"),
            ImageFormat::Rg16i => write!(f, " {}", "Rg16i"),
            ImageFormat::Rg8i => write!(f, " {}", "Rg8i"),
            ImageFormat::R16i => write!(f, " {}", "R16i"),
            ImageFormat::R8i => write!(f, " {}", "R8i"),
            ImageFormat::Rgba32ui => write!(f, " {}", "Rgba32ui"),
            ImageFormat::Rgba16ui => write!(f, " {}", "Rgba16ui"),
            ImageFormat::Rgba8ui => write!(f, " {}", "Rgba8ui"),
            ImageFormat::R32ui => write!(f, " {}", "R32ui"),
            ImageFormat::Rgb10a2ui => write!(f, " {}", "Rgb10a2ui"),
            ImageFormat::Rg32ui => write!(f, " {}", "Rg32ui"),
            ImageFormat::Rg16ui => write!(f, " {}", "Rg16ui"),
            ImageFormat::Rg8ui => write!(f, " {}", "Rg8ui"),
            ImageFormat::R16ui => write!(f, " {}", "R16ui"),
            ImageFormat::R8ui => write!(f, " {}", "R8ui"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ImageChannelOrder {
    R,
    A,
    RG,
    RA,
    RGB,
    RGBA,
    BGRA,
    ARGB,
    Intensity,
    Luminance,
    Rx,
    RGx,
    RGBx,
    Depth,
    DepthStencil,
    SRGB,
    SRGBx,
    SRGBA,
    SBGRA,
    ABGR,
}
impl SPIRVParse for ImageChannelOrder {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ImageChannelOrder::R, words)),
            1u32 => Ok((ImageChannelOrder::A, words)),
            2u32 => Ok((ImageChannelOrder::RG, words)),
            3u32 => Ok((ImageChannelOrder::RA, words)),
            4u32 => Ok((ImageChannelOrder::RGB, words)),
            5u32 => Ok((ImageChannelOrder::RGBA, words)),
            6u32 => Ok((ImageChannelOrder::BGRA, words)),
            7u32 => Ok((ImageChannelOrder::ARGB, words)),
            8u32 => Ok((ImageChannelOrder::Intensity, words)),
            9u32 => Ok((ImageChannelOrder::Luminance, words)),
            10u32 => Ok((ImageChannelOrder::Rx, words)),
            11u32 => Ok((ImageChannelOrder::RGx, words)),
            12u32 => Ok((ImageChannelOrder::RGBx, words)),
            13u32 => Ok((ImageChannelOrder::Depth, words)),
            14u32 => Ok((ImageChannelOrder::DepthStencil, words)),
            15u32 => Ok((ImageChannelOrder::SRGB, words)),
            16u32 => Ok((ImageChannelOrder::SRGBx, words)),
            17u32 => Ok((ImageChannelOrder::SRGBA, words)),
            18u32 => Ok((ImageChannelOrder::SBGRA, words)),
            19u32 => Ok((ImageChannelOrder::ABGR, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ImageChannelOrder {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ImageChannelOrder::R => write!(f, " {}", "R"),
            ImageChannelOrder::A => write!(f, " {}", "A"),
            ImageChannelOrder::RG => write!(f, " {}", "RG"),
            ImageChannelOrder::RA => write!(f, " {}", "RA"),
            ImageChannelOrder::RGB => write!(f, " {}", "RGB"),
            ImageChannelOrder::RGBA => write!(f, " {}", "RGBA"),
            ImageChannelOrder::BGRA => write!(f, " {}", "BGRA"),
            ImageChannelOrder::ARGB => write!(f, " {}", "ARGB"),
            ImageChannelOrder::Intensity => write!(f, " {}", "Intensity"),
            ImageChannelOrder::Luminance => write!(f, " {}", "Luminance"),
            ImageChannelOrder::Rx => write!(f, " {}", "Rx"),
            ImageChannelOrder::RGx => write!(f, " {}", "RGx"),
            ImageChannelOrder::RGBx => write!(f, " {}", "RGBx"),
            ImageChannelOrder::Depth => write!(f, " {}", "Depth"),
            ImageChannelOrder::DepthStencil => write!(f, " {}", "DepthStencil"),
            ImageChannelOrder::SRGB => write!(f, " {}", "sRGB"),
            ImageChannelOrder::SRGBx => write!(f, " {}", "sRGBx"),
            ImageChannelOrder::SRGBA => write!(f, " {}", "sRGBA"),
            ImageChannelOrder::SBGRA => write!(f, " {}", "sBGRA"),
            ImageChannelOrder::ABGR => write!(f, " {}", "ABGR"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum ImageChannelDataType {
    SnormInt8,
    SnormInt16,
    UnormInt8,
    UnormInt16,
    UnormShort565,
    UnormShort555,
    UnormInt101010,
    SignedInt8,
    SignedInt16,
    SignedInt32,
    UnsignedInt8,
    UnsignedInt16,
    UnsignedInt32,
    HalfFloat,
    Float,
    UnormInt24,
    UnormInt1010102,
}
impl SPIRVParse for ImageChannelDataType {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((ImageChannelDataType::SnormInt8, words)),
            1u32 => Ok((ImageChannelDataType::SnormInt16, words)),
            2u32 => Ok((ImageChannelDataType::UnormInt8, words)),
            3u32 => Ok((ImageChannelDataType::UnormInt16, words)),
            4u32 => Ok((ImageChannelDataType::UnormShort565, words)),
            5u32 => Ok((ImageChannelDataType::UnormShort555, words)),
            6u32 => Ok((ImageChannelDataType::UnormInt101010, words)),
            7u32 => Ok((ImageChannelDataType::SignedInt8, words)),
            8u32 => Ok((ImageChannelDataType::SignedInt16, words)),
            9u32 => Ok((ImageChannelDataType::SignedInt32, words)),
            10u32 => Ok((ImageChannelDataType::UnsignedInt8, words)),
            11u32 => Ok((ImageChannelDataType::UnsignedInt16, words)),
            12u32 => Ok((ImageChannelDataType::UnsignedInt32, words)),
            13u32 => Ok((ImageChannelDataType::HalfFloat, words)),
            14u32 => Ok((ImageChannelDataType::Float, words)),
            15u32 => Ok((ImageChannelDataType::UnormInt24, words)),
            16u32 => Ok((ImageChannelDataType::UnormInt1010102, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for ImageChannelDataType {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ImageChannelDataType::SnormInt8 => write!(f, " {}", "SnormInt8"),
            ImageChannelDataType::SnormInt16 => write!(f, " {}", "SnormInt16"),
            ImageChannelDataType::UnormInt8 => write!(f, " {}", "UnormInt8"),
            ImageChannelDataType::UnormInt16 => write!(f, " {}", "UnormInt16"),
            ImageChannelDataType::UnormShort565 => write!(f, " {}", "UnormShort565"),
            ImageChannelDataType::UnormShort555 => write!(f, " {}", "UnormShort555"),
            ImageChannelDataType::UnormInt101010 => write!(f, " {}", "UnormInt101010"),
            ImageChannelDataType::SignedInt8 => write!(f, " {}", "SignedInt8"),
            ImageChannelDataType::SignedInt16 => write!(f, " {}", "SignedInt16"),
            ImageChannelDataType::SignedInt32 => write!(f, " {}", "SignedInt32"),
            ImageChannelDataType::UnsignedInt8 => write!(f, " {}", "UnsignedInt8"),
            ImageChannelDataType::UnsignedInt16 => write!(f, " {}", "UnsignedInt16"),
            ImageChannelDataType::UnsignedInt32 => write!(f, " {}", "UnsignedInt32"),
            ImageChannelDataType::HalfFloat => write!(f, " {}", "HalfFloat"),
            ImageChannelDataType::Float => write!(f, " {}", "Float"),
            ImageChannelDataType::UnormInt24 => write!(f, " {}", "UnormInt24"),
            ImageChannelDataType::UnormInt1010102 => write!(f, " {}", "UnormInt101010_2"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum FPRoundingMode {
    RTE,
    RTZ,
    RTP,
    RTN,
}
impl SPIRVParse for FPRoundingMode {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((FPRoundingMode::RTE, words)),
            1u32 => Ok((FPRoundingMode::RTZ, words)),
            2u32 => Ok((FPRoundingMode::RTP, words)),
            3u32 => Ok((FPRoundingMode::RTN, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for FPRoundingMode {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FPRoundingMode::RTE => write!(f, " {}", "RTE"),
            FPRoundingMode::RTZ => write!(f, " {}", "RTZ"),
            FPRoundingMode::RTP => write!(f, " {}", "RTP"),
            FPRoundingMode::RTN => write!(f, " {}", "RTN"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum LinkageType {
    Export,
    Import,
}
impl SPIRVParse for LinkageType {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((LinkageType::Export, words)),
            1u32 => Ok((LinkageType::Import, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for LinkageType {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            LinkageType::Export => write!(f, " {}", "Export"),
            LinkageType::Import => write!(f, " {}", "Import"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum AccessQualifier {
    ReadOnly,
    WriteOnly,
    ReadWrite,
}
impl SPIRVParse for AccessQualifier {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((AccessQualifier::ReadOnly, words)),
            1u32 => Ok((AccessQualifier::WriteOnly, words)),
            2u32 => Ok((AccessQualifier::ReadWrite, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for AccessQualifier {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AccessQualifier::ReadOnly => write!(f, " {}", "ReadOnly"),
            AccessQualifier::WriteOnly => write!(f, " {}", "WriteOnly"),
            AccessQualifier::ReadWrite => write!(f, " {}", "ReadWrite"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum FunctionParameterAttribute {
    Zext,
    Sext,
    ByVal,
    Sret,
    NoAlias,
    NoCapture,
    NoWrite,
    NoReadWrite,
}
impl SPIRVParse for FunctionParameterAttribute {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((FunctionParameterAttribute::Zext, words)),
            1u32 => Ok((FunctionParameterAttribute::Sext, words)),
            2u32 => Ok((FunctionParameterAttribute::ByVal, words)),
            3u32 => Ok((FunctionParameterAttribute::Sret, words)),
            4u32 => Ok((FunctionParameterAttribute::NoAlias, words)),
            5u32 => Ok((FunctionParameterAttribute::NoCapture, words)),
            6u32 => Ok((FunctionParameterAttribute::NoWrite, words)),
            7u32 => Ok((FunctionParameterAttribute::NoReadWrite, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for FunctionParameterAttribute {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FunctionParameterAttribute::Zext => write!(f, " {}", "Zext"),
            FunctionParameterAttribute::Sext => write!(f, " {}", "Sext"),
            FunctionParameterAttribute::ByVal => write!(f, " {}", "ByVal"),
            FunctionParameterAttribute::Sret => write!(f, " {}", "Sret"),
            FunctionParameterAttribute::NoAlias => write!(f, " {}", "NoAlias"),
            FunctionParameterAttribute::NoCapture => write!(f, " {}", "NoCapture"),
            FunctionParameterAttribute::NoWrite => write!(f, " {}", "NoWrite"),
            FunctionParameterAttribute::NoReadWrite => write!(f, " {}", "NoReadWrite"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub enum Decoration {
    RelaxedPrecision,
    SpecId {
        specialization_constant_id: LiteralInteger32,
    },
    Block,
    BufferBlock,
    RowMajor,
    ColMajor,
    ArrayStride {
        array_stride: LiteralInteger32,
    },
    MatrixStride {
        matrix_stride: LiteralInteger32,
    },
    GLSLShared,
    GLSLPacked,
    CPacked,
    BuiltIn {
        built_in: BuiltIn,
    },
    NoPerspective,
    Flat,
    Patch,
    Centroid,
    Sample,
    Invariant,
    Restrict,
    Aliased,
    Volatile,
    Constant,
    Coherent,
    NonWritable,
    NonReadable,
    Uniform,
    UniformId {
        execution: IdScope,
    },
    SaturatedConversion,
    Stream {
        stream_number: LiteralInteger32,
    },
    Location {
        location: LiteralInteger32,
    },
    Component {
        component: LiteralInteger32,
    },
    Index {
        index: LiteralInteger32,
    },
    Binding {
        binding_point: LiteralInteger32,
    },
    DescriptorSet {
        descriptor_set: LiteralInteger32,
    },
    Offset {
        byte_offset: LiteralInteger32,
    },
    XfbBuffer {
        xfb_buffer_number: LiteralInteger32,
    },
    XfbStride {
        xfb_stride: LiteralInteger32,
    },
    FuncParamAttr {
        function_parameter_attribute: FunctionParameterAttribute,
    },
    FPRoundingMode {
        floating_point_rounding_mode: FPRoundingMode,
    },
    FPFastMathMode {
        fast_math_mode: FPFastMathMode,
    },
    LinkageAttributes {
        name: LiteralString,
        linkage_type: LinkageType,
    },
    NoContraction,
    InputAttachmentIndex {
        attachment_index: LiteralInteger32,
    },
    Alignment {
        alignment: LiteralInteger32,
    },
    MaxByteOffset {
        max_byte_offset: LiteralInteger32,
    },
    AlignmentId {
        alignment: IdRef,
    },
    MaxByteOffsetId {
        max_byte_offset: IdRef,
    },
    NoSignedWrap,
    NoUnsignedWrap,
    NonUniform,
    RestrictPointer,
    AliasedPointer,
    CounterBuffer {
        counter_buffer: IdRef,
    },
    UserSemantic {
        semantic: LiteralString,
    },
}
impl SPIRVParse for Decoration {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Decoration::RelaxedPrecision, words)),
            1u32 => {
                let (specialization_constant_id, words) =
                    LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::SpecId {
                        specialization_constant_id,
                    },
                    words,
                ))
            }
            2u32 => Ok((Decoration::Block, words)),
            3u32 => Ok((Decoration::BufferBlock, words)),
            4u32 => Ok((Decoration::RowMajor, words)),
            5u32 => Ok((Decoration::ColMajor, words)),
            6u32 => {
                let (array_stride, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::ArrayStride { array_stride }, words))
            }
            7u32 => {
                let (matrix_stride, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::MatrixStride { matrix_stride }, words))
            }
            8u32 => Ok((Decoration::GLSLShared, words)),
            9u32 => Ok((Decoration::GLSLPacked, words)),
            10u32 => Ok((Decoration::CPacked, words)),
            11u32 => {
                let (built_in, words) = BuiltIn::spirv_parse(words, parse_state)?;
                Ok((Decoration::BuiltIn { built_in }, words))
            }
            13u32 => Ok((Decoration::NoPerspective, words)),
            14u32 => Ok((Decoration::Flat, words)),
            15u32 => Ok((Decoration::Patch, words)),
            16u32 => Ok((Decoration::Centroid, words)),
            17u32 => Ok((Decoration::Sample, words)),
            18u32 => Ok((Decoration::Invariant, words)),
            19u32 => Ok((Decoration::Restrict, words)),
            20u32 => Ok((Decoration::Aliased, words)),
            21u32 => Ok((Decoration::Volatile, words)),
            22u32 => Ok((Decoration::Constant, words)),
            23u32 => Ok((Decoration::Coherent, words)),
            24u32 => Ok((Decoration::NonWritable, words)),
            25u32 => Ok((Decoration::NonReadable, words)),
            26u32 => Ok((Decoration::Uniform, words)),
            27u32 => {
                let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
                Ok((Decoration::UniformId { execution }, words))
            }
            28u32 => Ok((Decoration::SaturatedConversion, words)),
            29u32 => {
                let (stream_number, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Stream { stream_number }, words))
            }
            30u32 => {
                let (location, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Location { location }, words))
            }
            31u32 => {
                let (component, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Component { component }, words))
            }
            32u32 => {
                let (index, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Index { index }, words))
            }
            33u32 => {
                let (binding_point, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Binding { binding_point }, words))
            }
            34u32 => {
                let (descriptor_set, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::DescriptorSet { descriptor_set }, words))
            }
            35u32 => {
                let (byte_offset, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Offset { byte_offset }, words))
            }
            36u32 => {
                let (xfb_buffer_number, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::XfbBuffer { xfb_buffer_number }, words))
            }
            37u32 => {
                let (xfb_stride, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::XfbStride { xfb_stride }, words))
            }
            38u32 => {
                let (function_parameter_attribute, words) =
                    FunctionParameterAttribute::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::FuncParamAttr {
                        function_parameter_attribute,
                    },
                    words,
                ))
            }
            39u32 => {
                let (floating_point_rounding_mode, words) =
                    FPRoundingMode::spirv_parse(words, parse_state)?;
                Ok((
                    Decoration::FPRoundingMode {
                        floating_point_rounding_mode,
                    },
                    words,
                ))
            }
            40u32 => {
                let (fast_math_mode, words) = FPFastMathMode::spirv_parse(words, parse_state)?;
                Ok((Decoration::FPFastMathMode { fast_math_mode }, words))
            }
            41u32 => {
                let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
                let (linkage_type, words) = LinkageType::spirv_parse(words, parse_state)?;
                Ok((Decoration::LinkageAttributes { name, linkage_type }, words))
            }
            42u32 => Ok((Decoration::NoContraction, words)),
            43u32 => {
                let (attachment_index, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::InputAttachmentIndex { attachment_index }, words))
            }
            44u32 => {
                let (alignment, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::Alignment { alignment }, words))
            }
            45u32 => {
                let (max_byte_offset, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                Ok((Decoration::MaxByteOffset { max_byte_offset }, words))
            }
            46u32 => {
                let (alignment, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((Decoration::AlignmentId { alignment }, words))
            }
            47u32 => {
                let (max_byte_offset, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((Decoration::MaxByteOffsetId { max_byte_offset }, words))
            }
            4469u32 => Ok((Decoration::NoSignedWrap, words)),
            4470u32 => Ok((Decoration::NoUnsignedWrap, words)),
            5300u32 => Ok((Decoration::NonUniform, words)),
            5355u32 => Ok((Decoration::RestrictPointer, words)),
            5356u32 => Ok((Decoration::AliasedPointer, words)),
            5634u32 => {
                let (counter_buffer, words) = IdRef::spirv_parse(words, parse_state)?;
                Ok((Decoration::CounterBuffer { counter_buffer }, words))
            }
            5635u32 => {
                let (semantic, words) = LiteralString::spirv_parse(words, parse_state)?;
                Ok((Decoration::UserSemantic { semantic }, words))
            }
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Decoration {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Decoration::RelaxedPrecision => write!(f, " {}", "RelaxedPrecision"),
            Decoration::SpecId {
                specialization_constant_id,
            } => {
                write!(f, " {}", "SpecId")?;
                specialization_constant_id.spirv_display(f)?;
                Ok(())
            }
            Decoration::Block => write!(f, " {}", "Block"),
            Decoration::BufferBlock => write!(f, " {}", "BufferBlock"),
            Decoration::RowMajor => write!(f, " {}", "RowMajor"),
            Decoration::ColMajor => write!(f, " {}", "ColMajor"),
            Decoration::ArrayStride { array_stride } => {
                write!(f, " {}", "ArrayStride")?;
                array_stride.spirv_display(f)?;
                Ok(())
            }
            Decoration::MatrixStride { matrix_stride } => {
                write!(f, " {}", "MatrixStride")?;
                matrix_stride.spirv_display(f)?;
                Ok(())
            }
            Decoration::GLSLShared => write!(f, " {}", "GLSLShared"),
            Decoration::GLSLPacked => write!(f, " {}", "GLSLPacked"),
            Decoration::CPacked => write!(f, " {}", "CPacked"),
            Decoration::BuiltIn { built_in } => {
                write!(f, " {}", "BuiltIn")?;
                built_in.spirv_display(f)?;
                Ok(())
            }
            Decoration::NoPerspective => write!(f, " {}", "NoPerspective"),
            Decoration::Flat => write!(f, " {}", "Flat"),
            Decoration::Patch => write!(f, " {}", "Patch"),
            Decoration::Centroid => write!(f, " {}", "Centroid"),
            Decoration::Sample => write!(f, " {}", "Sample"),
            Decoration::Invariant => write!(f, " {}", "Invariant"),
            Decoration::Restrict => write!(f, " {}", "Restrict"),
            Decoration::Aliased => write!(f, " {}", "Aliased"),
            Decoration::Volatile => write!(f, " {}", "Volatile"),
            Decoration::Constant => write!(f, " {}", "Constant"),
            Decoration::Coherent => write!(f, " {}", "Coherent"),
            Decoration::NonWritable => write!(f, " {}", "NonWritable"),
            Decoration::NonReadable => write!(f, " {}", "NonReadable"),
            Decoration::Uniform => write!(f, " {}", "Uniform"),
            Decoration::UniformId { execution } => {
                write!(f, " {}", "UniformId")?;
                execution.spirv_display(f)?;
                Ok(())
            }
            Decoration::SaturatedConversion => write!(f, " {}", "SaturatedConversion"),
            Decoration::Stream { stream_number } => {
                write!(f, " {}", "Stream")?;
                stream_number.spirv_display(f)?;
                Ok(())
            }
            Decoration::Location { location } => {
                write!(f, " {}", "Location")?;
                location.spirv_display(f)?;
                Ok(())
            }
            Decoration::Component { component } => {
                write!(f, " {}", "Component")?;
                component.spirv_display(f)?;
                Ok(())
            }
            Decoration::Index { index } => {
                write!(f, " {}", "Index")?;
                index.spirv_display(f)?;
                Ok(())
            }
            Decoration::Binding { binding_point } => {
                write!(f, " {}", "Binding")?;
                binding_point.spirv_display(f)?;
                Ok(())
            }
            Decoration::DescriptorSet { descriptor_set } => {
                write!(f, " {}", "DescriptorSet")?;
                descriptor_set.spirv_display(f)?;
                Ok(())
            }
            Decoration::Offset { byte_offset } => {
                write!(f, " {}", "Offset")?;
                byte_offset.spirv_display(f)?;
                Ok(())
            }
            Decoration::XfbBuffer { xfb_buffer_number } => {
                write!(f, " {}", "XfbBuffer")?;
                xfb_buffer_number.spirv_display(f)?;
                Ok(())
            }
            Decoration::XfbStride { xfb_stride } => {
                write!(f, " {}", "XfbStride")?;
                xfb_stride.spirv_display(f)?;
                Ok(())
            }
            Decoration::FuncParamAttr {
                function_parameter_attribute,
            } => {
                write!(f, " {}", "FuncParamAttr")?;
                function_parameter_attribute.spirv_display(f)?;
                Ok(())
            }
            Decoration::FPRoundingMode {
                floating_point_rounding_mode,
            } => {
                write!(f, " {}", "FPRoundingMode")?;
                floating_point_rounding_mode.spirv_display(f)?;
                Ok(())
            }
            Decoration::FPFastMathMode { fast_math_mode } => {
                write!(f, " {}", "FPFastMathMode")?;
                fast_math_mode.spirv_display(f)?;
                Ok(())
            }
            Decoration::LinkageAttributes { name, linkage_type } => {
                write!(f, " {}", "LinkageAttributes")?;
                name.spirv_display(f)?;
                linkage_type.spirv_display(f)?;
                Ok(())
            }
            Decoration::NoContraction => write!(f, " {}", "NoContraction"),
            Decoration::InputAttachmentIndex { attachment_index } => {
                write!(f, " {}", "InputAttachmentIndex")?;
                attachment_index.spirv_display(f)?;
                Ok(())
            }
            Decoration::Alignment { alignment } => {
                write!(f, " {}", "Alignment")?;
                alignment.spirv_display(f)?;
                Ok(())
            }
            Decoration::MaxByteOffset { max_byte_offset } => {
                write!(f, " {}", "MaxByteOffset")?;
                max_byte_offset.spirv_display(f)?;
                Ok(())
            }
            Decoration::AlignmentId { alignment } => {
                write!(f, " {}", "AlignmentId")?;
                alignment.spirv_display(f)?;
                Ok(())
            }
            Decoration::MaxByteOffsetId { max_byte_offset } => {
                write!(f, " {}", "MaxByteOffsetId")?;
                max_byte_offset.spirv_display(f)?;
                Ok(())
            }
            Decoration::NoSignedWrap => write!(f, " {}", "NoSignedWrap"),
            Decoration::NoUnsignedWrap => write!(f, " {}", "NoUnsignedWrap"),
            Decoration::NonUniform => write!(f, " {}", "NonUniform"),
            Decoration::RestrictPointer => write!(f, " {}", "RestrictPointer"),
            Decoration::AliasedPointer => write!(f, " {}", "AliasedPointer"),
            Decoration::CounterBuffer { counter_buffer } => {
                write!(f, " {}", "CounterBuffer")?;
                counter_buffer.spirv_display(f)?;
                Ok(())
            }
            Decoration::UserSemantic { semantic } => {
                write!(f, " {}", "UserSemantic")?;
                semantic.spirv_display(f)?;
                Ok(())
            }
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum BuiltIn {
    Position,
    PointSize,
    ClipDistance,
    CullDistance,
    VertexId,
    InstanceId,
    PrimitiveId,
    InvocationId,
    Layer,
    ViewportIndex,
    TessLevelOuter,
    TessLevelInner,
    TessCoord,
    PatchVertices,
    FragCoord,
    PointCoord,
    FrontFacing,
    SampleId,
    SamplePosition,
    SampleMask,
    FragDepth,
    HelperInvocation,
    NumWorkgroups,
    WorkgroupSize,
    WorkgroupId,
    LocalInvocationId,
    GlobalInvocationId,
    LocalInvocationIndex,
    WorkDim,
    GlobalSize,
    EnqueuedWorkgroupSize,
    GlobalOffset,
    GlobalLinearId,
    SubgroupSize,
    SubgroupMaxSize,
    NumSubgroups,
    NumEnqueuedSubgroups,
    SubgroupId,
    SubgroupLocalInvocationId,
    VertexIndex,
    InstanceIndex,
    SubgroupEqMask,
    SubgroupGeMask,
    SubgroupGtMask,
    SubgroupLeMask,
    SubgroupLtMask,
    BaseVertex,
    BaseInstance,
    DrawIndex,
    DeviceIndex,
    ViewIndex,
}
impl SPIRVParse for BuiltIn {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((BuiltIn::Position, words)),
            1u32 => Ok((BuiltIn::PointSize, words)),
            3u32 => Ok((BuiltIn::ClipDistance, words)),
            4u32 => Ok((BuiltIn::CullDistance, words)),
            5u32 => Ok((BuiltIn::VertexId, words)),
            6u32 => Ok((BuiltIn::InstanceId, words)),
            7u32 => Ok((BuiltIn::PrimitiveId, words)),
            8u32 => Ok((BuiltIn::InvocationId, words)),
            9u32 => Ok((BuiltIn::Layer, words)),
            10u32 => Ok((BuiltIn::ViewportIndex, words)),
            11u32 => Ok((BuiltIn::TessLevelOuter, words)),
            12u32 => Ok((BuiltIn::TessLevelInner, words)),
            13u32 => Ok((BuiltIn::TessCoord, words)),
            14u32 => Ok((BuiltIn::PatchVertices, words)),
            15u32 => Ok((BuiltIn::FragCoord, words)),
            16u32 => Ok((BuiltIn::PointCoord, words)),
            17u32 => Ok((BuiltIn::FrontFacing, words)),
            18u32 => Ok((BuiltIn::SampleId, words)),
            19u32 => Ok((BuiltIn::SamplePosition, words)),
            20u32 => Ok((BuiltIn::SampleMask, words)),
            22u32 => Ok((BuiltIn::FragDepth, words)),
            23u32 => Ok((BuiltIn::HelperInvocation, words)),
            24u32 => Ok((BuiltIn::NumWorkgroups, words)),
            25u32 => Ok((BuiltIn::WorkgroupSize, words)),
            26u32 => Ok((BuiltIn::WorkgroupId, words)),
            27u32 => Ok((BuiltIn::LocalInvocationId, words)),
            28u32 => Ok((BuiltIn::GlobalInvocationId, words)),
            29u32 => Ok((BuiltIn::LocalInvocationIndex, words)),
            30u32 => Ok((BuiltIn::WorkDim, words)),
            31u32 => Ok((BuiltIn::GlobalSize, words)),
            32u32 => Ok((BuiltIn::EnqueuedWorkgroupSize, words)),
            33u32 => Ok((BuiltIn::GlobalOffset, words)),
            34u32 => Ok((BuiltIn::GlobalLinearId, words)),
            36u32 => Ok((BuiltIn::SubgroupSize, words)),
            37u32 => Ok((BuiltIn::SubgroupMaxSize, words)),
            38u32 => Ok((BuiltIn::NumSubgroups, words)),
            39u32 => Ok((BuiltIn::NumEnqueuedSubgroups, words)),
            40u32 => Ok((BuiltIn::SubgroupId, words)),
            41u32 => Ok((BuiltIn::SubgroupLocalInvocationId, words)),
            42u32 => Ok((BuiltIn::VertexIndex, words)),
            43u32 => Ok((BuiltIn::InstanceIndex, words)),
            4416u32 => Ok((BuiltIn::SubgroupEqMask, words)),
            4417u32 => Ok((BuiltIn::SubgroupGeMask, words)),
            4418u32 => Ok((BuiltIn::SubgroupGtMask, words)),
            4419u32 => Ok((BuiltIn::SubgroupLeMask, words)),
            4420u32 => Ok((BuiltIn::SubgroupLtMask, words)),
            4424u32 => Ok((BuiltIn::BaseVertex, words)),
            4425u32 => Ok((BuiltIn::BaseInstance, words)),
            4426u32 => Ok((BuiltIn::DrawIndex, words)),
            4438u32 => Ok((BuiltIn::DeviceIndex, words)),
            4440u32 => Ok((BuiltIn::ViewIndex, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for BuiltIn {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BuiltIn::Position => write!(f, " {}", "Position"),
            BuiltIn::PointSize => write!(f, " {}", "PointSize"),
            BuiltIn::ClipDistance => write!(f, " {}", "ClipDistance"),
            BuiltIn::CullDistance => write!(f, " {}", "CullDistance"),
            BuiltIn::VertexId => write!(f, " {}", "VertexId"),
            BuiltIn::InstanceId => write!(f, " {}", "InstanceId"),
            BuiltIn::PrimitiveId => write!(f, " {}", "PrimitiveId"),
            BuiltIn::InvocationId => write!(f, " {}", "InvocationId"),
            BuiltIn::Layer => write!(f, " {}", "Layer"),
            BuiltIn::ViewportIndex => write!(f, " {}", "ViewportIndex"),
            BuiltIn::TessLevelOuter => write!(f, " {}", "TessLevelOuter"),
            BuiltIn::TessLevelInner => write!(f, " {}", "TessLevelInner"),
            BuiltIn::TessCoord => write!(f, " {}", "TessCoord"),
            BuiltIn::PatchVertices => write!(f, " {}", "PatchVertices"),
            BuiltIn::FragCoord => write!(f, " {}", "FragCoord"),
            BuiltIn::PointCoord => write!(f, " {}", "PointCoord"),
            BuiltIn::FrontFacing => write!(f, " {}", "FrontFacing"),
            BuiltIn::SampleId => write!(f, " {}", "SampleId"),
            BuiltIn::SamplePosition => write!(f, " {}", "SamplePosition"),
            BuiltIn::SampleMask => write!(f, " {}", "SampleMask"),
            BuiltIn::FragDepth => write!(f, " {}", "FragDepth"),
            BuiltIn::HelperInvocation => write!(f, " {}", "HelperInvocation"),
            BuiltIn::NumWorkgroups => write!(f, " {}", "NumWorkgroups"),
            BuiltIn::WorkgroupSize => write!(f, " {}", "WorkgroupSize"),
            BuiltIn::WorkgroupId => write!(f, " {}", "WorkgroupId"),
            BuiltIn::LocalInvocationId => write!(f, " {}", "LocalInvocationId"),
            BuiltIn::GlobalInvocationId => write!(f, " {}", "GlobalInvocationId"),
            BuiltIn::LocalInvocationIndex => write!(f, " {}", "LocalInvocationIndex"),
            BuiltIn::WorkDim => write!(f, " {}", "WorkDim"),
            BuiltIn::GlobalSize => write!(f, " {}", "GlobalSize"),
            BuiltIn::EnqueuedWorkgroupSize => write!(f, " {}", "EnqueuedWorkgroupSize"),
            BuiltIn::GlobalOffset => write!(f, " {}", "GlobalOffset"),
            BuiltIn::GlobalLinearId => write!(f, " {}", "GlobalLinearId"),
            BuiltIn::SubgroupSize => write!(f, " {}", "SubgroupSize"),
            BuiltIn::SubgroupMaxSize => write!(f, " {}", "SubgroupMaxSize"),
            BuiltIn::NumSubgroups => write!(f, " {}", "NumSubgroups"),
            BuiltIn::NumEnqueuedSubgroups => write!(f, " {}", "NumEnqueuedSubgroups"),
            BuiltIn::SubgroupId => write!(f, " {}", "SubgroupId"),
            BuiltIn::SubgroupLocalInvocationId => write!(f, " {}", "SubgroupLocalInvocationId"),
            BuiltIn::VertexIndex => write!(f, " {}", "VertexIndex"),
            BuiltIn::InstanceIndex => write!(f, " {}", "InstanceIndex"),
            BuiltIn::SubgroupEqMask => write!(f, " {}", "SubgroupEqMask"),
            BuiltIn::SubgroupGeMask => write!(f, " {}", "SubgroupGeMask"),
            BuiltIn::SubgroupGtMask => write!(f, " {}", "SubgroupGtMask"),
            BuiltIn::SubgroupLeMask => write!(f, " {}", "SubgroupLeMask"),
            BuiltIn::SubgroupLtMask => write!(f, " {}", "SubgroupLtMask"),
            BuiltIn::BaseVertex => write!(f, " {}", "BaseVertex"),
            BuiltIn::BaseInstance => write!(f, " {}", "BaseInstance"),
            BuiltIn::DrawIndex => write!(f, " {}", "DrawIndex"),
            BuiltIn::DeviceIndex => write!(f, " {}", "DeviceIndex"),
            BuiltIn::ViewIndex => write!(f, " {}", "ViewIndex"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum Scope {
    CrossDevice,
    Device,
    Workgroup,
    Subgroup,
    Invocation,
    QueueFamily,
}
impl SPIRVParse for Scope {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Scope::CrossDevice, words)),
            1u32 => Ok((Scope::Device, words)),
            2u32 => Ok((Scope::Workgroup, words)),
            3u32 => Ok((Scope::Subgroup, words)),
            4u32 => Ok((Scope::Invocation, words)),
            5u32 => Ok((Scope::QueueFamily, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Scope {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Scope::CrossDevice => write!(f, " {}", "CrossDevice"),
            Scope::Device => write!(f, " {}", "Device"),
            Scope::Workgroup => write!(f, " {}", "Workgroup"),
            Scope::Subgroup => write!(f, " {}", "Subgroup"),
            Scope::Invocation => write!(f, " {}", "Invocation"),
            Scope::QueueFamily => write!(f, " {}", "QueueFamily"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum GroupOperation {
    Reduce,
    InclusiveScan,
    ExclusiveScan,
    ClusteredReduce,
}
impl SPIRVParse for GroupOperation {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((GroupOperation::Reduce, words)),
            1u32 => Ok((GroupOperation::InclusiveScan, words)),
            2u32 => Ok((GroupOperation::ExclusiveScan, words)),
            3u32 => Ok((GroupOperation::ClusteredReduce, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for GroupOperation {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            GroupOperation::Reduce => write!(f, " {}", "Reduce"),
            GroupOperation::InclusiveScan => write!(f, " {}", "InclusiveScan"),
            GroupOperation::ExclusiveScan => write!(f, " {}", "ExclusiveScan"),
            GroupOperation::ClusteredReduce => write!(f, " {}", "ClusteredReduce"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum KernelEnqueueFlags {
    NoWait,
    WaitKernel,
    WaitWorkGroup,
}
impl SPIRVParse for KernelEnqueueFlags {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((KernelEnqueueFlags::NoWait, words)),
            1u32 => Ok((KernelEnqueueFlags::WaitKernel, words)),
            2u32 => Ok((KernelEnqueueFlags::WaitWorkGroup, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for KernelEnqueueFlags {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            KernelEnqueueFlags::NoWait => write!(f, " {}", "NoWait"),
            KernelEnqueueFlags::WaitKernel => write!(f, " {}", "WaitKernel"),
            KernelEnqueueFlags::WaitWorkGroup => write!(f, " {}", "WaitWorkGroup"),
        }
    }
}
#[derive(Clone, Debug, Eq, PartialEq, Hash, Copy)]
pub enum Capability {
    Matrix,
    Shader,
    Geometry,
    Tessellation,
    Addresses,
    Linkage,
    Kernel,
    Vector16,
    Float16Buffer,
    Float16,
    Float64,
    Int64,
    Int64Atomics,
    ImageBasic,
    ImageReadWrite,
    ImageMipmap,
    Pipes,
    Groups,
    DeviceEnqueue,
    LiteralSampler,
    AtomicStorage,
    Int16,
    TessellationPointSize,
    GeometryPointSize,
    ImageGatherExtended,
    StorageImageMultisample,
    UniformBufferArrayDynamicIndexing,
    SampledImageArrayDynamicIndexing,
    StorageBufferArrayDynamicIndexing,
    StorageImageArrayDynamicIndexing,
    ClipDistance,
    CullDistance,
    ImageCubeArray,
    SampleRateShading,
    ImageRect,
    SampledRect,
    GenericPointer,
    Int8,
    InputAttachment,
    SparseResidency,
    MinLod,
    Sampled1D,
    Image1D,
    SampledCubeArray,
    SampledBuffer,
    ImageBuffer,
    ImageMSArray,
    StorageImageExtendedFormats,
    ImageQuery,
    DerivativeControl,
    InterpolationFunction,
    TransformFeedback,
    GeometryStreams,
    StorageImageReadWithoutFormat,
    StorageImageWriteWithoutFormat,
    MultiViewport,
    SubgroupDispatch,
    NamedBarrier,
    PipeStorage,
    GroupNonUniform,
    GroupNonUniformVote,
    GroupNonUniformArithmetic,
    GroupNonUniformBallot,
    GroupNonUniformShuffle,
    GroupNonUniformShuffleRelative,
    GroupNonUniformClustered,
    GroupNonUniformQuad,
    ShaderLayer,
    ShaderViewportIndex,
    DrawParameters,
    StorageBuffer16BitAccess,
    UniformAndStorageBuffer16BitAccess,
    StoragePushConstant16,
    StorageInputOutput16,
    DeviceGroup,
    MultiView,
    VariablePointersStorageBuffer,
    VariablePointers,
    StorageBuffer8BitAccess,
    UniformAndStorageBuffer8BitAccess,
    StoragePushConstant8,
    DenormPreserve,
    DenormFlushToZero,
    SignedZeroInfNanPreserve,
    RoundingModeRTE,
    RoundingModeRTZ,
    ShaderNonUniform,
    RuntimeDescriptorArray,
    InputAttachmentArrayDynamicIndexing,
    UniformTexelBufferArrayDynamicIndexing,
    StorageTexelBufferArrayDynamicIndexing,
    UniformBufferArrayNonUniformIndexing,
    SampledImageArrayNonUniformIndexing,
    StorageBufferArrayNonUniformIndexing,
    StorageImageArrayNonUniformIndexing,
    InputAttachmentArrayNonUniformIndexing,
    UniformTexelBufferArrayNonUniformIndexing,
    StorageTexelBufferArrayNonUniformIndexing,
    VulkanMemoryModel,
    VulkanMemoryModelDeviceScope,
    PhysicalStorageBufferAddresses,
}
impl SPIRVParse for Capability {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (enumerant, words) = u32::spirv_parse(words, parse_state)?;
        match enumerant {
            0u32 => Ok((Capability::Matrix, words)),
            1u32 => Ok((Capability::Shader, words)),
            2u32 => Ok((Capability::Geometry, words)),
            3u32 => Ok((Capability::Tessellation, words)),
            4u32 => Ok((Capability::Addresses, words)),
            5u32 => Ok((Capability::Linkage, words)),
            6u32 => Ok((Capability::Kernel, words)),
            7u32 => Ok((Capability::Vector16, words)),
            8u32 => Ok((Capability::Float16Buffer, words)),
            9u32 => Ok((Capability::Float16, words)),
            10u32 => Ok((Capability::Float64, words)),
            11u32 => Ok((Capability::Int64, words)),
            12u32 => Ok((Capability::Int64Atomics, words)),
            13u32 => Ok((Capability::ImageBasic, words)),
            14u32 => Ok((Capability::ImageReadWrite, words)),
            15u32 => Ok((Capability::ImageMipmap, words)),
            17u32 => Ok((Capability::Pipes, words)),
            18u32 => Ok((Capability::Groups, words)),
            19u32 => Ok((Capability::DeviceEnqueue, words)),
            20u32 => Ok((Capability::LiteralSampler, words)),
            21u32 => Ok((Capability::AtomicStorage, words)),
            22u32 => Ok((Capability::Int16, words)),
            23u32 => Ok((Capability::TessellationPointSize, words)),
            24u32 => Ok((Capability::GeometryPointSize, words)),
            25u32 => Ok((Capability::ImageGatherExtended, words)),
            27u32 => Ok((Capability::StorageImageMultisample, words)),
            28u32 => Ok((Capability::UniformBufferArrayDynamicIndexing, words)),
            29u32 => Ok((Capability::SampledImageArrayDynamicIndexing, words)),
            30u32 => Ok((Capability::StorageBufferArrayDynamicIndexing, words)),
            31u32 => Ok((Capability::StorageImageArrayDynamicIndexing, words)),
            32u32 => Ok((Capability::ClipDistance, words)),
            33u32 => Ok((Capability::CullDistance, words)),
            34u32 => Ok((Capability::ImageCubeArray, words)),
            35u32 => Ok((Capability::SampleRateShading, words)),
            36u32 => Ok((Capability::ImageRect, words)),
            37u32 => Ok((Capability::SampledRect, words)),
            38u32 => Ok((Capability::GenericPointer, words)),
            39u32 => Ok((Capability::Int8, words)),
            40u32 => Ok((Capability::InputAttachment, words)),
            41u32 => Ok((Capability::SparseResidency, words)),
            42u32 => Ok((Capability::MinLod, words)),
            43u32 => Ok((Capability::Sampled1D, words)),
            44u32 => Ok((Capability::Image1D, words)),
            45u32 => Ok((Capability::SampledCubeArray, words)),
            46u32 => Ok((Capability::SampledBuffer, words)),
            47u32 => Ok((Capability::ImageBuffer, words)),
            48u32 => Ok((Capability::ImageMSArray, words)),
            49u32 => Ok((Capability::StorageImageExtendedFormats, words)),
            50u32 => Ok((Capability::ImageQuery, words)),
            51u32 => Ok((Capability::DerivativeControl, words)),
            52u32 => Ok((Capability::InterpolationFunction, words)),
            53u32 => Ok((Capability::TransformFeedback, words)),
            54u32 => Ok((Capability::GeometryStreams, words)),
            55u32 => Ok((Capability::StorageImageReadWithoutFormat, words)),
            56u32 => Ok((Capability::StorageImageWriteWithoutFormat, words)),
            57u32 => Ok((Capability::MultiViewport, words)),
            58u32 => Ok((Capability::SubgroupDispatch, words)),
            59u32 => Ok((Capability::NamedBarrier, words)),
            60u32 => Ok((Capability::PipeStorage, words)),
            61u32 => Ok((Capability::GroupNonUniform, words)),
            62u32 => Ok((Capability::GroupNonUniformVote, words)),
            63u32 => Ok((Capability::GroupNonUniformArithmetic, words)),
            64u32 => Ok((Capability::GroupNonUniformBallot, words)),
            65u32 => Ok((Capability::GroupNonUniformShuffle, words)),
            66u32 => Ok((Capability::GroupNonUniformShuffleRelative, words)),
            67u32 => Ok((Capability::GroupNonUniformClustered, words)),
            68u32 => Ok((Capability::GroupNonUniformQuad, words)),
            69u32 => Ok((Capability::ShaderLayer, words)),
            70u32 => Ok((Capability::ShaderViewportIndex, words)),
            4427u32 => Ok((Capability::DrawParameters, words)),
            4433u32 => Ok((Capability::StorageBuffer16BitAccess, words)),
            4434u32 => Ok((Capability::UniformAndStorageBuffer16BitAccess, words)),
            4435u32 => Ok((Capability::StoragePushConstant16, words)),
            4436u32 => Ok((Capability::StorageInputOutput16, words)),
            4437u32 => Ok((Capability::DeviceGroup, words)),
            4439u32 => Ok((Capability::MultiView, words)),
            4441u32 => Ok((Capability::VariablePointersStorageBuffer, words)),
            4442u32 => Ok((Capability::VariablePointers, words)),
            4448u32 => Ok((Capability::StorageBuffer8BitAccess, words)),
            4449u32 => Ok((Capability::UniformAndStorageBuffer8BitAccess, words)),
            4450u32 => Ok((Capability::StoragePushConstant8, words)),
            4464u32 => Ok((Capability::DenormPreserve, words)),
            4465u32 => Ok((Capability::DenormFlushToZero, words)),
            4466u32 => Ok((Capability::SignedZeroInfNanPreserve, words)),
            4467u32 => Ok((Capability::RoundingModeRTE, words)),
            4468u32 => Ok((Capability::RoundingModeRTZ, words)),
            5301u32 => Ok((Capability::ShaderNonUniform, words)),
            5302u32 => Ok((Capability::RuntimeDescriptorArray, words)),
            5303u32 => Ok((Capability::InputAttachmentArrayDynamicIndexing, words)),
            5304u32 => Ok((Capability::UniformTexelBufferArrayDynamicIndexing, words)),
            5305u32 => Ok((Capability::StorageTexelBufferArrayDynamicIndexing, words)),
            5306u32 => Ok((Capability::UniformBufferArrayNonUniformIndexing, words)),
            5307u32 => Ok((Capability::SampledImageArrayNonUniformIndexing, words)),
            5308u32 => Ok((Capability::StorageBufferArrayNonUniformIndexing, words)),
            5309u32 => Ok((Capability::StorageImageArrayNonUniformIndexing, words)),
            5310u32 => Ok((Capability::InputAttachmentArrayNonUniformIndexing, words)),
            5311u32 => Ok((Capability::UniformTexelBufferArrayNonUniformIndexing, words)),
            5312u32 => Ok((Capability::StorageTexelBufferArrayNonUniformIndexing, words)),
            5345u32 => Ok((Capability::VulkanMemoryModel, words)),
            5346u32 => Ok((Capability::VulkanMemoryModelDeviceScope, words)),
            5347u32 => Ok((Capability::PhysicalStorageBufferAddresses, words)),
            _ => Err(Error::InvalidEnumValue),
        }
    }
}
impl SPIRVDisplay for Capability {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Capability::Matrix => write!(f, " {}", "Matrix"),
            Capability::Shader => write!(f, " {}", "Shader"),
            Capability::Geometry => write!(f, " {}", "Geometry"),
            Capability::Tessellation => write!(f, " {}", "Tessellation"),
            Capability::Addresses => write!(f, " {}", "Addresses"),
            Capability::Linkage => write!(f, " {}", "Linkage"),
            Capability::Kernel => write!(f, " {}", "Kernel"),
            Capability::Vector16 => write!(f, " {}", "Vector16"),
            Capability::Float16Buffer => write!(f, " {}", "Float16Buffer"),
            Capability::Float16 => write!(f, " {}", "Float16"),
            Capability::Float64 => write!(f, " {}", "Float64"),
            Capability::Int64 => write!(f, " {}", "Int64"),
            Capability::Int64Atomics => write!(f, " {}", "Int64Atomics"),
            Capability::ImageBasic => write!(f, " {}", "ImageBasic"),
            Capability::ImageReadWrite => write!(f, " {}", "ImageReadWrite"),
            Capability::ImageMipmap => write!(f, " {}", "ImageMipmap"),
            Capability::Pipes => write!(f, " {}", "Pipes"),
            Capability::Groups => write!(f, " {}", "Groups"),
            Capability::DeviceEnqueue => write!(f, " {}", "DeviceEnqueue"),
            Capability::LiteralSampler => write!(f, " {}", "LiteralSampler"),
            Capability::AtomicStorage => write!(f, " {}", "AtomicStorage"),
            Capability::Int16 => write!(f, " {}", "Int16"),
            Capability::TessellationPointSize => write!(f, " {}", "TessellationPointSize"),
            Capability::GeometryPointSize => write!(f, " {}", "GeometryPointSize"),
            Capability::ImageGatherExtended => write!(f, " {}", "ImageGatherExtended"),
            Capability::StorageImageMultisample => write!(f, " {}", "StorageImageMultisample"),
            Capability::UniformBufferArrayDynamicIndexing => {
                write!(f, " {}", "UniformBufferArrayDynamicIndexing")
            }
            Capability::SampledImageArrayDynamicIndexing => {
                write!(f, " {}", "SampledImageArrayDynamicIndexing")
            }
            Capability::StorageBufferArrayDynamicIndexing => {
                write!(f, " {}", "StorageBufferArrayDynamicIndexing")
            }
            Capability::StorageImageArrayDynamicIndexing => {
                write!(f, " {}", "StorageImageArrayDynamicIndexing")
            }
            Capability::ClipDistance => write!(f, " {}", "ClipDistance"),
            Capability::CullDistance => write!(f, " {}", "CullDistance"),
            Capability::ImageCubeArray => write!(f, " {}", "ImageCubeArray"),
            Capability::SampleRateShading => write!(f, " {}", "SampleRateShading"),
            Capability::ImageRect => write!(f, " {}", "ImageRect"),
            Capability::SampledRect => write!(f, " {}", "SampledRect"),
            Capability::GenericPointer => write!(f, " {}", "GenericPointer"),
            Capability::Int8 => write!(f, " {}", "Int8"),
            Capability::InputAttachment => write!(f, " {}", "InputAttachment"),
            Capability::SparseResidency => write!(f, " {}", "SparseResidency"),
            Capability::MinLod => write!(f, " {}", "MinLod"),
            Capability::Sampled1D => write!(f, " {}", "Sampled1D"),
            Capability::Image1D => write!(f, " {}", "Image1D"),
            Capability::SampledCubeArray => write!(f, " {}", "SampledCubeArray"),
            Capability::SampledBuffer => write!(f, " {}", "SampledBuffer"),
            Capability::ImageBuffer => write!(f, " {}", "ImageBuffer"),
            Capability::ImageMSArray => write!(f, " {}", "ImageMSArray"),
            Capability::StorageImageExtendedFormats => {
                write!(f, " {}", "StorageImageExtendedFormats")
            }
            Capability::ImageQuery => write!(f, " {}", "ImageQuery"),
            Capability::DerivativeControl => write!(f, " {}", "DerivativeControl"),
            Capability::InterpolationFunction => write!(f, " {}", "InterpolationFunction"),
            Capability::TransformFeedback => write!(f, " {}", "TransformFeedback"),
            Capability::GeometryStreams => write!(f, " {}", "GeometryStreams"),
            Capability::StorageImageReadWithoutFormat => {
                write!(f, " {}", "StorageImageReadWithoutFormat")
            }
            Capability::StorageImageWriteWithoutFormat => {
                write!(f, " {}", "StorageImageWriteWithoutFormat")
            }
            Capability::MultiViewport => write!(f, " {}", "MultiViewport"),
            Capability::SubgroupDispatch => write!(f, " {}", "SubgroupDispatch"),
            Capability::NamedBarrier => write!(f, " {}", "NamedBarrier"),
            Capability::PipeStorage => write!(f, " {}", "PipeStorage"),
            Capability::GroupNonUniform => write!(f, " {}", "GroupNonUniform"),
            Capability::GroupNonUniformVote => write!(f, " {}", "GroupNonUniformVote"),
            Capability::GroupNonUniformArithmetic => write!(f, " {}", "GroupNonUniformArithmetic"),
            Capability::GroupNonUniformBallot => write!(f, " {}", "GroupNonUniformBallot"),
            Capability::GroupNonUniformShuffle => write!(f, " {}", "GroupNonUniformShuffle"),
            Capability::GroupNonUniformShuffleRelative => {
                write!(f, " {}", "GroupNonUniformShuffleRelative")
            }
            Capability::GroupNonUniformClustered => write!(f, " {}", "GroupNonUniformClustered"),
            Capability::GroupNonUniformQuad => write!(f, " {}", "GroupNonUniformQuad"),
            Capability::ShaderLayer => write!(f, " {}", "ShaderLayer"),
            Capability::ShaderViewportIndex => write!(f, " {}", "ShaderViewportIndex"),
            Capability::DrawParameters => write!(f, " {}", "DrawParameters"),
            Capability::StorageBuffer16BitAccess => write!(f, " {}", "StorageBuffer16BitAccess"),
            Capability::UniformAndStorageBuffer16BitAccess => {
                write!(f, " {}", "UniformAndStorageBuffer16BitAccess")
            }
            Capability::StoragePushConstant16 => write!(f, " {}", "StoragePushConstant16"),
            Capability::StorageInputOutput16 => write!(f, " {}", "StorageInputOutput16"),
            Capability::DeviceGroup => write!(f, " {}", "DeviceGroup"),
            Capability::MultiView => write!(f, " {}", "MultiView"),
            Capability::VariablePointersStorageBuffer => {
                write!(f, " {}", "VariablePointersStorageBuffer")
            }
            Capability::VariablePointers => write!(f, " {}", "VariablePointers"),
            Capability::StorageBuffer8BitAccess => write!(f, " {}", "StorageBuffer8BitAccess"),
            Capability::UniformAndStorageBuffer8BitAccess => {
                write!(f, " {}", "UniformAndStorageBuffer8BitAccess")
            }
            Capability::StoragePushConstant8 => write!(f, " {}", "StoragePushConstant8"),
            Capability::DenormPreserve => write!(f, " {}", "DenormPreserve"),
            Capability::DenormFlushToZero => write!(f, " {}", "DenormFlushToZero"),
            Capability::SignedZeroInfNanPreserve => write!(f, " {}", "SignedZeroInfNanPreserve"),
            Capability::RoundingModeRTE => write!(f, " {}", "RoundingModeRTE"),
            Capability::RoundingModeRTZ => write!(f, " {}", "RoundingModeRTZ"),
            Capability::ShaderNonUniform => write!(f, " {}", "ShaderNonUniform"),
            Capability::RuntimeDescriptorArray => write!(f, " {}", "RuntimeDescriptorArray"),
            Capability::InputAttachmentArrayDynamicIndexing => {
                write!(f, " {}", "InputAttachmentArrayDynamicIndexing")
            }
            Capability::UniformTexelBufferArrayDynamicIndexing => {
                write!(f, " {}", "UniformTexelBufferArrayDynamicIndexing")
            }
            Capability::StorageTexelBufferArrayDynamicIndexing => {
                write!(f, " {}", "StorageTexelBufferArrayDynamicIndexing")
            }
            Capability::UniformBufferArrayNonUniformIndexing => {
                write!(f, " {}", "UniformBufferArrayNonUniformIndexing")
            }
            Capability::SampledImageArrayNonUniformIndexing => {
                write!(f, " {}", "SampledImageArrayNonUniformIndexing")
            }
            Capability::StorageBufferArrayNonUniformIndexing => {
                write!(f, " {}", "StorageBufferArrayNonUniformIndexing")
            }
            Capability::StorageImageArrayNonUniformIndexing => {
                write!(f, " {}", "StorageImageArrayNonUniformIndexing")
            }
            Capability::InputAttachmentArrayNonUniformIndexing => {
                write!(f, " {}", "InputAttachmentArrayNonUniformIndexing")
            }
            Capability::UniformTexelBufferArrayNonUniformIndexing => {
                write!(f, " {}", "UniformTexelBufferArrayNonUniformIndexing")
            }
            Capability::StorageTexelBufferArrayNonUniformIndexing => {
                write!(f, " {}", "StorageTexelBufferArrayNonUniformIndexing")
            }
            Capability::VulkanMemoryModel => write!(f, " {}", "VulkanMemoryModel"),
            Capability::VulkanMemoryModelDeviceScope => {
                write!(f, " {}", "VulkanMemoryModelDeviceScope")
            }
            Capability::PhysicalStorageBufferAddresses => {
                write!(f, " {}", "PhysicalStorageBufferAddresses")
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdResultType(pub IdRef);
impl SPIRVParse for IdResultType {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state).map(|(value, words)| (IdResultType(value), words))
    }
}
impl fmt::Display for IdResultType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdResultType {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdResult(pub IdRef);
impl SPIRVParse for IdResult {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state).map(|(value, words)| (IdResult(value), words))
    }
}
impl fmt::Display for IdResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdResult {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdMemorySemantics(pub IdRef);
impl SPIRVParse for IdMemorySemantics {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state)
            .map(|(value, words)| (IdMemorySemantics(value), words))
    }
}
impl fmt::Display for IdMemorySemantics {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdMemorySemantics {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdScope(pub IdRef);
impl SPIRVParse for IdScope {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        IdRef::spirv_parse(words, parse_state).map(|(value, words)| (IdScope(value), words))
    }
}
impl fmt::Display for IdScope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
impl SPIRVDisplay for IdScope {
    fn spirv_display(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.spirv_display(f)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default)]
#[repr(transparent)]
pub struct IdRef(pub u32);
pub type LiteralInteger32 = u32;
pub type LiteralInteger64 = u64;
pub type LiteralString = String;
pub type LiteralContextDependentNumber32 = u32;
pub type LiteralContextDependentNumber64 = u64;
pub type LiteralExtInstInteger = u32;
pub type PairLiteralInteger32IdRef = (LiteralInteger32, IdRef);
pub type PairLiteralInteger64IdRef = (LiteralInteger64, IdRef);
pub type PairIdRefLiteralInteger = (IdRef, LiteralInteger32);
pub type PairIdRefIdRef = (IdRef, IdRef);
#[derive(Clone, Debug)]
pub enum OpSpecConstantOp {
    AccessChain(OpAccessChain),
    InBoundsAccessChain(OpInBoundsAccessChain),
    PtrAccessChain(OpPtrAccessChain),
    InBoundsPtrAccessChain(OpInBoundsPtrAccessChain),
    VectorShuffle(OpVectorShuffle),
    CompositeExtract(OpCompositeExtract),
    CompositeInsert(OpCompositeInsert),
    ConvertFToU(OpConvertFToU),
    ConvertFToS(OpConvertFToS),
    ConvertSToF(OpConvertSToF),
    ConvertUToF(OpConvertUToF),
    UConvert(OpUConvert),
    SConvert(OpSConvert),
    FConvert(OpFConvert),
    QuantizeToF16(OpQuantizeToF16),
    ConvertPtrToU(OpConvertPtrToU),
    ConvertUToPtr(OpConvertUToPtr),
    PtrCastToGeneric(OpPtrCastToGeneric),
    GenericCastToPtr(OpGenericCastToPtr),
    Bitcast(OpBitcast),
    SNegate(OpSNegate),
    FNegate(OpFNegate),
    IAdd(OpIAdd),
    FAdd(OpFAdd),
    ISub(OpISub),
    FSub(OpFSub),
    IMul(OpIMul),
    FMul(OpFMul),
    UDiv(OpUDiv),
    SDiv(OpSDiv),
    FDiv(OpFDiv),
    UMod(OpUMod),
    SRem(OpSRem),
    SMod(OpSMod),
    FRem(OpFRem),
    FMod(OpFMod),
    LogicalEqual(OpLogicalEqual),
    LogicalNotEqual(OpLogicalNotEqual),
    LogicalOr(OpLogicalOr),
    LogicalAnd(OpLogicalAnd),
    LogicalNot(OpLogicalNot),
    Select(OpSelect),
    IEqual(OpIEqual),
    INotEqual(OpINotEqual),
    UGreaterThan(OpUGreaterThan),
    SGreaterThan(OpSGreaterThan),
    UGreaterThanEqual(OpUGreaterThanEqual),
    SGreaterThanEqual(OpSGreaterThanEqual),
    ULessThan(OpULessThan),
    SLessThan(OpSLessThan),
    ULessThanEqual(OpULessThanEqual),
    SLessThanEqual(OpSLessThanEqual),
    ShiftRightLogical(OpShiftRightLogical),
    ShiftRightArithmetic(OpShiftRightArithmetic),
    ShiftLeftLogical(OpShiftLeftLogical),
    BitwiseOr(OpBitwiseOr),
    BitwiseXor(OpBitwiseXor),
    BitwiseAnd(OpBitwiseAnd),
    Not(OpNot),
}
impl fmt::Display for OpSpecConstantOp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            OpSpecConstantOp::AccessChain(OpAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "AccessChain")?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::InBoundsAccessChain(OpInBoundsAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "InBoundsAccessChain")?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::PtrAccessChain(OpPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "PtrAccessChain")?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::InBoundsPtrAccessChain(OpInBoundsPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "InBoundsPtrAccessChain")?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::VectorShuffle(OpVectorShuffle {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
                components,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "VectorShuffle")?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                components.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::CompositeExtract(OpCompositeExtract {
                id_result_type,
                id_result,
                composite,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "CompositeExtract")?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::CompositeInsert(OpCompositeInsert {
                id_result_type,
                id_result,
                object,
                composite,
                indexes,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "CompositeInsert")?;
                object.spirv_display(f)?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertFToU(OpConvertFToU {
                id_result_type,
                id_result,
                float_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertFToU")?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertFToS(OpConvertFToS {
                id_result_type,
                id_result,
                float_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertFToS")?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertSToF(OpConvertSToF {
                id_result_type,
                id_result,
                signed_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertSToF")?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertUToF(OpConvertUToF {
                id_result_type,
                id_result,
                unsigned_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertUToF")?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UConvert(OpUConvert {
                id_result_type,
                id_result,
                unsigned_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UConvert")?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SConvert(OpSConvert {
                id_result_type,
                id_result,
                signed_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SConvert")?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FConvert(OpFConvert {
                id_result_type,
                id_result,
                float_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FConvert")?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::QuantizeToF16(OpQuantizeToF16 {
                id_result_type,
                id_result,
                value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "QuantizeToF16")?;
                value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertPtrToU(OpConvertPtrToU {
                id_result_type,
                id_result,
                pointer,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertPtrToU")?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ConvertUToPtr(OpConvertUToPtr {
                id_result_type,
                id_result,
                integer_value,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ConvertUToPtr")?;
                integer_value.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::PtrCastToGeneric(OpPtrCastToGeneric {
                id_result_type,
                id_result,
                pointer,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "PtrCastToGeneric")?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::GenericCastToPtr(OpGenericCastToPtr {
                id_result_type,
                id_result,
                pointer,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "GenericCastToPtr")?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::Bitcast(OpBitcast {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "Bitcast")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SNegate(OpSNegate {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SNegate")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FNegate(OpFNegate {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FNegate")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::IAdd(OpIAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "IAdd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FAdd(OpFAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FAdd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ISub(OpISub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ISub")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FSub(OpFSub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FSub")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::IMul(OpIMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "IMul")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FMul(OpFMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FMul")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UDiv(OpUDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UDiv")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SDiv(OpSDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SDiv")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FDiv(OpFDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FDiv")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UMod(OpUMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UMod")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SRem(OpSRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SRem")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SMod(OpSMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SMod")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FRem(OpFRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FRem")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::FMod(OpFMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "FMod")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalEqual(OpLogicalEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalNotEqual(OpLogicalNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalNotEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalOr(OpLogicalOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalOr")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalAnd(OpLogicalAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalAnd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::LogicalNot(OpLogicalNot {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "LogicalNot")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::Select(OpSelect {
                id_result_type,
                id_result,
                condition,
                object_1,
                object_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "Select")?;
                condition.spirv_display(f)?;
                object_1.spirv_display(f)?;
                object_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::IEqual(OpIEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "IEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::INotEqual(OpINotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "INotEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UGreaterThan(OpUGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UGreaterThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SGreaterThan(OpSGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SGreaterThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::UGreaterThanEqual(OpUGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "UGreaterThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SGreaterThanEqual(OpSGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SGreaterThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ULessThan(OpULessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ULessThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SLessThan(OpSLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SLessThan")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ULessThanEqual(OpULessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ULessThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::SLessThanEqual(OpSLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "SLessThanEqual")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ShiftRightLogical(OpShiftRightLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ShiftRightLogical")?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ShiftRightArithmetic(OpShiftRightArithmetic {
                id_result_type,
                id_result,
                base,
                shift,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ShiftRightArithmetic")?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::ShiftLeftLogical(OpShiftLeftLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "ShiftLeftLogical")?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::BitwiseOr(OpBitwiseOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "BitwiseOr")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::BitwiseXor(OpBitwiseXor {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "BitwiseXor")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::BitwiseAnd(OpBitwiseAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "BitwiseAnd")?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }
            OpSpecConstantOp::Not(OpNot {
                id_result_type,
                id_result,
                operand,
            }) => {
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantOp"
                )?;
                id_result_type.spirv_display(f)?;
                write!(f, " {}", "Not")?;
                operand.spirv_display(f)?;
                writeln!(f)
            }
        }
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpNop;
impl From<OpNop> for Instruction {
    fn from(v: OpNop) -> Self {
        Self::Nop(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUndef {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpUndef> for Instruction {
    fn from(v: OpUndef) -> Self {
        Self::Undef(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSourceContinued {
    pub continued_source: LiteralString,
}
impl From<OpSourceContinued> for Instruction {
    fn from(v: OpSourceContinued) -> Self {
        Self::SourceContinued(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSource {
    pub source_language: SourceLanguage,
    pub version: LiteralInteger32,
    pub file: Option<IdRef>,
    pub source: Option<LiteralString>,
}
impl From<OpSource> for Instruction {
    fn from(v: OpSource) -> Self {
        Self::Source(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSourceExtension {
    pub extension: LiteralString,
}
impl From<OpSourceExtension> for Instruction {
    fn from(v: OpSourceExtension) -> Self {
        Self::SourceExtension(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpName {
    pub target: IdRef,
    pub name: LiteralString,
}
impl From<OpName> for Instruction {
    fn from(v: OpName) -> Self {
        Self::Name(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemberName {
    pub type_: IdRef,
    pub member: LiteralInteger32,
    pub name: LiteralString,
}
impl From<OpMemberName> for Instruction {
    fn from(v: OpMemberName) -> Self {
        Self::MemberName(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpString {
    pub id_result: IdResult,
    pub string: LiteralString,
}
impl From<OpString> for Instruction {
    fn from(v: OpString) -> Self {
        Self::String(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLine {
    pub file: IdRef,
    pub line: LiteralInteger32,
    pub column: LiteralInteger32,
}
impl From<OpLine> for Instruction {
    fn from(v: OpLine) -> Self {
        Self::Line(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExtension {
    pub name: LiteralString,
}
impl From<OpExtension> for Instruction {
    fn from(v: OpExtension) -> Self {
        Self::Extension(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExtInstImport {
    pub id_result: IdResult,
    pub name: LiteralString,
}
impl From<OpExtInstImport> for Instruction {
    fn from(v: OpExtInstImport) -> Self {
        Self::ExtInstImport(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExtInst {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub instruction: LiteralExtInstInteger,
    pub operands: Vec<LiteralInteger32>,
}
impl From<OpExtInst> for Instruction {
    fn from(v: OpExtInst) -> Self {
        Self::ExtInst(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemoryModel {
    pub addressing_model: AddressingModel,
    pub memory_model: MemoryModel,
}
impl From<OpMemoryModel> for Instruction {
    fn from(v: OpMemoryModel) -> Self {
        Self::MemoryModel(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEntryPoint {
    pub execution_model: ExecutionModel,
    pub entry_point: IdRef,
    pub name: LiteralString,
    pub interface: Vec<IdRef>,
}
impl From<OpEntryPoint> for Instruction {
    fn from(v: OpEntryPoint) -> Self {
        Self::EntryPoint(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExecutionMode {
    pub entry_point: IdRef,
    pub mode: ExecutionMode,
}
impl From<OpExecutionMode> for Instruction {
    fn from(v: OpExecutionMode) -> Self {
        Self::ExecutionMode(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCapability {
    pub capability: Capability,
}
impl From<OpCapability> for Instruction {
    fn from(v: OpCapability) -> Self {
        Self::Capability(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeVoid {
    pub id_result: IdResult,
}
impl From<OpTypeVoid> for Instruction {
    fn from(v: OpTypeVoid) -> Self {
        Self::TypeVoid(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeBool {
    pub id_result: IdResult,
}
impl From<OpTypeBool> for Instruction {
    fn from(v: OpTypeBool) -> Self {
        Self::TypeBool(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeInt {
    pub id_result: IdResult,
    pub width: LiteralInteger32,
    pub signedness: LiteralInteger32,
}
impl From<OpTypeInt> for Instruction {
    fn from(v: OpTypeInt) -> Self {
        Self::TypeInt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeFloat {
    pub id_result: IdResult,
    pub width: LiteralInteger32,
}
impl From<OpTypeFloat> for Instruction {
    fn from(v: OpTypeFloat) -> Self {
        Self::TypeFloat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeVector {
    pub id_result: IdResult,
    pub component_type: IdRef,
    pub component_count: LiteralInteger32,
}
impl From<OpTypeVector> for Instruction {
    fn from(v: OpTypeVector) -> Self {
        Self::TypeVector(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeMatrix {
    pub id_result: IdResult,
    pub column_type: IdRef,
    pub column_count: LiteralInteger32,
}
impl From<OpTypeMatrix> for Instruction {
    fn from(v: OpTypeMatrix) -> Self {
        Self::TypeMatrix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeImage {
    pub id_result: IdResult,
    pub sampled_type: IdRef,
    pub dim: Dim,
    pub depth: LiteralInteger32,
    pub arrayed: LiteralInteger32,
    pub ms: LiteralInteger32,
    pub sampled: LiteralInteger32,
    pub image_format: ImageFormat,
    pub access_qualifier: Option<AccessQualifier>,
}
impl From<OpTypeImage> for Instruction {
    fn from(v: OpTypeImage) -> Self {
        Self::TypeImage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeSampler {
    pub id_result: IdResult,
}
impl From<OpTypeSampler> for Instruction {
    fn from(v: OpTypeSampler) -> Self {
        Self::TypeSampler(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeSampledImage {
    pub id_result: IdResult,
    pub image_type: IdRef,
}
impl From<OpTypeSampledImage> for Instruction {
    fn from(v: OpTypeSampledImage) -> Self {
        Self::TypeSampledImage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeArray {
    pub id_result: IdResult,
    pub element_type: IdRef,
    pub length: IdRef,
}
impl From<OpTypeArray> for Instruction {
    fn from(v: OpTypeArray) -> Self {
        Self::TypeArray(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeRuntimeArray {
    pub id_result: IdResult,
    pub element_type: IdRef,
}
impl From<OpTypeRuntimeArray> for Instruction {
    fn from(v: OpTypeRuntimeArray) -> Self {
        Self::TypeRuntimeArray(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeStruct {
    pub id_result: IdResult,
    pub member_types: Vec<IdRef>,
}
impl From<OpTypeStruct> for Instruction {
    fn from(v: OpTypeStruct) -> Self {
        Self::TypeStruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeOpaque {
    pub id_result: IdResult,
    pub the_name_of_the_opaque_type: LiteralString,
}
impl From<OpTypeOpaque> for Instruction {
    fn from(v: OpTypeOpaque) -> Self {
        Self::TypeOpaque(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypePointer {
    pub id_result: IdResult,
    pub storage_class: StorageClass,
    pub type_: IdRef,
}
impl From<OpTypePointer> for Instruction {
    fn from(v: OpTypePointer) -> Self {
        Self::TypePointer(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeFunction {
    pub id_result: IdResult,
    pub return_type: IdRef,
    pub parameter_types: Vec<IdRef>,
}
impl From<OpTypeFunction> for Instruction {
    fn from(v: OpTypeFunction) -> Self {
        Self::TypeFunction(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeEvent {
    pub id_result: IdResult,
}
impl From<OpTypeEvent> for Instruction {
    fn from(v: OpTypeEvent) -> Self {
        Self::TypeEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeDeviceEvent {
    pub id_result: IdResult,
}
impl From<OpTypeDeviceEvent> for Instruction {
    fn from(v: OpTypeDeviceEvent) -> Self {
        Self::TypeDeviceEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeReserveId {
    pub id_result: IdResult,
}
impl From<OpTypeReserveId> for Instruction {
    fn from(v: OpTypeReserveId) -> Self {
        Self::TypeReserveId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeQueue {
    pub id_result: IdResult,
}
impl From<OpTypeQueue> for Instruction {
    fn from(v: OpTypeQueue) -> Self {
        Self::TypeQueue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypePipe {
    pub id_result: IdResult,
    pub qualifier: AccessQualifier,
}
impl From<OpTypePipe> for Instruction {
    fn from(v: OpTypePipe) -> Self {
        Self::TypePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeForwardPointer {
    pub pointer_type: IdRef,
    pub storage_class: StorageClass,
}
impl From<OpTypeForwardPointer> for Instruction {
    fn from(v: OpTypeForwardPointer) -> Self {
        Self::TypeForwardPointer(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantTrue {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpConstantTrue> for Instruction {
    fn from(v: OpConstantTrue) -> Self {
        Self::ConstantTrue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantFalse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpConstantFalse> for Instruction {
    fn from(v: OpConstantFalse) -> Self {
        Self::ConstantFalse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstant32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber32,
}
impl From<OpConstant32> for Instruction {
    fn from(v: OpConstant32) -> Self {
        Self::Constant32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstant64 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber64,
}
impl From<OpConstant64> for Instruction {
    fn from(v: OpConstant64) -> Self {
        Self::Constant64(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantComposite {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub constituents: Vec<IdRef>,
}
impl From<OpConstantComposite> for Instruction {
    fn from(v: OpConstantComposite) -> Self {
        Self::ConstantComposite(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantSampler {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampler_addressing_mode: SamplerAddressingMode,
    pub param: LiteralInteger32,
    pub sampler_filter_mode: SamplerFilterMode,
}
impl From<OpConstantSampler> for Instruction {
    fn from(v: OpConstantSampler) -> Self {
        Self::ConstantSampler(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantNull {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpConstantNull> for Instruction {
    fn from(v: OpConstantNull) -> Self {
        Self::ConstantNull(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstantTrue {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpSpecConstantTrue> for Instruction {
    fn from(v: OpSpecConstantTrue) -> Self {
        Self::SpecConstantTrue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstantFalse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpSpecConstantFalse> for Instruction {
    fn from(v: OpSpecConstantFalse) -> Self {
        Self::SpecConstantFalse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstant32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber32,
}
impl From<OpSpecConstant32> for Instruction {
    fn from(v: OpSpecConstant32) -> Self {
        Self::SpecConstant32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstant64 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: LiteralContextDependentNumber64,
}
impl From<OpSpecConstant64> for Instruction {
    fn from(v: OpSpecConstant64) -> Self {
        Self::SpecConstant64(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSpecConstantComposite {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub constituents: Vec<IdRef>,
}
impl From<OpSpecConstantComposite> for Instruction {
    fn from(v: OpSpecConstantComposite) -> Self {
        Self::SpecConstantComposite(v)
    }
}
impl From<OpSpecConstantOp> for Instruction {
    fn from(v: OpSpecConstantOp) -> Self {
        Self::SpecConstantOp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFunction {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub function_control: FunctionControl,
    pub function_type: IdRef,
}
impl From<OpFunction> for Instruction {
    fn from(v: OpFunction) -> Self {
        Self::Function(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFunctionParameter {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpFunctionParameter> for Instruction {
    fn from(v: OpFunctionParameter) -> Self {
        Self::FunctionParameter(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpFunctionEnd;
impl From<OpFunctionEnd> for Instruction {
    fn from(v: OpFunctionEnd) -> Self {
        Self::FunctionEnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFunctionCall {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub function: IdRef,
    pub arguments: Vec<IdRef>,
}
impl From<OpFunctionCall> for Instruction {
    fn from(v: OpFunctionCall) -> Self {
        Self::FunctionCall(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVariable {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub storage_class: StorageClass,
    pub initializer: Option<IdRef>,
}
impl From<OpVariable> for Instruction {
    fn from(v: OpVariable) -> Self {
        Self::Variable(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageTexelPointer {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub sample: IdRef,
}
impl From<OpImageTexelPointer> for Instruction {
    fn from(v: OpImageTexelPointer) -> Self {
        Self::ImageTexelPointer(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLoad {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory_access: Option<MemoryAccess>,
}
impl From<OpLoad> for Instruction {
    fn from(v: OpLoad) -> Self {
        Self::Load(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpStore {
    pub pointer: IdRef,
    pub object: IdRef,
    pub memory_access: Option<MemoryAccess>,
}
impl From<OpStore> for Instruction {
    fn from(v: OpStore) -> Self {
        Self::Store(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyMemory {
    pub target: IdRef,
    pub source: IdRef,
    pub memory_access: Option<MemoryAccess>,
    pub source_memory_access: Option<MemoryAccess>,
}
impl From<OpCopyMemory> for Instruction {
    fn from(v: OpCopyMemory) -> Self {
        Self::CopyMemory(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyMemorySized {
    pub target: IdRef,
    pub source: IdRef,
    pub size: IdRef,
    pub memory_access: Option<MemoryAccess>,
    pub source_memory_access: Option<MemoryAccess>,
}
impl From<OpCopyMemorySized> for Instruction {
    fn from(v: OpCopyMemorySized) -> Self {
        Self::CopyMemorySized(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpAccessChain> for Instruction {
    fn from(v: OpAccessChain) -> Self {
        Self::AccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpInBoundsAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpInBoundsAccessChain> for Instruction {
    fn from(v: OpInBoundsAccessChain) -> Self {
        Self::InBoundsAccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub element: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpPtrAccessChain> for Instruction {
    fn from(v: OpPtrAccessChain) -> Self {
        Self::PtrAccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpArrayLength {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub structure: IdRef,
    pub array_member: LiteralInteger32,
}
impl From<OpArrayLength> for Instruction {
    fn from(v: OpArrayLength) -> Self {
        Self::ArrayLength(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGenericPtrMemSemantics {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpGenericPtrMemSemantics> for Instruction {
    fn from(v: OpGenericPtrMemSemantics) -> Self {
        Self::GenericPtrMemSemantics(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpInBoundsPtrAccessChain {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub element: IdRef,
    pub indexes: Vec<IdRef>,
}
impl From<OpInBoundsPtrAccessChain> for Instruction {
    fn from(v: OpInBoundsPtrAccessChain) -> Self {
        Self::InBoundsPtrAccessChain(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorate {
    pub target: IdRef,
    pub decoration: Decoration,
}
impl From<OpDecorate> for Instruction {
    fn from(v: OpDecorate) -> Self {
        Self::Decorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemberDecorate {
    pub structure_type: IdRef,
    pub member: LiteralInteger32,
    pub decoration: Decoration,
}
impl From<OpMemberDecorate> for Instruction {
    fn from(v: OpMemberDecorate) -> Self {
        Self::MemberDecorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorationGroup {
    pub id_result: IdResult,
}
impl From<OpDecorationGroup> for Instruction {
    fn from(v: OpDecorationGroup) -> Self {
        Self::DecorationGroup(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupDecorate {
    pub decoration_group: IdRef,
    pub targets: Vec<IdRef>,
}
impl From<OpGroupDecorate> for Instruction {
    fn from(v: OpGroupDecorate) -> Self {
        Self::GroupDecorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupMemberDecorate {
    pub decoration_group: IdRef,
    pub targets: Vec<PairIdRefLiteralInteger>,
}
impl From<OpGroupMemberDecorate> for Instruction {
    fn from(v: OpGroupMemberDecorate) -> Self {
        Self::GroupMemberDecorate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorExtractDynamic {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub index: IdRef,
}
impl From<OpVectorExtractDynamic> for Instruction {
    fn from(v: OpVectorExtractDynamic) -> Self {
        Self::VectorExtractDynamic(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorInsertDynamic {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub component: IdRef,
    pub index: IdRef,
}
impl From<OpVectorInsertDynamic> for Instruction {
    fn from(v: OpVectorInsertDynamic) -> Self {
        Self::VectorInsertDynamic(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorShuffle {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector_1: IdRef,
    pub vector_2: IdRef,
    pub components: Vec<LiteralInteger32>,
}
impl From<OpVectorShuffle> for Instruction {
    fn from(v: OpVectorShuffle) -> Self {
        Self::VectorShuffle(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCompositeConstruct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub constituents: Vec<IdRef>,
}
impl From<OpCompositeConstruct> for Instruction {
    fn from(v: OpCompositeConstruct) -> Self {
        Self::CompositeConstruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCompositeExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub composite: IdRef,
    pub indexes: Vec<LiteralInteger32>,
}
impl From<OpCompositeExtract> for Instruction {
    fn from(v: OpCompositeExtract) -> Self {
        Self::CompositeExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCompositeInsert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub object: IdRef,
    pub composite: IdRef,
    pub indexes: Vec<LiteralInteger32>,
}
impl From<OpCompositeInsert> for Instruction {
    fn from(v: OpCompositeInsert) -> Self {
        Self::CompositeInsert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyObject {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpCopyObject> for Instruction {
    fn from(v: OpCopyObject) -> Self {
        Self::CopyObject(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTranspose {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub matrix: IdRef,
}
impl From<OpTranspose> for Instruction {
    fn from(v: OpTranspose) -> Self {
        Self::Transpose(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSampledImage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub sampler: IdRef,
}
impl From<OpSampledImage> for Instruction {
    fn from(v: OpSampledImage) -> Self {
        Self::SampledImage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleImplicitLod> for Instruction {
    fn from(v: OpImageSampleImplicitLod) -> Self {
        Self::ImageSampleImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleExplicitLod> for Instruction {
    fn from(v: OpImageSampleExplicitLod) -> Self {
        Self::ImageSampleExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleDrefImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleDrefImplicitLod> for Instruction {
    fn from(v: OpImageSampleDrefImplicitLod) -> Self {
        Self::ImageSampleDrefImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleDrefExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleDrefExplicitLod> for Instruction {
    fn from(v: OpImageSampleDrefExplicitLod) -> Self {
        Self::ImageSampleDrefExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleProjImplicitLod> for Instruction {
    fn from(v: OpImageSampleProjImplicitLod) -> Self {
        Self::ImageSampleProjImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleProjExplicitLod> for Instruction {
    fn from(v: OpImageSampleProjExplicitLod) -> Self {
        Self::ImageSampleProjExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjDrefImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSampleProjDrefImplicitLod> for Instruction {
    fn from(v: OpImageSampleProjDrefImplicitLod) -> Self {
        Self::ImageSampleProjDrefImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSampleProjDrefExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSampleProjDrefExplicitLod> for Instruction {
    fn from(v: OpImageSampleProjDrefExplicitLod) -> Self {
        Self::ImageSampleProjDrefExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageFetch {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageFetch> for Instruction {
    fn from(v: OpImageFetch) -> Self {
        Self::ImageFetch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub component: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageGather> for Instruction {
    fn from(v: OpImageGather) -> Self {
        Self::ImageGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageDrefGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageDrefGather> for Instruction {
    fn from(v: OpImageDrefGather) -> Self {
        Self::ImageDrefGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageRead {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageRead> for Instruction {
    fn from(v: OpImageRead) -> Self {
        Self::ImageRead(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageWrite {
    pub image: IdRef,
    pub coordinate: IdRef,
    pub texel: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageWrite> for Instruction {
    fn from(v: OpImageWrite) -> Self {
        Self::ImageWrite(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
}
impl From<OpImage> for Instruction {
    fn from(v: OpImage) -> Self {
        Self::Image(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryFormat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQueryFormat> for Instruction {
    fn from(v: OpImageQueryFormat) -> Self {
        Self::ImageQueryFormat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryOrder {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQueryOrder> for Instruction {
    fn from(v: OpImageQueryOrder) -> Self {
        Self::ImageQueryOrder(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQuerySizeLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub level_of_detail: IdRef,
}
impl From<OpImageQuerySizeLod> for Instruction {
    fn from(v: OpImageQuerySizeLod) -> Self {
        Self::ImageQuerySizeLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQuerySize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQuerySize> for Instruction {
    fn from(v: OpImageQuerySize) -> Self {
        Self::ImageQuerySize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
}
impl From<OpImageQueryLod> for Instruction {
    fn from(v: OpImageQueryLod) -> Self {
        Self::ImageQueryLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQueryLevels {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQueryLevels> for Instruction {
    fn from(v: OpImageQueryLevels) -> Self {
        Self::ImageQueryLevels(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageQuerySamples {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
}
impl From<OpImageQuerySamples> for Instruction {
    fn from(v: OpImageQuerySamples) -> Self {
        Self::ImageQuerySamples(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertFToU {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub float_value: IdRef,
}
impl From<OpConvertFToU> for Instruction {
    fn from(v: OpConvertFToU) -> Self {
        Self::ConvertFToU(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertFToS {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub float_value: IdRef,
}
impl From<OpConvertFToS> for Instruction {
    fn from(v: OpConvertFToS) -> Self {
        Self::ConvertFToS(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertSToF {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub signed_value: IdRef,
}
impl From<OpConvertSToF> for Instruction {
    fn from(v: OpConvertSToF) -> Self {
        Self::ConvertSToF(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertUToF {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub unsigned_value: IdRef,
}
impl From<OpConvertUToF> for Instruction {
    fn from(v: OpConvertUToF) -> Self {
        Self::ConvertUToF(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUConvert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub unsigned_value: IdRef,
}
impl From<OpUConvert> for Instruction {
    fn from(v: OpUConvert) -> Self {
        Self::UConvert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSConvert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub signed_value: IdRef,
}
impl From<OpSConvert> for Instruction {
    fn from(v: OpSConvert) -> Self {
        Self::SConvert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFConvert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub float_value: IdRef,
}
impl From<OpFConvert> for Instruction {
    fn from(v: OpFConvert) -> Self {
        Self::FConvert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpQuantizeToF16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub value: IdRef,
}
impl From<OpQuantizeToF16> for Instruction {
    fn from(v: OpQuantizeToF16) -> Self {
        Self::QuantizeToF16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertPtrToU {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpConvertPtrToU> for Instruction {
    fn from(v: OpConvertPtrToU) -> Self {
        Self::ConvertPtrToU(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSatConvertSToU {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub signed_value: IdRef,
}
impl From<OpSatConvertSToU> for Instruction {
    fn from(v: OpSatConvertSToU) -> Self {
        Self::SatConvertSToU(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSatConvertUToS {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub unsigned_value: IdRef,
}
impl From<OpSatConvertUToS> for Instruction {
    fn from(v: OpSatConvertUToS) -> Self {
        Self::SatConvertUToS(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConvertUToPtr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub integer_value: IdRef,
}
impl From<OpConvertUToPtr> for Instruction {
    fn from(v: OpConvertUToPtr) -> Self {
        Self::ConvertUToPtr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrCastToGeneric {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpPtrCastToGeneric> for Instruction {
    fn from(v: OpPtrCastToGeneric) -> Self {
        Self::PtrCastToGeneric(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGenericCastToPtr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpGenericCastToPtr> for Instruction {
    fn from(v: OpGenericCastToPtr) -> Self {
        Self::GenericCastToPtr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGenericCastToPtrExplicit {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub storage: StorageClass,
}
impl From<OpGenericCastToPtrExplicit> for Instruction {
    fn from(v: OpGenericCastToPtrExplicit) -> Self {
        Self::GenericCastToPtrExplicit(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpBitcast> for Instruction {
    fn from(v: OpBitcast) -> Self {
        Self::Bitcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSNegate {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpSNegate> for Instruction {
    fn from(v: OpSNegate) -> Self {
        Self::SNegate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFNegate {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpFNegate> for Instruction {
    fn from(v: OpFNegate) -> Self {
        Self::FNegate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIAdd> for Instruction {
    fn from(v: OpIAdd) -> Self {
        Self::IAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFAdd> for Instruction {
    fn from(v: OpFAdd) -> Self {
        Self::FAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpISub {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpISub> for Instruction {
    fn from(v: OpISub) -> Self {
        Self::ISub(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFSub {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFSub> for Instruction {
    fn from(v: OpFSub) -> Self {
        Self::FSub(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIMul> for Instruction {
    fn from(v: OpIMul) -> Self {
        Self::IMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFMul> for Instruction {
    fn from(v: OpFMul) -> Self {
        Self::FMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUDiv {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUDiv> for Instruction {
    fn from(v: OpUDiv) -> Self {
        Self::UDiv(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSDiv {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSDiv> for Instruction {
    fn from(v: OpSDiv) -> Self {
        Self::SDiv(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFDiv {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFDiv> for Instruction {
    fn from(v: OpFDiv) -> Self {
        Self::FDiv(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUMod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUMod> for Instruction {
    fn from(v: OpUMod) -> Self {
        Self::UMod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSRem {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSRem> for Instruction {
    fn from(v: OpSRem) -> Self {
        Self::SRem(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSMod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSMod> for Instruction {
    fn from(v: OpSMod) -> Self {
        Self::SMod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFRem {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFRem> for Instruction {
    fn from(v: OpFRem) -> Self {
        Self::FRem(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFMod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFMod> for Instruction {
    fn from(v: OpFMod) -> Self {
        Self::FMod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorTimesScalar {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub scalar: IdRef,
}
impl From<OpVectorTimesScalar> for Instruction {
    fn from(v: OpVectorTimesScalar) -> Self {
        Self::VectorTimesScalar(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMatrixTimesScalar {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub matrix: IdRef,
    pub scalar: IdRef,
}
impl From<OpMatrixTimesScalar> for Instruction {
    fn from(v: OpMatrixTimesScalar) -> Self {
        Self::MatrixTimesScalar(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpVectorTimesMatrix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
    pub matrix: IdRef,
}
impl From<OpVectorTimesMatrix> for Instruction {
    fn from(v: OpVectorTimesMatrix) -> Self {
        Self::VectorTimesMatrix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMatrixTimesVector {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub matrix: IdRef,
    pub vector: IdRef,
}
impl From<OpMatrixTimesVector> for Instruction {
    fn from(v: OpMatrixTimesVector) -> Self {
        Self::MatrixTimesVector(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMatrixTimesMatrix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub left_matrix: IdRef,
    pub right_matrix: IdRef,
}
impl From<OpMatrixTimesMatrix> for Instruction {
    fn from(v: OpMatrixTimesMatrix) -> Self {
        Self::MatrixTimesMatrix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOuterProduct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector_1: IdRef,
    pub vector_2: IdRef,
}
impl From<OpOuterProduct> for Instruction {
    fn from(v: OpOuterProduct) -> Self {
        Self::OuterProduct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector_1: IdRef,
    pub vector_2: IdRef,
}
impl From<OpDot> for Instruction {
    fn from(v: OpDot) -> Self {
        Self::Dot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIAddCarry {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIAddCarry> for Instruction {
    fn from(v: OpIAddCarry) -> Self {
        Self::IAddCarry(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpISubBorrow {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpISubBorrow> for Instruction {
    fn from(v: OpISubBorrow) -> Self {
        Self::ISubBorrow(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUMulExtended {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUMulExtended> for Instruction {
    fn from(v: OpUMulExtended) -> Self {
        Self::UMulExtended(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSMulExtended {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSMulExtended> for Instruction {
    fn from(v: OpSMulExtended) -> Self {
        Self::SMulExtended(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAny {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
}
impl From<OpAny> for Instruction {
    fn from(v: OpAny) -> Self {
        Self::Any(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAll {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub vector: IdRef,
}
impl From<OpAll> for Instruction {
    fn from(v: OpAll) -> Self {
        Self::All(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsNan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsNan> for Instruction {
    fn from(v: OpIsNan) -> Self {
        Self::IsNan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsInf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsInf> for Instruction {
    fn from(v: OpIsInf) -> Self {
        Self::IsInf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsFinite {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsFinite> for Instruction {
    fn from(v: OpIsFinite) -> Self {
        Self::IsFinite(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsNormal {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpIsNormal> for Instruction {
    fn from(v: OpIsNormal) -> Self {
        Self::IsNormal(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSignBitSet {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
}
impl From<OpSignBitSet> for Instruction {
    fn from(v: OpSignBitSet) -> Self {
        Self::SignBitSet(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLessOrGreater {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpLessOrGreater> for Instruction {
    fn from(v: OpLessOrGreater) -> Self {
        Self::LessOrGreater(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOrdered {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOrdered> for Instruction {
    fn from(v: OpOrdered) -> Self {
        Self::Ordered(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUnordered {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpUnordered> for Instruction {
    fn from(v: OpUnordered) -> Self {
        Self::Unordered(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalEqual> for Instruction {
    fn from(v: OpLogicalEqual) -> Self {
        Self::LogicalEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalNotEqual> for Instruction {
    fn from(v: OpLogicalNotEqual) -> Self {
        Self::LogicalNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalOr> for Instruction {
    fn from(v: OpLogicalOr) -> Self {
        Self::LogicalOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpLogicalAnd> for Instruction {
    fn from(v: OpLogicalAnd) -> Self {
        Self::LogicalAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLogicalNot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpLogicalNot> for Instruction {
    fn from(v: OpLogicalNot) -> Self {
        Self::LogicalNot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSelect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub condition: IdRef,
    pub object_1: IdRef,
    pub object_2: IdRef,
}
impl From<OpSelect> for Instruction {
    fn from(v: OpSelect) -> Self {
        Self::Select(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpIEqual> for Instruction {
    fn from(v: OpIEqual) -> Self {
        Self::IEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpINotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpINotEqual> for Instruction {
    fn from(v: OpINotEqual) -> Self {
        Self::INotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUGreaterThan> for Instruction {
    fn from(v: OpUGreaterThan) -> Self {
        Self::UGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSGreaterThan> for Instruction {
    fn from(v: OpSGreaterThan) -> Self {
        Self::SGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpUGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpUGreaterThanEqual> for Instruction {
    fn from(v: OpUGreaterThanEqual) -> Self {
        Self::UGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSGreaterThanEqual> for Instruction {
    fn from(v: OpSGreaterThanEqual) -> Self {
        Self::SGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpULessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpULessThan> for Instruction {
    fn from(v: OpULessThan) -> Self {
        Self::ULessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSLessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSLessThan> for Instruction {
    fn from(v: OpSLessThan) -> Self {
        Self::SLessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpULessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpULessThanEqual> for Instruction {
    fn from(v: OpULessThanEqual) -> Self {
        Self::ULessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSLessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpSLessThanEqual> for Instruction {
    fn from(v: OpSLessThanEqual) -> Self {
        Self::SLessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdEqual> for Instruction {
    fn from(v: OpFOrdEqual) -> Self {
        Self::FOrdEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordEqual> for Instruction {
    fn from(v: OpFUnordEqual) -> Self {
        Self::FUnordEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdNotEqual> for Instruction {
    fn from(v: OpFOrdNotEqual) -> Self {
        Self::FOrdNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordNotEqual> for Instruction {
    fn from(v: OpFUnordNotEqual) -> Self {
        Self::FUnordNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdLessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdLessThan> for Instruction {
    fn from(v: OpFOrdLessThan) -> Self {
        Self::FOrdLessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordLessThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordLessThan> for Instruction {
    fn from(v: OpFUnordLessThan) -> Self {
        Self::FUnordLessThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdGreaterThan> for Instruction {
    fn from(v: OpFOrdGreaterThan) -> Self {
        Self::FOrdGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordGreaterThan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordGreaterThan> for Instruction {
    fn from(v: OpFUnordGreaterThan) -> Self {
        Self::FUnordGreaterThan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdLessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdLessThanEqual> for Instruction {
    fn from(v: OpFOrdLessThanEqual) -> Self {
        Self::FOrdLessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordLessThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordLessThanEqual> for Instruction {
    fn from(v: OpFUnordLessThanEqual) -> Self {
        Self::FUnordLessThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFOrdGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFOrdGreaterThanEqual> for Instruction {
    fn from(v: OpFOrdGreaterThanEqual) -> Self {
        Self::FOrdGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFUnordGreaterThanEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpFUnordGreaterThanEqual> for Instruction {
    fn from(v: OpFUnordGreaterThanEqual) -> Self {
        Self::FUnordGreaterThanEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpShiftRightLogical {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub shift: IdRef,
}
impl From<OpShiftRightLogical> for Instruction {
    fn from(v: OpShiftRightLogical) -> Self {
        Self::ShiftRightLogical(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpShiftRightArithmetic {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub shift: IdRef,
}
impl From<OpShiftRightArithmetic> for Instruction {
    fn from(v: OpShiftRightArithmetic) -> Self {
        Self::ShiftRightArithmetic(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpShiftLeftLogical {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub shift: IdRef,
}
impl From<OpShiftLeftLogical> for Instruction {
    fn from(v: OpShiftLeftLogical) -> Self {
        Self::ShiftLeftLogical(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitwiseOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpBitwiseOr> for Instruction {
    fn from(v: OpBitwiseOr) -> Self {
        Self::BitwiseOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitwiseXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpBitwiseXor> for Instruction {
    fn from(v: OpBitwiseXor) -> Self {
        Self::BitwiseXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitwiseAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpBitwiseAnd> for Instruction {
    fn from(v: OpBitwiseAnd) -> Self {
        Self::BitwiseAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpNot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpNot> for Instruction {
    fn from(v: OpNot) -> Self {
        Self::Not(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitFieldInsert {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub insert: IdRef,
    pub offset: IdRef,
    pub count: IdRef,
}
impl From<OpBitFieldInsert> for Instruction {
    fn from(v: OpBitFieldInsert) -> Self {
        Self::BitFieldInsert(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitFieldSExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub offset: IdRef,
    pub count: IdRef,
}
impl From<OpBitFieldSExtract> for Instruction {
    fn from(v: OpBitFieldSExtract) -> Self {
        Self::BitFieldSExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitFieldUExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
    pub offset: IdRef,
    pub count: IdRef,
}
impl From<OpBitFieldUExtract> for Instruction {
    fn from(v: OpBitFieldUExtract) -> Self {
        Self::BitFieldUExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitReverse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
}
impl From<OpBitReverse> for Instruction {
    fn from(v: OpBitReverse) -> Self {
        Self::BitReverse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBitCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub base: IdRef,
}
impl From<OpBitCount> for Instruction {
    fn from(v: OpBitCount) -> Self {
        Self::BitCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdx {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdx> for Instruction {
    fn from(v: OpDPdx) -> Self {
        Self::DPdx(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdy {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdy> for Instruction {
    fn from(v: OpDPdy) -> Self {
        Self::DPdy(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFwidth {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpFwidth> for Instruction {
    fn from(v: OpFwidth) -> Self {
        Self::Fwidth(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdxFine {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdxFine> for Instruction {
    fn from(v: OpDPdxFine) -> Self {
        Self::DPdxFine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdyFine {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdyFine> for Instruction {
    fn from(v: OpDPdyFine) -> Self {
        Self::DPdyFine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFwidthFine {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpFwidthFine> for Instruction {
    fn from(v: OpFwidthFine) -> Self {
        Self::FwidthFine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdxCoarse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdxCoarse> for Instruction {
    fn from(v: OpDPdxCoarse) -> Self {
        Self::DPdxCoarse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDPdyCoarse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpDPdyCoarse> for Instruction {
    fn from(v: OpDPdyCoarse) -> Self {
        Self::DPdyCoarse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpFwidthCoarse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub p: IdRef,
}
impl From<OpFwidthCoarse> for Instruction {
    fn from(v: OpFwidthCoarse) -> Self {
        Self::FwidthCoarse(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpEmitVertex;
impl From<OpEmitVertex> for Instruction {
    fn from(v: OpEmitVertex) -> Self {
        Self::EmitVertex(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpEndPrimitive;
impl From<OpEndPrimitive> for Instruction {
    fn from(v: OpEndPrimitive) -> Self {
        Self::EndPrimitive(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEmitStreamVertex {
    pub stream: IdRef,
}
impl From<OpEmitStreamVertex> for Instruction {
    fn from(v: OpEmitStreamVertex) -> Self {
        Self::EmitStreamVertex(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEndStreamPrimitive {
    pub stream: IdRef,
}
impl From<OpEndStreamPrimitive> for Instruction {
    fn from(v: OpEndStreamPrimitive) -> Self {
        Self::EndStreamPrimitive(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpControlBarrier {
    pub execution: IdScope,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpControlBarrier> for Instruction {
    fn from(v: OpControlBarrier) -> Self {
        Self::ControlBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemoryBarrier {
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpMemoryBarrier> for Instruction {
    fn from(v: OpMemoryBarrier) -> Self {
        Self::MemoryBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicLoad {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicLoad> for Instruction {
    fn from(v: OpAtomicLoad) -> Self {
        Self::AtomicLoad(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicStore {
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicStore> for Instruction {
    fn from(v: OpAtomicStore) -> Self {
        Self::AtomicStore(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicExchange {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicExchange> for Instruction {
    fn from(v: OpAtomicExchange) -> Self {
        Self::AtomicExchange(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicCompareExchange {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub equal: IdMemorySemantics,
    pub unequal: IdMemorySemantics,
    pub value: IdRef,
    pub comparator: IdRef,
}
impl From<OpAtomicCompareExchange> for Instruction {
    fn from(v: OpAtomicCompareExchange) -> Self {
        Self::AtomicCompareExchange(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicCompareExchangeWeak {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub equal: IdMemorySemantics,
    pub unequal: IdMemorySemantics,
    pub value: IdRef,
    pub comparator: IdRef,
}
impl From<OpAtomicCompareExchangeWeak> for Instruction {
    fn from(v: OpAtomicCompareExchangeWeak) -> Self {
        Self::AtomicCompareExchangeWeak(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicIIncrement {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicIIncrement> for Instruction {
    fn from(v: OpAtomicIIncrement) -> Self {
        Self::AtomicIIncrement(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicIDecrement {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicIDecrement> for Instruction {
    fn from(v: OpAtomicIDecrement) -> Self {
        Self::AtomicIDecrement(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicIAdd> for Instruction {
    fn from(v: OpAtomicIAdd) -> Self {
        Self::AtomicIAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicISub {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicISub> for Instruction {
    fn from(v: OpAtomicISub) -> Self {
        Self::AtomicISub(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicSMin> for Instruction {
    fn from(v: OpAtomicSMin) -> Self {
        Self::AtomicSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicUMin> for Instruction {
    fn from(v: OpAtomicUMin) -> Self {
        Self::AtomicUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicSMax> for Instruction {
    fn from(v: OpAtomicSMax) -> Self {
        Self::AtomicSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicUMax> for Instruction {
    fn from(v: OpAtomicUMax) -> Self {
        Self::AtomicUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicAnd> for Instruction {
    fn from(v: OpAtomicAnd) -> Self {
        Self::AtomicAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicOr> for Instruction {
    fn from(v: OpAtomicOr) -> Self {
        Self::AtomicOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
    pub value: IdRef,
}
impl From<OpAtomicXor> for Instruction {
    fn from(v: OpAtomicXor) -> Self {
        Self::AtomicXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPhi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub variable_parent: Vec<PairIdRefIdRef>,
}
impl From<OpPhi> for Instruction {
    fn from(v: OpPhi) -> Self {
        Self::Phi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLoopMerge {
    pub merge_block: IdRef,
    pub continue_target: IdRef,
    pub loop_control: LoopControl,
}
impl From<OpLoopMerge> for Instruction {
    fn from(v: OpLoopMerge) -> Self {
        Self::LoopMerge(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSelectionMerge {
    pub merge_block: IdRef,
    pub selection_control: SelectionControl,
}
impl From<OpSelectionMerge> for Instruction {
    fn from(v: OpSelectionMerge) -> Self {
        Self::SelectionMerge(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLabel {
    pub id_result: IdResult,
}
impl From<OpLabel> for Instruction {
    fn from(v: OpLabel) -> Self {
        Self::Label(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBranch {
    pub target_label: IdRef,
}
impl From<OpBranch> for Instruction {
    fn from(v: OpBranch) -> Self {
        Self::Branch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBranchConditional {
    pub condition: IdRef,
    pub true_label: IdRef,
    pub false_label: IdRef,
    pub branch_weights: Vec<LiteralInteger32>,
}
impl From<OpBranchConditional> for Instruction {
    fn from(v: OpBranchConditional) -> Self {
        Self::BranchConditional(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSwitch32 {
    pub selector: IdRef,
    pub default: IdRef,
    pub target: Vec<PairLiteralInteger32IdRef>,
}
impl From<OpSwitch32> for Instruction {
    fn from(v: OpSwitch32) -> Self {
        Self::Switch32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSwitch64 {
    pub selector: IdRef,
    pub default: IdRef,
    pub target: Vec<PairLiteralInteger64IdRef>,
}
impl From<OpSwitch64> for Instruction {
    fn from(v: OpSwitch64) -> Self {
        Self::Switch64(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpKill;
impl From<OpKill> for Instruction {
    fn from(v: OpKill) -> Self {
        Self::Kill(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpReturn;
impl From<OpReturn> for Instruction {
    fn from(v: OpReturn) -> Self {
        Self::Return(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReturnValue {
    pub value: IdRef,
}
impl From<OpReturnValue> for Instruction {
    fn from(v: OpReturnValue) -> Self {
        Self::ReturnValue(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpUnreachable;
impl From<OpUnreachable> for Instruction {
    fn from(v: OpUnreachable) -> Self {
        Self::Unreachable(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLifetimeStart {
    pub pointer: IdRef,
    pub size: LiteralInteger32,
}
impl From<OpLifetimeStart> for Instruction {
    fn from(v: OpLifetimeStart) -> Self {
        Self::LifetimeStart(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpLifetimeStop {
    pub pointer: IdRef,
    pub size: LiteralInteger32,
}
impl From<OpLifetimeStop> for Instruction {
    fn from(v: OpLifetimeStop) -> Self {
        Self::LifetimeStop(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupAsyncCopy {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub destination: IdRef,
    pub source: IdRef,
    pub num_elements: IdRef,
    pub stride: IdRef,
    pub event: IdRef,
}
impl From<OpGroupAsyncCopy> for Instruction {
    fn from(v: OpGroupAsyncCopy) -> Self {
        Self::GroupAsyncCopy(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupWaitEvents {
    pub execution: IdScope,
    pub num_events: IdRef,
    pub events_list: IdRef,
}
impl From<OpGroupWaitEvents> for Instruction {
    fn from(v: OpGroupWaitEvents) -> Self {
        Self::GroupWaitEvents(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupAll {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupAll> for Instruction {
    fn from(v: OpGroupAll) -> Self {
        Self::GroupAll(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupAny {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupAny> for Instruction {
    fn from(v: OpGroupAny) -> Self {
        Self::GroupAny(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupBroadcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub local_id: IdRef,
}
impl From<OpGroupBroadcast> for Instruction {
    fn from(v: OpGroupBroadcast) -> Self {
        Self::GroupBroadcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupIAdd> for Instruction {
    fn from(v: OpGroupIAdd) -> Self {
        Self::GroupIAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupFAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupFAdd> for Instruction {
    fn from(v: OpGroupFAdd) -> Self {
        Self::GroupFAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupFMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupFMin> for Instruction {
    fn from(v: OpGroupFMin) -> Self {
        Self::GroupFMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupUMin> for Instruction {
    fn from(v: OpGroupUMin) -> Self {
        Self::GroupUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupSMin> for Instruction {
    fn from(v: OpGroupSMin) -> Self {
        Self::GroupSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupFMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupFMax> for Instruction {
    fn from(v: OpGroupFMax) -> Self {
        Self::GroupFMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupUMax> for Instruction {
    fn from(v: OpGroupUMax) -> Self {
        Self::GroupUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub x: IdRef,
}
impl From<OpGroupSMax> for Instruction {
    fn from(v: OpGroupSMax) -> Self {
        Self::GroupSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReadPipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReadPipe> for Instruction {
    fn from(v: OpReadPipe) -> Self {
        Self::ReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpWritePipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpWritePipe> for Instruction {
    fn from(v: OpWritePipe) -> Self {
        Self::WritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReservedReadPipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub index: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReservedReadPipe> for Instruction {
    fn from(v: OpReservedReadPipe) -> Self {
        Self::ReservedReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReservedWritePipe {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub index: IdRef,
    pub pointer: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReservedWritePipe> for Instruction {
    fn from(v: OpReservedWritePipe) -> Self {
        Self::ReservedWritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReserveReadPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReserveReadPipePackets> for Instruction {
    fn from(v: OpReserveReadPipePackets) -> Self {
        Self::ReserveReadPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReserveWritePipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpReserveWritePipePackets> for Instruction {
    fn from(v: OpReserveWritePipePackets) -> Self {
        Self::ReserveWritePipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCommitReadPipe {
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpCommitReadPipe> for Instruction {
    fn from(v: OpCommitReadPipe) -> Self {
        Self::CommitReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCommitWritePipe {
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpCommitWritePipe> for Instruction {
    fn from(v: OpCommitWritePipe) -> Self {
        Self::CommitWritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsValidReserveId {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub reserve_id: IdRef,
}
impl From<OpIsValidReserveId> for Instruction {
    fn from(v: OpIsValidReserveId) -> Self {
        Self::IsValidReserveId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetNumPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGetNumPipePackets> for Instruction {
    fn from(v: OpGetNumPipePackets) -> Self {
        Self::GetNumPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetMaxPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGetMaxPipePackets> for Instruction {
    fn from(v: OpGetMaxPipePackets) -> Self {
        Self::GetMaxPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupReserveReadPipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupReserveReadPipePackets> for Instruction {
    fn from(v: OpGroupReserveReadPipePackets) -> Self {
        Self::GroupReserveReadPipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupReserveWritePipePackets {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub pipe: IdRef,
    pub num_packets: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupReserveWritePipePackets> for Instruction {
    fn from(v: OpGroupReserveWritePipePackets) -> Self {
        Self::GroupReserveWritePipePackets(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupCommitReadPipe {
    pub execution: IdScope,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupCommitReadPipe> for Instruction {
    fn from(v: OpGroupCommitReadPipe) -> Self {
        Self::GroupCommitReadPipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupCommitWritePipe {
    pub execution: IdScope,
    pub pipe: IdRef,
    pub reserve_id: IdRef,
    pub packet_size: IdRef,
    pub packet_alignment: IdRef,
}
impl From<OpGroupCommitWritePipe> for Instruction {
    fn from(v: OpGroupCommitWritePipe) -> Self {
        Self::GroupCommitWritePipe(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEnqueueMarker {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub queue: IdRef,
    pub num_events: IdRef,
    pub wait_events: IdRef,
    pub ret_event: IdRef,
}
impl From<OpEnqueueMarker> for Instruction {
    fn from(v: OpEnqueueMarker) -> Self {
        Self::EnqueueMarker(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpEnqueueKernel {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub queue: IdRef,
    pub flags: IdRef,
    pub nd_range: IdRef,
    pub num_events: IdRef,
    pub wait_events: IdRef,
    pub ret_event: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
    pub local_size: Vec<IdRef>,
}
impl From<OpEnqueueKernel> for Instruction {
    fn from(v: OpEnqueueKernel) -> Self {
        Self::EnqueueKernel(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelNDrangeSubGroupCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub nd_range: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelNDrangeSubGroupCount> for Instruction {
    fn from(v: OpGetKernelNDrangeSubGroupCount) -> Self {
        Self::GetKernelNDrangeSubGroupCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelNDrangeMaxSubGroupSize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub nd_range: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelNDrangeMaxSubGroupSize> for Instruction {
    fn from(v: OpGetKernelNDrangeMaxSubGroupSize) -> Self {
        Self::GetKernelNDrangeMaxSubGroupSize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelWorkGroupSize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelWorkGroupSize> for Instruction {
    fn from(v: OpGetKernelWorkGroupSize) -> Self {
        Self::GetKernelWorkGroupSize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelPreferredWorkGroupSizeMultiple {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelPreferredWorkGroupSizeMultiple> for Instruction {
    fn from(v: OpGetKernelPreferredWorkGroupSizeMultiple) -> Self {
        Self::GetKernelPreferredWorkGroupSizeMultiple(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpRetainEvent {
    pub event: IdRef,
}
impl From<OpRetainEvent> for Instruction {
    fn from(v: OpRetainEvent) -> Self {
        Self::RetainEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpReleaseEvent {
    pub event: IdRef,
}
impl From<OpReleaseEvent> for Instruction {
    fn from(v: OpReleaseEvent) -> Self {
        Self::ReleaseEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCreateUserEvent {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpCreateUserEvent> for Instruction {
    fn from(v: OpCreateUserEvent) -> Self {
        Self::CreateUserEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpIsValidEvent {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub event: IdRef,
}
impl From<OpIsValidEvent> for Instruction {
    fn from(v: OpIsValidEvent) -> Self {
        Self::IsValidEvent(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSetUserEventStatus {
    pub event: IdRef,
    pub status: IdRef,
}
impl From<OpSetUserEventStatus> for Instruction {
    fn from(v: OpSetUserEventStatus) -> Self {
        Self::SetUserEventStatus(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCaptureEventProfilingInfo {
    pub event: IdRef,
    pub profiling_info: IdRef,
    pub value: IdRef,
}
impl From<OpCaptureEventProfilingInfo> for Instruction {
    fn from(v: OpCaptureEventProfilingInfo) -> Self {
        Self::CaptureEventProfilingInfo(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetDefaultQueue {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
}
impl From<OpGetDefaultQueue> for Instruction {
    fn from(v: OpGetDefaultQueue) -> Self {
        Self::GetDefaultQueue(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpBuildNDRange {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub global_work_size: IdRef,
    pub local_work_size: IdRef,
    pub global_work_offset: IdRef,
}
impl From<OpBuildNDRange> for Instruction {
    fn from(v: OpBuildNDRange) -> Self {
        Self::BuildNDRange(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseSampleImplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleImplicitLod) -> Self {
        Self::ImageSparseSampleImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSparseSampleExplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleExplicitLod) -> Self {
        Self::ImageSparseSampleExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleDrefImplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseSampleDrefImplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleDrefImplicitLod) -> Self {
        Self::ImageSparseSampleDrefImplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseSampleDrefExplicitLod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: ImageOperands,
}
impl From<OpImageSparseSampleDrefExplicitLod> for Instruction {
    fn from(v: OpImageSparseSampleDrefExplicitLod) -> Self {
        Self::ImageSparseSampleDrefExplicitLod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseFetch {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseFetch> for Instruction {
    fn from(v: OpImageSparseFetch) -> Self {
        Self::ImageSparseFetch(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub component: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseGather> for Instruction {
    fn from(v: OpImageSparseGather) -> Self {
        Self::ImageSparseGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseDrefGather {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub sampled_image: IdRef,
    pub coordinate: IdRef,
    pub d_ref: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseDrefGather> for Instruction {
    fn from(v: OpImageSparseDrefGather) -> Self {
        Self::ImageSparseDrefGather(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseTexelsResident {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub resident_code: IdRef,
}
impl From<OpImageSparseTexelsResident> for Instruction {
    fn from(v: OpImageSparseTexelsResident) -> Self {
        Self::ImageSparseTexelsResident(v)
    }
}
#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
pub struct OpNoLine;
impl From<OpNoLine> for Instruction {
    fn from(v: OpNoLine) -> Self {
        Self::NoLine(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicFlagTestAndSet {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicFlagTestAndSet> for Instruction {
    fn from(v: OpAtomicFlagTestAndSet) -> Self {
        Self::AtomicFlagTestAndSet(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpAtomicFlagClear {
    pub pointer: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpAtomicFlagClear> for Instruction {
    fn from(v: OpAtomicFlagClear) -> Self {
        Self::AtomicFlagClear(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpImageSparseRead {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub image: IdRef,
    pub coordinate: IdRef,
    pub image_operands: Option<ImageOperands>,
}
impl From<OpImageSparseRead> for Instruction {
    fn from(v: OpImageSparseRead) -> Self {
        Self::ImageSparseRead(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpSizeOf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pointer: IdRef,
}
impl From<OpSizeOf> for Instruction {
    fn from(v: OpSizeOf) -> Self {
        Self::SizeOf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypePipeStorage {
    pub id_result: IdResult,
}
impl From<OpTypePipeStorage> for Instruction {
    fn from(v: OpTypePipeStorage) -> Self {
        Self::TypePipeStorage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpConstantPipeStorage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub packet_size: LiteralInteger32,
    pub packet_alignment: LiteralInteger32,
    pub capacity: LiteralInteger32,
}
impl From<OpConstantPipeStorage> for Instruction {
    fn from(v: OpConstantPipeStorage) -> Self {
        Self::ConstantPipeStorage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCreatePipeFromPipeStorage {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub pipe_storage: IdRef,
}
impl From<OpCreatePipeFromPipeStorage> for Instruction {
    fn from(v: OpCreatePipeFromPipeStorage) -> Self {
        Self::CreatePipeFromPipeStorage(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelLocalSizeForSubgroupCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub subgroup_count: IdRef,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelLocalSizeForSubgroupCount> for Instruction {
    fn from(v: OpGetKernelLocalSizeForSubgroupCount) -> Self {
        Self::GetKernelLocalSizeForSubgroupCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGetKernelMaxNumSubgroups {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub invoke: IdRef,
    pub param: IdRef,
    pub param_size: IdRef,
    pub param_align: IdRef,
}
impl From<OpGetKernelMaxNumSubgroups> for Instruction {
    fn from(v: OpGetKernelMaxNumSubgroups) -> Self {
        Self::GetKernelMaxNumSubgroups(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpTypeNamedBarrier {
    pub id_result: IdResult,
}
impl From<OpTypeNamedBarrier> for Instruction {
    fn from(v: OpTypeNamedBarrier) -> Self {
        Self::TypeNamedBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpNamedBarrierInitialize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub subgroup_count: IdRef,
}
impl From<OpNamedBarrierInitialize> for Instruction {
    fn from(v: OpNamedBarrierInitialize) -> Self {
        Self::NamedBarrierInitialize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemoryNamedBarrier {
    pub named_barrier: IdRef,
    pub memory: IdScope,
    pub semantics: IdMemorySemantics,
}
impl From<OpMemoryNamedBarrier> for Instruction {
    fn from(v: OpMemoryNamedBarrier) -> Self {
        Self::MemoryNamedBarrier(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpModuleProcessed {
    pub process: LiteralString,
}
impl From<OpModuleProcessed> for Instruction {
    fn from(v: OpModuleProcessed) -> Self {
        Self::ModuleProcessed(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpExecutionModeId {
    pub entry_point: IdRef,
    pub mode: ExecutionMode,
}
impl From<OpExecutionModeId> for Instruction {
    fn from(v: OpExecutionModeId) -> Self {
        Self::ExecutionModeId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorateId {
    pub target: IdRef,
    pub decoration: Decoration,
}
impl From<OpDecorateId> for Instruction {
    fn from(v: OpDecorateId) -> Self {
        Self::DecorateId(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformElect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
}
impl From<OpGroupNonUniformElect> for Instruction {
    fn from(v: OpGroupNonUniformElect) -> Self {
        Self::GroupNonUniformElect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformAll {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupNonUniformAll> for Instruction {
    fn from(v: OpGroupNonUniformAll) -> Self {
        Self::GroupNonUniformAll(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformAny {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupNonUniformAny> for Instruction {
    fn from(v: OpGroupNonUniformAny) -> Self {
        Self::GroupNonUniformAny(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformAllEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformAllEqual> for Instruction {
    fn from(v: OpGroupNonUniformAllEqual) -> Self {
        Self::GroupNonUniformAllEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBroadcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub id: IdRef,
}
impl From<OpGroupNonUniformBroadcast> for Instruction {
    fn from(v: OpGroupNonUniformBroadcast) -> Self {
        Self::GroupNonUniformBroadcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBroadcastFirst {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBroadcastFirst> for Instruction {
    fn from(v: OpGroupNonUniformBroadcastFirst) -> Self {
        Self::GroupNonUniformBroadcastFirst(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub predicate: IdRef,
}
impl From<OpGroupNonUniformBallot> for Instruction {
    fn from(v: OpGroupNonUniformBallot) -> Self {
        Self::GroupNonUniformBallot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformInverseBallot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformInverseBallot> for Instruction {
    fn from(v: OpGroupNonUniformInverseBallot) -> Self {
        Self::GroupNonUniformInverseBallot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotBitExtract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub index: IdRef,
}
impl From<OpGroupNonUniformBallotBitExtract> for Instruction {
    fn from(v: OpGroupNonUniformBallotBitExtract) -> Self {
        Self::GroupNonUniformBallotBitExtract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotBitCount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBallotBitCount> for Instruction {
    fn from(v: OpGroupNonUniformBallotBitCount) -> Self {
        Self::GroupNonUniformBallotBitCount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotFindLSB {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBallotFindLSB> for Instruction {
    fn from(v: OpGroupNonUniformBallotFindLSB) -> Self {
        Self::GroupNonUniformBallotFindLSB(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBallotFindMSB {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
}
impl From<OpGroupNonUniformBallotFindMSB> for Instruction {
    fn from(v: OpGroupNonUniformBallotFindMSB) -> Self {
        Self::GroupNonUniformBallotFindMSB(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffle {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub id: IdRef,
}
impl From<OpGroupNonUniformShuffle> for Instruction {
    fn from(v: OpGroupNonUniformShuffle) -> Self {
        Self::GroupNonUniformShuffle(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffleXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub mask: IdRef,
}
impl From<OpGroupNonUniformShuffleXor> for Instruction {
    fn from(v: OpGroupNonUniformShuffleXor) -> Self {
        Self::GroupNonUniformShuffleXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffleUp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub delta: IdRef,
}
impl From<OpGroupNonUniformShuffleUp> for Instruction {
    fn from(v: OpGroupNonUniformShuffleUp) -> Self {
        Self::GroupNonUniformShuffleUp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformShuffleDown {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub delta: IdRef,
}
impl From<OpGroupNonUniformShuffleDown> for Instruction {
    fn from(v: OpGroupNonUniformShuffleDown) -> Self {
        Self::GroupNonUniformShuffleDown(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformIAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformIAdd> for Instruction {
    fn from(v: OpGroupNonUniformIAdd) -> Self {
        Self::GroupNonUniformIAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFAdd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFAdd> for Instruction {
    fn from(v: OpGroupNonUniformFAdd) -> Self {
        Self::GroupNonUniformFAdd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformIMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformIMul> for Instruction {
    fn from(v: OpGroupNonUniformIMul) -> Self {
        Self::GroupNonUniformIMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFMul {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFMul> for Instruction {
    fn from(v: OpGroupNonUniformFMul) -> Self {
        Self::GroupNonUniformFMul(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformSMin> for Instruction {
    fn from(v: OpGroupNonUniformSMin) -> Self {
        Self::GroupNonUniformSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformUMin> for Instruction {
    fn from(v: OpGroupNonUniformUMin) -> Self {
        Self::GroupNonUniformUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFMin> for Instruction {
    fn from(v: OpGroupNonUniformFMin) -> Self {
        Self::GroupNonUniformFMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformSMax> for Instruction {
    fn from(v: OpGroupNonUniformSMax) -> Self {
        Self::GroupNonUniformSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformUMax> for Instruction {
    fn from(v: OpGroupNonUniformUMax) -> Self {
        Self::GroupNonUniformUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformFMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformFMax> for Instruction {
    fn from(v: OpGroupNonUniformFMax) -> Self {
        Self::GroupNonUniformFMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBitwiseAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformBitwiseAnd> for Instruction {
    fn from(v: OpGroupNonUniformBitwiseAnd) -> Self {
        Self::GroupNonUniformBitwiseAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBitwiseOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformBitwiseOr> for Instruction {
    fn from(v: OpGroupNonUniformBitwiseOr) -> Self {
        Self::GroupNonUniformBitwiseOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformBitwiseXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformBitwiseXor> for Instruction {
    fn from(v: OpGroupNonUniformBitwiseXor) -> Self {
        Self::GroupNonUniformBitwiseXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformLogicalAnd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformLogicalAnd> for Instruction {
    fn from(v: OpGroupNonUniformLogicalAnd) -> Self {
        Self::GroupNonUniformLogicalAnd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformLogicalOr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformLogicalOr> for Instruction {
    fn from(v: OpGroupNonUniformLogicalOr) -> Self {
        Self::GroupNonUniformLogicalOr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformLogicalXor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub operation: GroupOperation,
    pub value: IdRef,
    pub cluster_size: Option<IdRef>,
}
impl From<OpGroupNonUniformLogicalXor> for Instruction {
    fn from(v: OpGroupNonUniformLogicalXor) -> Self {
        Self::GroupNonUniformLogicalXor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformQuadBroadcast {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub index: IdRef,
}
impl From<OpGroupNonUniformQuadBroadcast> for Instruction {
    fn from(v: OpGroupNonUniformQuadBroadcast) -> Self {
        Self::GroupNonUniformQuadBroadcast(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGroupNonUniformQuadSwap {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub execution: IdScope,
    pub value: IdRef,
    pub direction: IdRef,
}
impl From<OpGroupNonUniformQuadSwap> for Instruction {
    fn from(v: OpGroupNonUniformQuadSwap) -> Self {
        Self::GroupNonUniformQuadSwap(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpCopyLogical {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand: IdRef,
}
impl From<OpCopyLogical> for Instruction {
    fn from(v: OpCopyLogical) -> Self {
        Self::CopyLogical(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpPtrEqual> for Instruction {
    fn from(v: OpPtrEqual) -> Self {
        Self::PtrEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrNotEqual {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpPtrNotEqual> for Instruction {
    fn from(v: OpPtrNotEqual) -> Self {
        Self::PtrNotEqual(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpPtrDiff {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub operand_1: IdRef,
    pub operand_2: IdRef,
}
impl From<OpPtrDiff> for Instruction {
    fn from(v: OpPtrDiff) -> Self {
        Self::PtrDiff(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpDecorateString {
    pub target: IdRef,
    pub decoration: Decoration,
}
impl From<OpDecorateString> for Instruction {
    fn from(v: OpDecorateString) -> Self {
        Self::DecorateString(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpMemberDecorateString {
    pub struct_type: IdRef,
    pub member: LiteralInteger32,
    pub decoration: Decoration,
}
impl From<OpMemberDecorateString> for Instruction {
    fn from(v: OpMemberDecorateString) -> Self {
        Self::MemberDecorateString(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Round {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Round> for Instruction {
    fn from(v: OpGLSLStd450Round) -> Self {
        Self::GLSLStd450Round(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450RoundEven {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450RoundEven> for Instruction {
    fn from(v: OpGLSLStd450RoundEven) -> Self {
        Self::GLSLStd450RoundEven(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Trunc {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Trunc> for Instruction {
    fn from(v: OpGLSLStd450Trunc) -> Self {
        Self::GLSLStd450Trunc(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450FAbs> for Instruction {
    fn from(v: OpGLSLStd450FAbs) -> Self {
        Self::GLSLStd450FAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450SAbs> for Instruction {
    fn from(v: OpGLSLStd450SAbs) -> Self {
        Self::GLSLStd450SAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FSign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450FSign> for Instruction {
    fn from(v: OpGLSLStd450FSign) -> Self {
        Self::GLSLStd450FSign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SSign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450SSign> for Instruction {
    fn from(v: OpGLSLStd450SSign) -> Self {
        Self::GLSLStd450SSign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Floor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Floor> for Instruction {
    fn from(v: OpGLSLStd450Floor) -> Self {
        Self::GLSLStd450Floor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Ceil {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Ceil> for Instruction {
    fn from(v: OpGLSLStd450Ceil) -> Self {
        Self::GLSLStd450Ceil(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Fract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Fract> for Instruction {
    fn from(v: OpGLSLStd450Fract) -> Self {
        Self::GLSLStd450Fract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Radians {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub degrees: IdRef,
}
impl From<OpGLSLStd450Radians> for Instruction {
    fn from(v: OpGLSLStd450Radians) -> Self {
        Self::GLSLStd450Radians(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Degrees {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub radians: IdRef,
}
impl From<OpGLSLStd450Degrees> for Instruction {
    fn from(v: OpGLSLStd450Degrees) -> Self {
        Self::GLSLStd450Degrees(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Sin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Sin> for Instruction {
    fn from(v: OpGLSLStd450Sin) -> Self {
        Self::GLSLStd450Sin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Cos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Cos> for Instruction {
    fn from(v: OpGLSLStd450Cos) -> Self {
        Self::GLSLStd450Cos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Tan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Tan> for Instruction {
    fn from(v: OpGLSLStd450Tan) -> Self {
        Self::GLSLStd450Tan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Asin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Asin> for Instruction {
    fn from(v: OpGLSLStd450Asin) -> Self {
        Self::GLSLStd450Asin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Acos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Acos> for Instruction {
    fn from(v: OpGLSLStd450Acos) -> Self {
        Self::GLSLStd450Acos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Atan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y_over_x: IdRef,
}
impl From<OpGLSLStd450Atan> for Instruction {
    fn from(v: OpGLSLStd450Atan) -> Self {
        Self::GLSLStd450Atan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Sinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Sinh> for Instruction {
    fn from(v: OpGLSLStd450Sinh) -> Self {
        Self::GLSLStd450Sinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Cosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Cosh> for Instruction {
    fn from(v: OpGLSLStd450Cosh) -> Self {
        Self::GLSLStd450Cosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Tanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Tanh> for Instruction {
    fn from(v: OpGLSLStd450Tanh) -> Self {
        Self::GLSLStd450Tanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Asinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Asinh> for Instruction {
    fn from(v: OpGLSLStd450Asinh) -> Self {
        Self::GLSLStd450Asinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Acosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Acosh> for Instruction {
    fn from(v: OpGLSLStd450Acosh) -> Self {
        Self::GLSLStd450Acosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Atanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Atanh> for Instruction {
    fn from(v: OpGLSLStd450Atanh) -> Self {
        Self::GLSLStd450Atanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Atan2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Atan2> for Instruction {
    fn from(v: OpGLSLStd450Atan2) -> Self {
        Self::GLSLStd450Atan2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Pow {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450Pow> for Instruction {
    fn from(v: OpGLSLStd450Pow) -> Self {
        Self::GLSLStd450Pow(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Exp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Exp> for Instruction {
    fn from(v: OpGLSLStd450Exp) -> Self {
        Self::GLSLStd450Exp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Log {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Log> for Instruction {
    fn from(v: OpGLSLStd450Log) -> Self {
        Self::GLSLStd450Log(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Exp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Exp2> for Instruction {
    fn from(v: OpGLSLStd450Exp2) -> Self {
        Self::GLSLStd450Exp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Log2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Log2> for Instruction {
    fn from(v: OpGLSLStd450Log2) -> Self {
        Self::GLSLStd450Log2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Sqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Sqrt> for Instruction {
    fn from(v: OpGLSLStd450Sqrt) -> Self {
        Self::GLSLStd450Sqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InverseSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450InverseSqrt> for Instruction {
    fn from(v: OpGLSLStd450InverseSqrt) -> Self {
        Self::GLSLStd450InverseSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Determinant {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Determinant> for Instruction {
    fn from(v: OpGLSLStd450Determinant) -> Self {
        Self::GLSLStd450Determinant(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450MatrixInverse {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450MatrixInverse> for Instruction {
    fn from(v: OpGLSLStd450MatrixInverse) -> Self {
        Self::GLSLStd450MatrixInverse(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Modf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub i: IdRef,
}
impl From<OpGLSLStd450Modf> for Instruction {
    fn from(v: OpGLSLStd450Modf) -> Self {
        Self::GLSLStd450Modf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450ModfStruct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450ModfStruct> for Instruction {
    fn from(v: OpGLSLStd450ModfStruct) -> Self {
        Self::GLSLStd450ModfStruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450FMin> for Instruction {
    fn from(v: OpGLSLStd450FMin) -> Self {
        Self::GLSLStd450FMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450UMin> for Instruction {
    fn from(v: OpGLSLStd450UMin) -> Self {
        Self::GLSLStd450UMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450SMin> for Instruction {
    fn from(v: OpGLSLStd450SMin) -> Self {
        Self::GLSLStd450SMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450FMax> for Instruction {
    fn from(v: OpGLSLStd450FMax) -> Self {
        Self::GLSLStd450FMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450UMax> for Instruction {
    fn from(v: OpGLSLStd450UMax) -> Self {
        Self::GLSLStd450UMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450SMax> for Instruction {
    fn from(v: OpGLSLStd450SMax) -> Self {
        Self::GLSLStd450SMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450FClamp> for Instruction {
    fn from(v: OpGLSLStd450FClamp) -> Self {
        Self::GLSLStd450FClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450UClamp> for Instruction {
    fn from(v: OpGLSLStd450UClamp) -> Self {
        Self::GLSLStd450UClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450SClamp> for Instruction {
    fn from(v: OpGLSLStd450SClamp) -> Self {
        Self::GLSLStd450SClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FMix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub a: IdRef,
}
impl From<OpGLSLStd450FMix> for Instruction {
    fn from(v: OpGLSLStd450FMix) -> Self {
        Self::GLSLStd450FMix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450IMix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub a: IdRef,
}
impl From<OpGLSLStd450IMix> for Instruction {
    fn from(v: OpGLSLStd450IMix) -> Self {
        Self::GLSLStd450IMix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Step {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Step> for Instruction {
    fn from(v: OpGLSLStd450Step) -> Self {
        Self::GLSLStd450Step(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450SmoothStep {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge0: IdRef,
    pub edge1: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450SmoothStep> for Instruction {
    fn from(v: OpGLSLStd450SmoothStep) -> Self {
        Self::GLSLStd450SmoothStep(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Fma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpGLSLStd450Fma> for Instruction {
    fn from(v: OpGLSLStd450Fma) -> Self {
        Self::GLSLStd450Fma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Frexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub exp: IdRef,
}
impl From<OpGLSLStd450Frexp> for Instruction {
    fn from(v: OpGLSLStd450Frexp) -> Self {
        Self::GLSLStd450Frexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FrexpStruct {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450FrexpStruct> for Instruction {
    fn from(v: OpGLSLStd450FrexpStruct) -> Self {
        Self::GLSLStd450FrexpStruct(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Ldexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub exp: IdRef,
}
impl From<OpGLSLStd450Ldexp> for Instruction {
    fn from(v: OpGLSLStd450Ldexp) -> Self {
        Self::GLSLStd450Ldexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackSnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackSnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450PackSnorm4x8) -> Self {
        Self::GLSLStd450PackSnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackUnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackUnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450PackUnorm4x8) -> Self {
        Self::GLSLStd450PackUnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackSnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackSnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450PackSnorm2x16) -> Self {
        Self::GLSLStd450PackSnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackUnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackUnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450PackUnorm2x16) -> Self {
        Self::GLSLStd450PackUnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackHalf2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackHalf2x16> for Instruction {
    fn from(v: OpGLSLStd450PackHalf2x16) -> Self {
        Self::GLSLStd450PackHalf2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450PackDouble2x32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450PackDouble2x32> for Instruction {
    fn from(v: OpGLSLStd450PackDouble2x32) -> Self {
        Self::GLSLStd450PackDouble2x32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackSnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackSnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450UnpackSnorm2x16) -> Self {
        Self::GLSLStd450UnpackSnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackUnorm2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackUnorm2x16> for Instruction {
    fn from(v: OpGLSLStd450UnpackUnorm2x16) -> Self {
        Self::GLSLStd450UnpackUnorm2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackHalf2x16 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450UnpackHalf2x16> for Instruction {
    fn from(v: OpGLSLStd450UnpackHalf2x16) -> Self {
        Self::GLSLStd450UnpackHalf2x16(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackSnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackSnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450UnpackSnorm4x8) -> Self {
        Self::GLSLStd450UnpackSnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackUnorm4x8 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpGLSLStd450UnpackUnorm4x8> for Instruction {
    fn from(v: OpGLSLStd450UnpackUnorm4x8) -> Self {
        Self::GLSLStd450UnpackUnorm4x8(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450UnpackDouble2x32 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
}
impl From<OpGLSLStd450UnpackDouble2x32> for Instruction {
    fn from(v: OpGLSLStd450UnpackDouble2x32) -> Self {
        Self::GLSLStd450UnpackDouble2x32(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Length {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Length> for Instruction {
    fn from(v: OpGLSLStd450Length) -> Self {
        Self::GLSLStd450Length(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Distance {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpGLSLStd450Distance> for Instruction {
    fn from(v: OpGLSLStd450Distance) -> Self {
        Self::GLSLStd450Distance(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Cross {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450Cross> for Instruction {
    fn from(v: OpGLSLStd450Cross) -> Self {
        Self::GLSLStd450Cross(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Normalize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpGLSLStd450Normalize> for Instruction {
    fn from(v: OpGLSLStd450Normalize) -> Self {
        Self::GLSLStd450Normalize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FaceForward {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub n: IdRef,
    pub i: IdRef,
    pub nref: IdRef,
}
impl From<OpGLSLStd450FaceForward> for Instruction {
    fn from(v: OpGLSLStd450FaceForward) -> Self {
        Self::GLSLStd450FaceForward(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Reflect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub i: IdRef,
    pub n: IdRef,
}
impl From<OpGLSLStd450Reflect> for Instruction {
    fn from(v: OpGLSLStd450Reflect) -> Self {
        Self::GLSLStd450Reflect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450Refract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub i: IdRef,
    pub n: IdRef,
    pub eta: IdRef,
}
impl From<OpGLSLStd450Refract> for Instruction {
    fn from(v: OpGLSLStd450Refract) -> Self {
        Self::GLSLStd450Refract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FindILsb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub value: IdRef,
}
impl From<OpGLSLStd450FindILsb> for Instruction {
    fn from(v: OpGLSLStd450FindILsb) -> Self {
        Self::GLSLStd450FindILsb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FindSMsb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub value: IdRef,
}
impl From<OpGLSLStd450FindSMsb> for Instruction {
    fn from(v: OpGLSLStd450FindSMsb) -> Self {
        Self::GLSLStd450FindSMsb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450FindUMsb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub value: IdRef,
}
impl From<OpGLSLStd450FindUMsb> for Instruction {
    fn from(v: OpGLSLStd450FindUMsb) -> Self {
        Self::GLSLStd450FindUMsb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InterpolateAtCentroid {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub interpolant: IdRef,
}
impl From<OpGLSLStd450InterpolateAtCentroid> for Instruction {
    fn from(v: OpGLSLStd450InterpolateAtCentroid) -> Self {
        Self::GLSLStd450InterpolateAtCentroid(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InterpolateAtSample {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub interpolant: IdRef,
    pub sample: IdRef,
}
impl From<OpGLSLStd450InterpolateAtSample> for Instruction {
    fn from(v: OpGLSLStd450InterpolateAtSample) -> Self {
        Self::GLSLStd450InterpolateAtSample(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450InterpolateAtOffset {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub interpolant: IdRef,
    pub offset: IdRef,
}
impl From<OpGLSLStd450InterpolateAtOffset> for Instruction {
    fn from(v: OpGLSLStd450InterpolateAtOffset) -> Self {
        Self::GLSLStd450InterpolateAtOffset(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450NMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450NMin> for Instruction {
    fn from(v: OpGLSLStd450NMin) -> Self {
        Self::GLSLStd450NMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450NMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpGLSLStd450NMax> for Instruction {
    fn from(v: OpGLSLStd450NMax) -> Self {
        Self::GLSLStd450NMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpGLSLStd450NClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub min_val: IdRef,
    pub max_val: IdRef,
}
impl From<OpGLSLStd450NClamp> for Instruction {
    fn from(v: OpGLSLStd450NClamp) -> Self {
        Self::GLSLStd450NClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAcos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAcos> for Instruction {
    fn from(v: OpOpenCLStdAcos) -> Self {
        Self::OpenCLStdAcos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAcosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAcosh> for Instruction {
    fn from(v: OpOpenCLStdAcosh) -> Self {
        Self::OpenCLStdAcosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAcospi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAcospi> for Instruction {
    fn from(v: OpOpenCLStdAcospi) -> Self {
        Self::OpenCLStdAcospi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAsin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAsin> for Instruction {
    fn from(v: OpOpenCLStdAsin) -> Self {
        Self::OpenCLStdAsin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAsinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAsinh> for Instruction {
    fn from(v: OpOpenCLStdAsinh) -> Self {
        Self::OpenCLStdAsinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAsinpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAsinpi> for Instruction {
    fn from(v: OpOpenCLStdAsinpi) -> Self {
        Self::OpenCLStdAsinpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtan> for Instruction {
    fn from(v: OpOpenCLStdAtan) -> Self {
        Self::OpenCLStdAtan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtan2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtan2> for Instruction {
    fn from(v: OpOpenCLStdAtan2) -> Self {
        Self::OpenCLStdAtan2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtanh> for Instruction {
    fn from(v: OpOpenCLStdAtanh) -> Self {
        Self::OpenCLStdAtanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtanpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtanpi> for Instruction {
    fn from(v: OpOpenCLStdAtanpi) -> Self {
        Self::OpenCLStdAtanpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdAtan2pi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub y: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdAtan2pi> for Instruction {
    fn from(v: OpOpenCLStdAtan2pi) -> Self {
        Self::OpenCLStdAtan2pi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCbrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCbrt> for Instruction {
    fn from(v: OpOpenCLStdCbrt) -> Self {
        Self::OpenCLStdCbrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCeil {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCeil> for Instruction {
    fn from(v: OpOpenCLStdCeil) -> Self {
        Self::OpenCLStdCeil(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCopysign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdCopysign> for Instruction {
    fn from(v: OpOpenCLStdCopysign) -> Self {
        Self::OpenCLStdCopysign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCos> for Instruction {
    fn from(v: OpOpenCLStdCos) -> Self {
        Self::OpenCLStdCos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCosh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCosh> for Instruction {
    fn from(v: OpOpenCLStdCosh) -> Self {
        Self::OpenCLStdCosh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCospi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCospi> for Instruction {
    fn from(v: OpOpenCLStdCospi) -> Self {
        Self::OpenCLStdCospi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdErfc {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdErfc> for Instruction {
    fn from(v: OpOpenCLStdErfc) -> Self {
        Self::OpenCLStdErfc(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdErf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdErf> for Instruction {
    fn from(v: OpOpenCLStdErf) -> Self {
        Self::OpenCLStdErf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExp> for Instruction {
    fn from(v: OpOpenCLStdExp) -> Self {
        Self::OpenCLStdExp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExp2> for Instruction {
    fn from(v: OpOpenCLStdExp2) -> Self {
        Self::OpenCLStdExp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExp10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExp10> for Instruction {
    fn from(v: OpOpenCLStdExp10) -> Self {
        Self::OpenCLStdExp10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdExpm1 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdExpm1> for Instruction {
    fn from(v: OpOpenCLStdExpm1) -> Self {
        Self::OpenCLStdExpm1(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFabs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdFabs> for Instruction {
    fn from(v: OpOpenCLStdFabs) -> Self {
        Self::OpenCLStdFabs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFdim {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFdim> for Instruction {
    fn from(v: OpOpenCLStdFdim) -> Self {
        Self::OpenCLStdFdim(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFloor {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdFloor> for Instruction {
    fn from(v: OpOpenCLStdFloor) -> Self {
        Self::OpenCLStdFloor(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdFma> for Instruction {
    fn from(v: OpOpenCLStdFma) -> Self {
        Self::OpenCLStdFma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmax> for Instruction {
    fn from(v: OpOpenCLStdFmax) -> Self {
        Self::OpenCLStdFmax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmin> for Instruction {
    fn from(v: OpOpenCLStdFmin) -> Self {
        Self::OpenCLStdFmin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmod {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmod> for Instruction {
    fn from(v: OpOpenCLStdFmod) -> Self {
        Self::OpenCLStdFmod(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFract {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub ptr: IdRef,
}
impl From<OpOpenCLStdFract> for Instruction {
    fn from(v: OpOpenCLStdFract) -> Self {
        Self::OpenCLStdFract(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFrexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub exp: IdRef,
}
impl From<OpOpenCLStdFrexp> for Instruction {
    fn from(v: OpOpenCLStdFrexp) -> Self {
        Self::OpenCLStdFrexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHypot {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdHypot> for Instruction {
    fn from(v: OpOpenCLStdHypot) -> Self {
        Self::OpenCLStdHypot(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdIlogb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdIlogb> for Instruction {
    fn from(v: OpOpenCLStdIlogb) -> Self {
        Self::OpenCLStdIlogb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLdexp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub k: IdRef,
}
impl From<OpOpenCLStdLdexp> for Instruction {
    fn from(v: OpOpenCLStdLdexp) -> Self {
        Self::OpenCLStdLdexp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLgamma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLgamma> for Instruction {
    fn from(v: OpOpenCLStdLgamma) -> Self {
        Self::OpenCLStdLgamma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLgammaR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub signp: IdRef,
}
impl From<OpOpenCLStdLgammaR> for Instruction {
    fn from(v: OpOpenCLStdLgammaR) -> Self {
        Self::OpenCLStdLgammaR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog> for Instruction {
    fn from(v: OpOpenCLStdLog) -> Self {
        Self::OpenCLStdLog(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog2> for Instruction {
    fn from(v: OpOpenCLStdLog2) -> Self {
        Self::OpenCLStdLog2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog10> for Instruction {
    fn from(v: OpOpenCLStdLog10) -> Self {
        Self::OpenCLStdLog10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLog1p {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLog1p> for Instruction {
    fn from(v: OpOpenCLStdLog1p) -> Self {
        Self::OpenCLStdLog1p(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLogb {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdLogb> for Instruction {
    fn from(v: OpOpenCLStdLogb) -> Self {
        Self::OpenCLStdLogb(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMad {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdMad> for Instruction {
    fn from(v: OpOpenCLStdMad) -> Self {
        Self::OpenCLStdMad(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMaxmag {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdMaxmag> for Instruction {
    fn from(v: OpOpenCLStdMaxmag) -> Self {
        Self::OpenCLStdMaxmag(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMinmag {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdMinmag> for Instruction {
    fn from(v: OpOpenCLStdMinmag) -> Self {
        Self::OpenCLStdMinmag(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdModf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub iptr: IdRef,
}
impl From<OpOpenCLStdModf> for Instruction {
    fn from(v: OpOpenCLStdModf) -> Self {
        Self::OpenCLStdModf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub nancode: IdRef,
}
impl From<OpOpenCLStdNan> for Instruction {
    fn from(v: OpOpenCLStdNan) -> Self {
        Self::OpenCLStdNan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNextafter {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdNextafter> for Instruction {
    fn from(v: OpOpenCLStdNextafter) -> Self {
        Self::OpenCLStdNextafter(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPow {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdPow> for Instruction {
    fn from(v: OpOpenCLStdPow) -> Self {
        Self::OpenCLStdPow(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPown {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdPown> for Instruction {
    fn from(v: OpOpenCLStdPown) -> Self {
        Self::OpenCLStdPown(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPowr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdPowr> for Instruction {
    fn from(v: OpOpenCLStdPowr) -> Self {
        Self::OpenCLStdPowr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRemainder {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdRemainder> for Instruction {
    fn from(v: OpOpenCLStdRemainder) -> Self {
        Self::OpenCLStdRemainder(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRemquo {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub quo: IdRef,
}
impl From<OpOpenCLStdRemquo> for Instruction {
    fn from(v: OpOpenCLStdRemquo) -> Self {
        Self::OpenCLStdRemquo(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRint {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdRint> for Instruction {
    fn from(v: OpOpenCLStdRint) -> Self {
        Self::OpenCLStdRint(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRootn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdRootn> for Instruction {
    fn from(v: OpOpenCLStdRootn) -> Self {
        Self::OpenCLStdRootn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRound {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdRound> for Instruction {
    fn from(v: OpOpenCLStdRound) -> Self {
        Self::OpenCLStdRound(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRsqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdRsqrt> for Instruction {
    fn from(v: OpOpenCLStdRsqrt) -> Self {
        Self::OpenCLStdRsqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSin> for Instruction {
    fn from(v: OpOpenCLStdSin) -> Self {
        Self::OpenCLStdSin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSincos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub cosval: IdRef,
}
impl From<OpOpenCLStdSincos> for Instruction {
    fn from(v: OpOpenCLStdSincos) -> Self {
        Self::OpenCLStdSincos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSinh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSinh> for Instruction {
    fn from(v: OpOpenCLStdSinh) -> Self {
        Self::OpenCLStdSinh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSinpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSinpi> for Instruction {
    fn from(v: OpOpenCLStdSinpi) -> Self {
        Self::OpenCLStdSinpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSqrt> for Instruction {
    fn from(v: OpOpenCLStdSqrt) -> Self {
        Self::OpenCLStdSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTan> for Instruction {
    fn from(v: OpOpenCLStdTan) -> Self {
        Self::OpenCLStdTan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTanh {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTanh> for Instruction {
    fn from(v: OpOpenCLStdTanh) -> Self {
        Self::OpenCLStdTanh(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTanpi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTanpi> for Instruction {
    fn from(v: OpOpenCLStdTanpi) -> Self {
        Self::OpenCLStdTanpi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTgamma {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTgamma> for Instruction {
    fn from(v: OpOpenCLStdTgamma) -> Self {
        Self::OpenCLStdTgamma(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdTrunc {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdTrunc> for Instruction {
    fn from(v: OpOpenCLStdTrunc) -> Self {
        Self::OpenCLStdTrunc(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfCos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfCos> for Instruction {
    fn from(v: OpOpenCLStdHalfCos) -> Self {
        Self::OpenCLStdHalfCos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfDivide {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdHalfDivide> for Instruction {
    fn from(v: OpOpenCLStdHalfDivide) -> Self {
        Self::OpenCLStdHalfDivide(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfExp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfExp> for Instruction {
    fn from(v: OpOpenCLStdHalfExp) -> Self {
        Self::OpenCLStdHalfExp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfExp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfExp2> for Instruction {
    fn from(v: OpOpenCLStdHalfExp2) -> Self {
        Self::OpenCLStdHalfExp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfExp10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfExp10> for Instruction {
    fn from(v: OpOpenCLStdHalfExp10) -> Self {
        Self::OpenCLStdHalfExp10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfLog {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfLog> for Instruction {
    fn from(v: OpOpenCLStdHalfLog) -> Self {
        Self::OpenCLStdHalfLog(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfLog2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfLog2> for Instruction {
    fn from(v: OpOpenCLStdHalfLog2) -> Self {
        Self::OpenCLStdHalfLog2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfLog10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfLog10> for Instruction {
    fn from(v: OpOpenCLStdHalfLog10) -> Self {
        Self::OpenCLStdHalfLog10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfPowr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdHalfPowr> for Instruction {
    fn from(v: OpOpenCLStdHalfPowr) -> Self {
        Self::OpenCLStdHalfPowr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfRecip {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfRecip> for Instruction {
    fn from(v: OpOpenCLStdHalfRecip) -> Self {
        Self::OpenCLStdHalfRecip(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfRsqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfRsqrt> for Instruction {
    fn from(v: OpOpenCLStdHalfRsqrt) -> Self {
        Self::OpenCLStdHalfRsqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfSin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfSin> for Instruction {
    fn from(v: OpOpenCLStdHalfSin) -> Self {
        Self::OpenCLStdHalfSin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfSqrt> for Instruction {
    fn from(v: OpOpenCLStdHalfSqrt) -> Self {
        Self::OpenCLStdHalfSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdHalfTan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdHalfTan> for Instruction {
    fn from(v: OpOpenCLStdHalfTan) -> Self {
        Self::OpenCLStdHalfTan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeCos {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeCos> for Instruction {
    fn from(v: OpOpenCLStdNativeCos) -> Self {
        Self::OpenCLStdNativeCos(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeDivide {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdNativeDivide> for Instruction {
    fn from(v: OpOpenCLStdNativeDivide) -> Self {
        Self::OpenCLStdNativeDivide(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeExp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeExp> for Instruction {
    fn from(v: OpOpenCLStdNativeExp) -> Self {
        Self::OpenCLStdNativeExp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeExp2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeExp2> for Instruction {
    fn from(v: OpOpenCLStdNativeExp2) -> Self {
        Self::OpenCLStdNativeExp2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeExp10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeExp10> for Instruction {
    fn from(v: OpOpenCLStdNativeExp10) -> Self {
        Self::OpenCLStdNativeExp10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeLog {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeLog> for Instruction {
    fn from(v: OpOpenCLStdNativeLog) -> Self {
        Self::OpenCLStdNativeLog(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeLog2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeLog2> for Instruction {
    fn from(v: OpOpenCLStdNativeLog2) -> Self {
        Self::OpenCLStdNativeLog2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeLog10 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeLog10> for Instruction {
    fn from(v: OpOpenCLStdNativeLog10) -> Self {
        Self::OpenCLStdNativeLog10(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativePowr {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdNativePowr> for Instruction {
    fn from(v: OpOpenCLStdNativePowr) -> Self {
        Self::OpenCLStdNativePowr(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeRecip {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeRecip> for Instruction {
    fn from(v: OpOpenCLStdNativeRecip) -> Self {
        Self::OpenCLStdNativeRecip(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeRsqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeRsqrt> for Instruction {
    fn from(v: OpOpenCLStdNativeRsqrt) -> Self {
        Self::OpenCLStdNativeRsqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeSin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeSin> for Instruction {
    fn from(v: OpOpenCLStdNativeSin) -> Self {
        Self::OpenCLStdNativeSin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeSqrt {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeSqrt> for Instruction {
    fn from(v: OpOpenCLStdNativeSqrt) -> Self {
        Self::OpenCLStdNativeSqrt(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNativeTan {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdNativeTan> for Instruction {
    fn from(v: OpOpenCLStdNativeTan) -> Self {
        Self::OpenCLStdNativeTan(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSAbs> for Instruction {
    fn from(v: OpOpenCLStdSAbs) -> Self {
        Self::OpenCLStdSAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSAbsDiff {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSAbsDiff> for Instruction {
    fn from(v: OpOpenCLStdSAbsDiff) -> Self {
        Self::OpenCLStdSAbsDiff(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSAddSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSAddSat> for Instruction {
    fn from(v: OpOpenCLStdSAddSat) -> Self {
        Self::OpenCLStdSAddSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUAddSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUAddSat> for Instruction {
    fn from(v: OpOpenCLStdUAddSat) -> Self {
        Self::OpenCLStdUAddSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSHadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSHadd> for Instruction {
    fn from(v: OpOpenCLStdSHadd) -> Self {
        Self::OpenCLStdSHadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUHadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUHadd> for Instruction {
    fn from(v: OpOpenCLStdUHadd) -> Self {
        Self::OpenCLStdUHadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSRhadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSRhadd> for Instruction {
    fn from(v: OpOpenCLStdSRhadd) -> Self {
        Self::OpenCLStdSRhadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdURhadd {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdURhadd> for Instruction {
    fn from(v: OpOpenCLStdURhadd) -> Self {
        Self::OpenCLStdURhadd(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub minval: IdRef,
    pub maxval: IdRef,
}
impl From<OpOpenCLStdSClamp> for Instruction {
    fn from(v: OpOpenCLStdSClamp) -> Self {
        Self::OpenCLStdSClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUClamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub minval: IdRef,
    pub maxval: IdRef,
}
impl From<OpOpenCLStdUClamp> for Instruction {
    fn from(v: OpOpenCLStdUClamp) -> Self {
        Self::OpenCLStdUClamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdClz {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdClz> for Instruction {
    fn from(v: OpOpenCLStdClz) -> Self {
        Self::OpenCLStdClz(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCtz {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdCtz> for Instruction {
    fn from(v: OpOpenCLStdCtz) -> Self {
        Self::OpenCLStdCtz(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMadHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdSMadHi> for Instruction {
    fn from(v: OpOpenCLStdSMadHi) -> Self {
        Self::OpenCLStdSMadHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMadSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdUMadSat> for Instruction {
    fn from(v: OpOpenCLStdUMadSat) -> Self {
        Self::OpenCLStdUMadSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMadSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdSMadSat> for Instruction {
    fn from(v: OpOpenCLStdSMadSat) -> Self {
        Self::OpenCLStdSMadSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMax> for Instruction {
    fn from(v: OpOpenCLStdSMax) -> Self {
        Self::OpenCLStdSMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMax {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMax> for Instruction {
    fn from(v: OpOpenCLStdUMax) -> Self {
        Self::OpenCLStdUMax(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMin> for Instruction {
    fn from(v: OpOpenCLStdSMin) -> Self {
        Self::OpenCLStdSMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMin {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMin> for Instruction {
    fn from(v: OpOpenCLStdUMin) -> Self {
        Self::OpenCLStdUMin(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMulHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMulHi> for Instruction {
    fn from(v: OpOpenCLStdSMulHi) -> Self {
        Self::OpenCLStdSMulHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRotate {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub v: IdRef,
    pub i: IdRef,
}
impl From<OpOpenCLStdRotate> for Instruction {
    fn from(v: OpOpenCLStdRotate) -> Self {
        Self::OpenCLStdRotate(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSSubSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSSubSat> for Instruction {
    fn from(v: OpOpenCLStdSSubSat) -> Self {
        Self::OpenCLStdSSubSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUSubSat {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUSubSat> for Instruction {
    fn from(v: OpOpenCLStdUSubSat) -> Self {
        Self::OpenCLStdUSubSat(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUUpsample {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub hi: IdRef,
    pub lo: IdRef,
}
impl From<OpOpenCLStdUUpsample> for Instruction {
    fn from(v: OpOpenCLStdUUpsample) -> Self {
        Self::OpenCLStdUUpsample(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSUpsample {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub hi: IdRef,
    pub lo: IdRef,
}
impl From<OpOpenCLStdSUpsample> for Instruction {
    fn from(v: OpOpenCLStdSUpsample) -> Self {
        Self::OpenCLStdSUpsample(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPopcount {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdPopcount> for Instruction {
    fn from(v: OpOpenCLStdPopcount) -> Self {
        Self::OpenCLStdPopcount(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMad24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdSMad24> for Instruction {
    fn from(v: OpOpenCLStdSMad24) -> Self {
        Self::OpenCLStdSMad24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMad24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub z: IdRef,
}
impl From<OpOpenCLStdUMad24> for Instruction {
    fn from(v: OpOpenCLStdUMad24) -> Self {
        Self::OpenCLStdUMad24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSMul24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdSMul24> for Instruction {
    fn from(v: OpOpenCLStdSMul24) -> Self {
        Self::OpenCLStdSMul24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMul24 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMul24> for Instruction {
    fn from(v: OpOpenCLStdUMul24) -> Self {
        Self::OpenCLStdUMul24(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUAbs {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdUAbs> for Instruction {
    fn from(v: OpOpenCLStdUAbs) -> Self {
        Self::OpenCLStdUAbs(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUAbsDiff {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUAbsDiff> for Instruction {
    fn from(v: OpOpenCLStdUAbsDiff) -> Self {
        Self::OpenCLStdUAbsDiff(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMulHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdUMulHi> for Instruction {
    fn from(v: OpOpenCLStdUMulHi) -> Self {
        Self::OpenCLStdUMulHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdUMadHi {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdUMadHi> for Instruction {
    fn from(v: OpOpenCLStdUMadHi) -> Self {
        Self::OpenCLStdUMadHi(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFclamp {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub minval: IdRef,
    pub maxval: IdRef,
}
impl From<OpOpenCLStdFclamp> for Instruction {
    fn from(v: OpOpenCLStdFclamp) -> Self {
        Self::OpenCLStdFclamp(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdDegrees {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub radians: IdRef,
}
impl From<OpOpenCLStdDegrees> for Instruction {
    fn from(v: OpOpenCLStdDegrees) -> Self {
        Self::OpenCLStdDegrees(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFmaxCommon {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFmaxCommon> for Instruction {
    fn from(v: OpOpenCLStdFmaxCommon) -> Self {
        Self::OpenCLStdFmaxCommon(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFminCommon {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
}
impl From<OpOpenCLStdFminCommon> for Instruction {
    fn from(v: OpOpenCLStdFminCommon) -> Self {
        Self::OpenCLStdFminCommon(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdMix {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub a: IdRef,
}
impl From<OpOpenCLStdMix> for Instruction {
    fn from(v: OpOpenCLStdMix) -> Self {
        Self::OpenCLStdMix(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdRadians {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub degrees: IdRef,
}
impl From<OpOpenCLStdRadians> for Instruction {
    fn from(v: OpOpenCLStdRadians) -> Self {
        Self::OpenCLStdRadians(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdStep {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdStep> for Instruction {
    fn from(v: OpOpenCLStdStep) -> Self {
        Self::OpenCLStdStep(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSmoothstep {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub edge0: IdRef,
    pub edge1: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSmoothstep> for Instruction {
    fn from(v: OpOpenCLStdSmoothstep) -> Self {
        Self::OpenCLStdSmoothstep(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSign {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
}
impl From<OpOpenCLStdSign> for Instruction {
    fn from(v: OpOpenCLStdSign) -> Self {
        Self::OpenCLStdSign(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdCross {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpOpenCLStdCross> for Instruction {
    fn from(v: OpOpenCLStdCross) -> Self {
        Self::OpenCLStdCross(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdDistance {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpOpenCLStdDistance> for Instruction {
    fn from(v: OpOpenCLStdDistance) -> Self {
        Self::OpenCLStdDistance(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdLength {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdLength> for Instruction {
    fn from(v: OpOpenCLStdLength) -> Self {
        Self::OpenCLStdLength(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdNormalize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdNormalize> for Instruction {
    fn from(v: OpOpenCLStdNormalize) -> Self {
        Self::OpenCLStdNormalize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFastDistance {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p0: IdRef,
    pub p1: IdRef,
}
impl From<OpOpenCLStdFastDistance> for Instruction {
    fn from(v: OpOpenCLStdFastDistance) -> Self {
        Self::OpenCLStdFastDistance(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFastLength {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdFastLength> for Instruction {
    fn from(v: OpOpenCLStdFastLength) -> Self {
        Self::OpenCLStdFastLength(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdFastNormalize {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdFastNormalize> for Instruction {
    fn from(v: OpOpenCLStdFastNormalize) -> Self {
        Self::OpenCLStdFastNormalize(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdBitselect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdBitselect> for Instruction {
    fn from(v: OpOpenCLStdBitselect) -> Self {
        Self::OpenCLStdBitselect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdSelect {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub a: IdRef,
    pub b: IdRef,
    pub c: IdRef,
}
impl From<OpOpenCLStdSelect> for Instruction {
    fn from(v: OpOpenCLStdSelect) -> Self {
        Self::OpenCLStdSelect(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub n: LiteralInteger32,
}
impl From<OpOpenCLStdVloadn> for Instruction {
    fn from(v: OpOpenCLStdVloadn) -> Self {
        Self::OpenCLStdVloadn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoren {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoren> for Instruction {
    fn from(v: OpOpenCLStdVstoren) -> Self {
        Self::OpenCLStdVstoren(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadHalf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVloadHalf> for Instruction {
    fn from(v: OpOpenCLStdVloadHalf) -> Self {
        Self::OpenCLStdVloadHalf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub n: LiteralInteger32,
}
impl From<OpOpenCLStdVloadHalfn> for Instruction {
    fn from(v: OpOpenCLStdVloadHalfn) -> Self {
        Self::OpenCLStdVloadHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoreHalf> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalf) -> Self {
        Self::OpenCLStdVstoreHalf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalfR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub mode: FPRoundingMode,
}
impl From<OpOpenCLStdVstoreHalfR> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalfR) -> Self {
        Self::OpenCLStdVstoreHalfR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoreHalfn> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalfn) -> Self {
        Self::OpenCLStdVstoreHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreHalfnR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub mode: FPRoundingMode,
}
impl From<OpOpenCLStdVstoreHalfnR> for Instruction {
    fn from(v: OpOpenCLStdVstoreHalfnR) -> Self {
        Self::OpenCLStdVstoreHalfnR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVloadaHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub n: LiteralInteger32,
}
impl From<OpOpenCLStdVloadaHalfn> for Instruction {
    fn from(v: OpOpenCLStdVloadaHalfn) -> Self {
        Self::OpenCLStdVloadaHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreaHalfn {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
}
impl From<OpOpenCLStdVstoreaHalfn> for Instruction {
    fn from(v: OpOpenCLStdVstoreaHalfn) -> Self {
        Self::OpenCLStdVstoreaHalfn(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdVstoreaHalfnR {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub data: IdRef,
    pub offset: IdRef,
    pub p: IdRef,
    pub mode: FPRoundingMode,
}
impl From<OpOpenCLStdVstoreaHalfnR> for Instruction {
    fn from(v: OpOpenCLStdVstoreaHalfnR) -> Self {
        Self::OpenCLStdVstoreaHalfnR(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdShuffle {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub shuffle_mask: IdRef,
}
impl From<OpOpenCLStdShuffle> for Instruction {
    fn from(v: OpOpenCLStdShuffle) -> Self {
        Self::OpenCLStdShuffle(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdShuffle2 {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub x: IdRef,
    pub y: IdRef,
    pub shuffle_mask: IdRef,
}
impl From<OpOpenCLStdShuffle2> for Instruction {
    fn from(v: OpOpenCLStdShuffle2) -> Self {
        Self::OpenCLStdShuffle2(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPrintf {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub format: IdRef,
    pub additional_arguments: Vec<IdRef>,
}
impl From<OpOpenCLStdPrintf> for Instruction {
    fn from(v: OpOpenCLStdPrintf) -> Self {
        Self::OpenCLStdPrintf(v)
    }
}
#[derive(Clone, Debug)]
pub struct OpOpenCLStdPrefetch {
    pub id_result_type: IdResultType,
    pub id_result: IdResult,
    pub set: IdRef,
    pub ptr: IdRef,
    pub num_elements: IdRef,
}
impl From<OpOpenCLStdPrefetch> for Instruction {
    fn from(v: OpOpenCLStdPrefetch) -> Self {
        Self::OpenCLStdPrefetch(v)
    }
}
#[derive(Clone, Debug)]
pub enum Instruction {
    Nop(OpNop),
    Undef(OpUndef),
    SourceContinued(OpSourceContinued),
    Source(OpSource),
    SourceExtension(OpSourceExtension),
    Name(OpName),
    MemberName(OpMemberName),
    String(OpString),
    Line(OpLine),
    Extension(OpExtension),
    ExtInstImport(OpExtInstImport),
    ExtInst(OpExtInst),
    MemoryModel(OpMemoryModel),
    EntryPoint(OpEntryPoint),
    ExecutionMode(OpExecutionMode),
    Capability(OpCapability),
    TypeVoid(OpTypeVoid),
    TypeBool(OpTypeBool),
    TypeInt(OpTypeInt),
    TypeFloat(OpTypeFloat),
    TypeVector(OpTypeVector),
    TypeMatrix(OpTypeMatrix),
    TypeImage(OpTypeImage),
    TypeSampler(OpTypeSampler),
    TypeSampledImage(OpTypeSampledImage),
    TypeArray(OpTypeArray),
    TypeRuntimeArray(OpTypeRuntimeArray),
    TypeStruct(OpTypeStruct),
    TypeOpaque(OpTypeOpaque),
    TypePointer(OpTypePointer),
    TypeFunction(OpTypeFunction),
    TypeEvent(OpTypeEvent),
    TypeDeviceEvent(OpTypeDeviceEvent),
    TypeReserveId(OpTypeReserveId),
    TypeQueue(OpTypeQueue),
    TypePipe(OpTypePipe),
    TypeForwardPointer(OpTypeForwardPointer),
    ConstantTrue(OpConstantTrue),
    ConstantFalse(OpConstantFalse),
    Constant32(OpConstant32),
    Constant64(OpConstant64),
    ConstantComposite(OpConstantComposite),
    ConstantSampler(OpConstantSampler),
    ConstantNull(OpConstantNull),
    SpecConstantTrue(OpSpecConstantTrue),
    SpecConstantFalse(OpSpecConstantFalse),
    SpecConstant32(OpSpecConstant32),
    SpecConstant64(OpSpecConstant64),
    SpecConstantComposite(OpSpecConstantComposite),
    SpecConstantOp(OpSpecConstantOp),
    Function(OpFunction),
    FunctionParameter(OpFunctionParameter),
    FunctionEnd(OpFunctionEnd),
    FunctionCall(OpFunctionCall),
    Variable(OpVariable),
    ImageTexelPointer(OpImageTexelPointer),
    Load(OpLoad),
    Store(OpStore),
    CopyMemory(OpCopyMemory),
    CopyMemorySized(OpCopyMemorySized),
    AccessChain(OpAccessChain),
    InBoundsAccessChain(OpInBoundsAccessChain),
    PtrAccessChain(OpPtrAccessChain),
    ArrayLength(OpArrayLength),
    GenericPtrMemSemantics(OpGenericPtrMemSemantics),
    InBoundsPtrAccessChain(OpInBoundsPtrAccessChain),
    Decorate(OpDecorate),
    MemberDecorate(OpMemberDecorate),
    DecorationGroup(OpDecorationGroup),
    GroupDecorate(OpGroupDecorate),
    GroupMemberDecorate(OpGroupMemberDecorate),
    VectorExtractDynamic(OpVectorExtractDynamic),
    VectorInsertDynamic(OpVectorInsertDynamic),
    VectorShuffle(OpVectorShuffle),
    CompositeConstruct(OpCompositeConstruct),
    CompositeExtract(OpCompositeExtract),
    CompositeInsert(OpCompositeInsert),
    CopyObject(OpCopyObject),
    Transpose(OpTranspose),
    SampledImage(OpSampledImage),
    ImageSampleImplicitLod(OpImageSampleImplicitLod),
    ImageSampleExplicitLod(OpImageSampleExplicitLod),
    ImageSampleDrefImplicitLod(OpImageSampleDrefImplicitLod),
    ImageSampleDrefExplicitLod(OpImageSampleDrefExplicitLod),
    ImageSampleProjImplicitLod(OpImageSampleProjImplicitLod),
    ImageSampleProjExplicitLod(OpImageSampleProjExplicitLod),
    ImageSampleProjDrefImplicitLod(OpImageSampleProjDrefImplicitLod),
    ImageSampleProjDrefExplicitLod(OpImageSampleProjDrefExplicitLod),
    ImageFetch(OpImageFetch),
    ImageGather(OpImageGather),
    ImageDrefGather(OpImageDrefGather),
    ImageRead(OpImageRead),
    ImageWrite(OpImageWrite),
    Image(OpImage),
    ImageQueryFormat(OpImageQueryFormat),
    ImageQueryOrder(OpImageQueryOrder),
    ImageQuerySizeLod(OpImageQuerySizeLod),
    ImageQuerySize(OpImageQuerySize),
    ImageQueryLod(OpImageQueryLod),
    ImageQueryLevels(OpImageQueryLevels),
    ImageQuerySamples(OpImageQuerySamples),
    ConvertFToU(OpConvertFToU),
    ConvertFToS(OpConvertFToS),
    ConvertSToF(OpConvertSToF),
    ConvertUToF(OpConvertUToF),
    UConvert(OpUConvert),
    SConvert(OpSConvert),
    FConvert(OpFConvert),
    QuantizeToF16(OpQuantizeToF16),
    ConvertPtrToU(OpConvertPtrToU),
    SatConvertSToU(OpSatConvertSToU),
    SatConvertUToS(OpSatConvertUToS),
    ConvertUToPtr(OpConvertUToPtr),
    PtrCastToGeneric(OpPtrCastToGeneric),
    GenericCastToPtr(OpGenericCastToPtr),
    GenericCastToPtrExplicit(OpGenericCastToPtrExplicit),
    Bitcast(OpBitcast),
    SNegate(OpSNegate),
    FNegate(OpFNegate),
    IAdd(OpIAdd),
    FAdd(OpFAdd),
    ISub(OpISub),
    FSub(OpFSub),
    IMul(OpIMul),
    FMul(OpFMul),
    UDiv(OpUDiv),
    SDiv(OpSDiv),
    FDiv(OpFDiv),
    UMod(OpUMod),
    SRem(OpSRem),
    SMod(OpSMod),
    FRem(OpFRem),
    FMod(OpFMod),
    VectorTimesScalar(OpVectorTimesScalar),
    MatrixTimesScalar(OpMatrixTimesScalar),
    VectorTimesMatrix(OpVectorTimesMatrix),
    MatrixTimesVector(OpMatrixTimesVector),
    MatrixTimesMatrix(OpMatrixTimesMatrix),
    OuterProduct(OpOuterProduct),
    Dot(OpDot),
    IAddCarry(OpIAddCarry),
    ISubBorrow(OpISubBorrow),
    UMulExtended(OpUMulExtended),
    SMulExtended(OpSMulExtended),
    Any(OpAny),
    All(OpAll),
    IsNan(OpIsNan),
    IsInf(OpIsInf),
    IsFinite(OpIsFinite),
    IsNormal(OpIsNormal),
    SignBitSet(OpSignBitSet),
    LessOrGreater(OpLessOrGreater),
    Ordered(OpOrdered),
    Unordered(OpUnordered),
    LogicalEqual(OpLogicalEqual),
    LogicalNotEqual(OpLogicalNotEqual),
    LogicalOr(OpLogicalOr),
    LogicalAnd(OpLogicalAnd),
    LogicalNot(OpLogicalNot),
    Select(OpSelect),
    IEqual(OpIEqual),
    INotEqual(OpINotEqual),
    UGreaterThan(OpUGreaterThan),
    SGreaterThan(OpSGreaterThan),
    UGreaterThanEqual(OpUGreaterThanEqual),
    SGreaterThanEqual(OpSGreaterThanEqual),
    ULessThan(OpULessThan),
    SLessThan(OpSLessThan),
    ULessThanEqual(OpULessThanEqual),
    SLessThanEqual(OpSLessThanEqual),
    FOrdEqual(OpFOrdEqual),
    FUnordEqual(OpFUnordEqual),
    FOrdNotEqual(OpFOrdNotEqual),
    FUnordNotEqual(OpFUnordNotEqual),
    FOrdLessThan(OpFOrdLessThan),
    FUnordLessThan(OpFUnordLessThan),
    FOrdGreaterThan(OpFOrdGreaterThan),
    FUnordGreaterThan(OpFUnordGreaterThan),
    FOrdLessThanEqual(OpFOrdLessThanEqual),
    FUnordLessThanEqual(OpFUnordLessThanEqual),
    FOrdGreaterThanEqual(OpFOrdGreaterThanEqual),
    FUnordGreaterThanEqual(OpFUnordGreaterThanEqual),
    ShiftRightLogical(OpShiftRightLogical),
    ShiftRightArithmetic(OpShiftRightArithmetic),
    ShiftLeftLogical(OpShiftLeftLogical),
    BitwiseOr(OpBitwiseOr),
    BitwiseXor(OpBitwiseXor),
    BitwiseAnd(OpBitwiseAnd),
    Not(OpNot),
    BitFieldInsert(OpBitFieldInsert),
    BitFieldSExtract(OpBitFieldSExtract),
    BitFieldUExtract(OpBitFieldUExtract),
    BitReverse(OpBitReverse),
    BitCount(OpBitCount),
    DPdx(OpDPdx),
    DPdy(OpDPdy),
    Fwidth(OpFwidth),
    DPdxFine(OpDPdxFine),
    DPdyFine(OpDPdyFine),
    FwidthFine(OpFwidthFine),
    DPdxCoarse(OpDPdxCoarse),
    DPdyCoarse(OpDPdyCoarse),
    FwidthCoarse(OpFwidthCoarse),
    EmitVertex(OpEmitVertex),
    EndPrimitive(OpEndPrimitive),
    EmitStreamVertex(OpEmitStreamVertex),
    EndStreamPrimitive(OpEndStreamPrimitive),
    ControlBarrier(OpControlBarrier),
    MemoryBarrier(OpMemoryBarrier),
    AtomicLoad(OpAtomicLoad),
    AtomicStore(OpAtomicStore),
    AtomicExchange(OpAtomicExchange),
    AtomicCompareExchange(OpAtomicCompareExchange),
    AtomicCompareExchangeWeak(OpAtomicCompareExchangeWeak),
    AtomicIIncrement(OpAtomicIIncrement),
    AtomicIDecrement(OpAtomicIDecrement),
    AtomicIAdd(OpAtomicIAdd),
    AtomicISub(OpAtomicISub),
    AtomicSMin(OpAtomicSMin),
    AtomicUMin(OpAtomicUMin),
    AtomicSMax(OpAtomicSMax),
    AtomicUMax(OpAtomicUMax),
    AtomicAnd(OpAtomicAnd),
    AtomicOr(OpAtomicOr),
    AtomicXor(OpAtomicXor),
    Phi(OpPhi),
    LoopMerge(OpLoopMerge),
    SelectionMerge(OpSelectionMerge),
    Label(OpLabel),
    Branch(OpBranch),
    BranchConditional(OpBranchConditional),
    Switch32(OpSwitch32),
    Switch64(OpSwitch64),
    Kill(OpKill),
    Return(OpReturn),
    ReturnValue(OpReturnValue),
    Unreachable(OpUnreachable),
    LifetimeStart(OpLifetimeStart),
    LifetimeStop(OpLifetimeStop),
    GroupAsyncCopy(OpGroupAsyncCopy),
    GroupWaitEvents(OpGroupWaitEvents),
    GroupAll(OpGroupAll),
    GroupAny(OpGroupAny),
    GroupBroadcast(OpGroupBroadcast),
    GroupIAdd(OpGroupIAdd),
    GroupFAdd(OpGroupFAdd),
    GroupFMin(OpGroupFMin),
    GroupUMin(OpGroupUMin),
    GroupSMin(OpGroupSMin),
    GroupFMax(OpGroupFMax),
    GroupUMax(OpGroupUMax),
    GroupSMax(OpGroupSMax),
    ReadPipe(OpReadPipe),
    WritePipe(OpWritePipe),
    ReservedReadPipe(OpReservedReadPipe),
    ReservedWritePipe(OpReservedWritePipe),
    ReserveReadPipePackets(OpReserveReadPipePackets),
    ReserveWritePipePackets(OpReserveWritePipePackets),
    CommitReadPipe(OpCommitReadPipe),
    CommitWritePipe(OpCommitWritePipe),
    IsValidReserveId(OpIsValidReserveId),
    GetNumPipePackets(OpGetNumPipePackets),
    GetMaxPipePackets(OpGetMaxPipePackets),
    GroupReserveReadPipePackets(OpGroupReserveReadPipePackets),
    GroupReserveWritePipePackets(OpGroupReserveWritePipePackets),
    GroupCommitReadPipe(OpGroupCommitReadPipe),
    GroupCommitWritePipe(OpGroupCommitWritePipe),
    EnqueueMarker(OpEnqueueMarker),
    EnqueueKernel(OpEnqueueKernel),
    GetKernelNDrangeSubGroupCount(OpGetKernelNDrangeSubGroupCount),
    GetKernelNDrangeMaxSubGroupSize(OpGetKernelNDrangeMaxSubGroupSize),
    GetKernelWorkGroupSize(OpGetKernelWorkGroupSize),
    GetKernelPreferredWorkGroupSizeMultiple(OpGetKernelPreferredWorkGroupSizeMultiple),
    RetainEvent(OpRetainEvent),
    ReleaseEvent(OpReleaseEvent),
    CreateUserEvent(OpCreateUserEvent),
    IsValidEvent(OpIsValidEvent),
    SetUserEventStatus(OpSetUserEventStatus),
    CaptureEventProfilingInfo(OpCaptureEventProfilingInfo),
    GetDefaultQueue(OpGetDefaultQueue),
    BuildNDRange(OpBuildNDRange),
    ImageSparseSampleImplicitLod(OpImageSparseSampleImplicitLod),
    ImageSparseSampleExplicitLod(OpImageSparseSampleExplicitLod),
    ImageSparseSampleDrefImplicitLod(OpImageSparseSampleDrefImplicitLod),
    ImageSparseSampleDrefExplicitLod(OpImageSparseSampleDrefExplicitLod),
    ImageSparseFetch(OpImageSparseFetch),
    ImageSparseGather(OpImageSparseGather),
    ImageSparseDrefGather(OpImageSparseDrefGather),
    ImageSparseTexelsResident(OpImageSparseTexelsResident),
    NoLine(OpNoLine),
    AtomicFlagTestAndSet(OpAtomicFlagTestAndSet),
    AtomicFlagClear(OpAtomicFlagClear),
    ImageSparseRead(OpImageSparseRead),
    SizeOf(OpSizeOf),
    TypePipeStorage(OpTypePipeStorage),
    ConstantPipeStorage(OpConstantPipeStorage),
    CreatePipeFromPipeStorage(OpCreatePipeFromPipeStorage),
    GetKernelLocalSizeForSubgroupCount(OpGetKernelLocalSizeForSubgroupCount),
    GetKernelMaxNumSubgroups(OpGetKernelMaxNumSubgroups),
    TypeNamedBarrier(OpTypeNamedBarrier),
    NamedBarrierInitialize(OpNamedBarrierInitialize),
    MemoryNamedBarrier(OpMemoryNamedBarrier),
    ModuleProcessed(OpModuleProcessed),
    ExecutionModeId(OpExecutionModeId),
    DecorateId(OpDecorateId),
    GroupNonUniformElect(OpGroupNonUniformElect),
    GroupNonUniformAll(OpGroupNonUniformAll),
    GroupNonUniformAny(OpGroupNonUniformAny),
    GroupNonUniformAllEqual(OpGroupNonUniformAllEqual),
    GroupNonUniformBroadcast(OpGroupNonUniformBroadcast),
    GroupNonUniformBroadcastFirst(OpGroupNonUniformBroadcastFirst),
    GroupNonUniformBallot(OpGroupNonUniformBallot),
    GroupNonUniformInverseBallot(OpGroupNonUniformInverseBallot),
    GroupNonUniformBallotBitExtract(OpGroupNonUniformBallotBitExtract),
    GroupNonUniformBallotBitCount(OpGroupNonUniformBallotBitCount),
    GroupNonUniformBallotFindLSB(OpGroupNonUniformBallotFindLSB),
    GroupNonUniformBallotFindMSB(OpGroupNonUniformBallotFindMSB),
    GroupNonUniformShuffle(OpGroupNonUniformShuffle),
    GroupNonUniformShuffleXor(OpGroupNonUniformShuffleXor),
    GroupNonUniformShuffleUp(OpGroupNonUniformShuffleUp),
    GroupNonUniformShuffleDown(OpGroupNonUniformShuffleDown),
    GroupNonUniformIAdd(OpGroupNonUniformIAdd),
    GroupNonUniformFAdd(OpGroupNonUniformFAdd),
    GroupNonUniformIMul(OpGroupNonUniformIMul),
    GroupNonUniformFMul(OpGroupNonUniformFMul),
    GroupNonUniformSMin(OpGroupNonUniformSMin),
    GroupNonUniformUMin(OpGroupNonUniformUMin),
    GroupNonUniformFMin(OpGroupNonUniformFMin),
    GroupNonUniformSMax(OpGroupNonUniformSMax),
    GroupNonUniformUMax(OpGroupNonUniformUMax),
    GroupNonUniformFMax(OpGroupNonUniformFMax),
    GroupNonUniformBitwiseAnd(OpGroupNonUniformBitwiseAnd),
    GroupNonUniformBitwiseOr(OpGroupNonUniformBitwiseOr),
    GroupNonUniformBitwiseXor(OpGroupNonUniformBitwiseXor),
    GroupNonUniformLogicalAnd(OpGroupNonUniformLogicalAnd),
    GroupNonUniformLogicalOr(OpGroupNonUniformLogicalOr),
    GroupNonUniformLogicalXor(OpGroupNonUniformLogicalXor),
    GroupNonUniformQuadBroadcast(OpGroupNonUniformQuadBroadcast),
    GroupNonUniformQuadSwap(OpGroupNonUniformQuadSwap),
    CopyLogical(OpCopyLogical),
    PtrEqual(OpPtrEqual),
    PtrNotEqual(OpPtrNotEqual),
    PtrDiff(OpPtrDiff),
    DecorateString(OpDecorateString),
    MemberDecorateString(OpMemberDecorateString),
    GLSLStd450Round(OpGLSLStd450Round),
    GLSLStd450RoundEven(OpGLSLStd450RoundEven),
    GLSLStd450Trunc(OpGLSLStd450Trunc),
    GLSLStd450FAbs(OpGLSLStd450FAbs),
    GLSLStd450SAbs(OpGLSLStd450SAbs),
    GLSLStd450FSign(OpGLSLStd450FSign),
    GLSLStd450SSign(OpGLSLStd450SSign),
    GLSLStd450Floor(OpGLSLStd450Floor),
    GLSLStd450Ceil(OpGLSLStd450Ceil),
    GLSLStd450Fract(OpGLSLStd450Fract),
    GLSLStd450Radians(OpGLSLStd450Radians),
    GLSLStd450Degrees(OpGLSLStd450Degrees),
    GLSLStd450Sin(OpGLSLStd450Sin),
    GLSLStd450Cos(OpGLSLStd450Cos),
    GLSLStd450Tan(OpGLSLStd450Tan),
    GLSLStd450Asin(OpGLSLStd450Asin),
    GLSLStd450Acos(OpGLSLStd450Acos),
    GLSLStd450Atan(OpGLSLStd450Atan),
    GLSLStd450Sinh(OpGLSLStd450Sinh),
    GLSLStd450Cosh(OpGLSLStd450Cosh),
    GLSLStd450Tanh(OpGLSLStd450Tanh),
    GLSLStd450Asinh(OpGLSLStd450Asinh),
    GLSLStd450Acosh(OpGLSLStd450Acosh),
    GLSLStd450Atanh(OpGLSLStd450Atanh),
    GLSLStd450Atan2(OpGLSLStd450Atan2),
    GLSLStd450Pow(OpGLSLStd450Pow),
    GLSLStd450Exp(OpGLSLStd450Exp),
    GLSLStd450Log(OpGLSLStd450Log),
    GLSLStd450Exp2(OpGLSLStd450Exp2),
    GLSLStd450Log2(OpGLSLStd450Log2),
    GLSLStd450Sqrt(OpGLSLStd450Sqrt),
    GLSLStd450InverseSqrt(OpGLSLStd450InverseSqrt),
    GLSLStd450Determinant(OpGLSLStd450Determinant),
    GLSLStd450MatrixInverse(OpGLSLStd450MatrixInverse),
    GLSLStd450Modf(OpGLSLStd450Modf),
    GLSLStd450ModfStruct(OpGLSLStd450ModfStruct),
    GLSLStd450FMin(OpGLSLStd450FMin),
    GLSLStd450UMin(OpGLSLStd450UMin),
    GLSLStd450SMin(OpGLSLStd450SMin),
    GLSLStd450FMax(OpGLSLStd450FMax),
    GLSLStd450UMax(OpGLSLStd450UMax),
    GLSLStd450SMax(OpGLSLStd450SMax),
    GLSLStd450FClamp(OpGLSLStd450FClamp),
    GLSLStd450UClamp(OpGLSLStd450UClamp),
    GLSLStd450SClamp(OpGLSLStd450SClamp),
    GLSLStd450FMix(OpGLSLStd450FMix),
    GLSLStd450IMix(OpGLSLStd450IMix),
    GLSLStd450Step(OpGLSLStd450Step),
    GLSLStd450SmoothStep(OpGLSLStd450SmoothStep),
    GLSLStd450Fma(OpGLSLStd450Fma),
    GLSLStd450Frexp(OpGLSLStd450Frexp),
    GLSLStd450FrexpStruct(OpGLSLStd450FrexpStruct),
    GLSLStd450Ldexp(OpGLSLStd450Ldexp),
    GLSLStd450PackSnorm4x8(OpGLSLStd450PackSnorm4x8),
    GLSLStd450PackUnorm4x8(OpGLSLStd450PackUnorm4x8),
    GLSLStd450PackSnorm2x16(OpGLSLStd450PackSnorm2x16),
    GLSLStd450PackUnorm2x16(OpGLSLStd450PackUnorm2x16),
    GLSLStd450PackHalf2x16(OpGLSLStd450PackHalf2x16),
    GLSLStd450PackDouble2x32(OpGLSLStd450PackDouble2x32),
    GLSLStd450UnpackSnorm2x16(OpGLSLStd450UnpackSnorm2x16),
    GLSLStd450UnpackUnorm2x16(OpGLSLStd450UnpackUnorm2x16),
    GLSLStd450UnpackHalf2x16(OpGLSLStd450UnpackHalf2x16),
    GLSLStd450UnpackSnorm4x8(OpGLSLStd450UnpackSnorm4x8),
    GLSLStd450UnpackUnorm4x8(OpGLSLStd450UnpackUnorm4x8),
    GLSLStd450UnpackDouble2x32(OpGLSLStd450UnpackDouble2x32),
    GLSLStd450Length(OpGLSLStd450Length),
    GLSLStd450Distance(OpGLSLStd450Distance),
    GLSLStd450Cross(OpGLSLStd450Cross),
    GLSLStd450Normalize(OpGLSLStd450Normalize),
    GLSLStd450FaceForward(OpGLSLStd450FaceForward),
    GLSLStd450Reflect(OpGLSLStd450Reflect),
    GLSLStd450Refract(OpGLSLStd450Refract),
    GLSLStd450FindILsb(OpGLSLStd450FindILsb),
    GLSLStd450FindSMsb(OpGLSLStd450FindSMsb),
    GLSLStd450FindUMsb(OpGLSLStd450FindUMsb),
    GLSLStd450InterpolateAtCentroid(OpGLSLStd450InterpolateAtCentroid),
    GLSLStd450InterpolateAtSample(OpGLSLStd450InterpolateAtSample),
    GLSLStd450InterpolateAtOffset(OpGLSLStd450InterpolateAtOffset),
    GLSLStd450NMin(OpGLSLStd450NMin),
    GLSLStd450NMax(OpGLSLStd450NMax),
    GLSLStd450NClamp(OpGLSLStd450NClamp),
    OpenCLStdAcos(OpOpenCLStdAcos),
    OpenCLStdAcosh(OpOpenCLStdAcosh),
    OpenCLStdAcospi(OpOpenCLStdAcospi),
    OpenCLStdAsin(OpOpenCLStdAsin),
    OpenCLStdAsinh(OpOpenCLStdAsinh),
    OpenCLStdAsinpi(OpOpenCLStdAsinpi),
    OpenCLStdAtan(OpOpenCLStdAtan),
    OpenCLStdAtan2(OpOpenCLStdAtan2),
    OpenCLStdAtanh(OpOpenCLStdAtanh),
    OpenCLStdAtanpi(OpOpenCLStdAtanpi),
    OpenCLStdAtan2pi(OpOpenCLStdAtan2pi),
    OpenCLStdCbrt(OpOpenCLStdCbrt),
    OpenCLStdCeil(OpOpenCLStdCeil),
    OpenCLStdCopysign(OpOpenCLStdCopysign),
    OpenCLStdCos(OpOpenCLStdCos),
    OpenCLStdCosh(OpOpenCLStdCosh),
    OpenCLStdCospi(OpOpenCLStdCospi),
    OpenCLStdErfc(OpOpenCLStdErfc),
    OpenCLStdErf(OpOpenCLStdErf),
    OpenCLStdExp(OpOpenCLStdExp),
    OpenCLStdExp2(OpOpenCLStdExp2),
    OpenCLStdExp10(OpOpenCLStdExp10),
    OpenCLStdExpm1(OpOpenCLStdExpm1),
    OpenCLStdFabs(OpOpenCLStdFabs),
    OpenCLStdFdim(OpOpenCLStdFdim),
    OpenCLStdFloor(OpOpenCLStdFloor),
    OpenCLStdFma(OpOpenCLStdFma),
    OpenCLStdFmax(OpOpenCLStdFmax),
    OpenCLStdFmin(OpOpenCLStdFmin),
    OpenCLStdFmod(OpOpenCLStdFmod),
    OpenCLStdFract(OpOpenCLStdFract),
    OpenCLStdFrexp(OpOpenCLStdFrexp),
    OpenCLStdHypot(OpOpenCLStdHypot),
    OpenCLStdIlogb(OpOpenCLStdIlogb),
    OpenCLStdLdexp(OpOpenCLStdLdexp),
    OpenCLStdLgamma(OpOpenCLStdLgamma),
    OpenCLStdLgammaR(OpOpenCLStdLgammaR),
    OpenCLStdLog(OpOpenCLStdLog),
    OpenCLStdLog2(OpOpenCLStdLog2),
    OpenCLStdLog10(OpOpenCLStdLog10),
    OpenCLStdLog1p(OpOpenCLStdLog1p),
    OpenCLStdLogb(OpOpenCLStdLogb),
    OpenCLStdMad(OpOpenCLStdMad),
    OpenCLStdMaxmag(OpOpenCLStdMaxmag),
    OpenCLStdMinmag(OpOpenCLStdMinmag),
    OpenCLStdModf(OpOpenCLStdModf),
    OpenCLStdNan(OpOpenCLStdNan),
    OpenCLStdNextafter(OpOpenCLStdNextafter),
    OpenCLStdPow(OpOpenCLStdPow),
    OpenCLStdPown(OpOpenCLStdPown),
    OpenCLStdPowr(OpOpenCLStdPowr),
    OpenCLStdRemainder(OpOpenCLStdRemainder),
    OpenCLStdRemquo(OpOpenCLStdRemquo),
    OpenCLStdRint(OpOpenCLStdRint),
    OpenCLStdRootn(OpOpenCLStdRootn),
    OpenCLStdRound(OpOpenCLStdRound),
    OpenCLStdRsqrt(OpOpenCLStdRsqrt),
    OpenCLStdSin(OpOpenCLStdSin),
    OpenCLStdSincos(OpOpenCLStdSincos),
    OpenCLStdSinh(OpOpenCLStdSinh),
    OpenCLStdSinpi(OpOpenCLStdSinpi),
    OpenCLStdSqrt(OpOpenCLStdSqrt),
    OpenCLStdTan(OpOpenCLStdTan),
    OpenCLStdTanh(OpOpenCLStdTanh),
    OpenCLStdTanpi(OpOpenCLStdTanpi),
    OpenCLStdTgamma(OpOpenCLStdTgamma),
    OpenCLStdTrunc(OpOpenCLStdTrunc),
    OpenCLStdHalfCos(OpOpenCLStdHalfCos),
    OpenCLStdHalfDivide(OpOpenCLStdHalfDivide),
    OpenCLStdHalfExp(OpOpenCLStdHalfExp),
    OpenCLStdHalfExp2(OpOpenCLStdHalfExp2),
    OpenCLStdHalfExp10(OpOpenCLStdHalfExp10),
    OpenCLStdHalfLog(OpOpenCLStdHalfLog),
    OpenCLStdHalfLog2(OpOpenCLStdHalfLog2),
    OpenCLStdHalfLog10(OpOpenCLStdHalfLog10),
    OpenCLStdHalfPowr(OpOpenCLStdHalfPowr),
    OpenCLStdHalfRecip(OpOpenCLStdHalfRecip),
    OpenCLStdHalfRsqrt(OpOpenCLStdHalfRsqrt),
    OpenCLStdHalfSin(OpOpenCLStdHalfSin),
    OpenCLStdHalfSqrt(OpOpenCLStdHalfSqrt),
    OpenCLStdHalfTan(OpOpenCLStdHalfTan),
    OpenCLStdNativeCos(OpOpenCLStdNativeCos),
    OpenCLStdNativeDivide(OpOpenCLStdNativeDivide),
    OpenCLStdNativeExp(OpOpenCLStdNativeExp),
    OpenCLStdNativeExp2(OpOpenCLStdNativeExp2),
    OpenCLStdNativeExp10(OpOpenCLStdNativeExp10),
    OpenCLStdNativeLog(OpOpenCLStdNativeLog),
    OpenCLStdNativeLog2(OpOpenCLStdNativeLog2),
    OpenCLStdNativeLog10(OpOpenCLStdNativeLog10),
    OpenCLStdNativePowr(OpOpenCLStdNativePowr),
    OpenCLStdNativeRecip(OpOpenCLStdNativeRecip),
    OpenCLStdNativeRsqrt(OpOpenCLStdNativeRsqrt),
    OpenCLStdNativeSin(OpOpenCLStdNativeSin),
    OpenCLStdNativeSqrt(OpOpenCLStdNativeSqrt),
    OpenCLStdNativeTan(OpOpenCLStdNativeTan),
    OpenCLStdSAbs(OpOpenCLStdSAbs),
    OpenCLStdSAbsDiff(OpOpenCLStdSAbsDiff),
    OpenCLStdSAddSat(OpOpenCLStdSAddSat),
    OpenCLStdUAddSat(OpOpenCLStdUAddSat),
    OpenCLStdSHadd(OpOpenCLStdSHadd),
    OpenCLStdUHadd(OpOpenCLStdUHadd),
    OpenCLStdSRhadd(OpOpenCLStdSRhadd),
    OpenCLStdURhadd(OpOpenCLStdURhadd),
    OpenCLStdSClamp(OpOpenCLStdSClamp),
    OpenCLStdUClamp(OpOpenCLStdUClamp),
    OpenCLStdClz(OpOpenCLStdClz),
    OpenCLStdCtz(OpOpenCLStdCtz),
    OpenCLStdSMadHi(OpOpenCLStdSMadHi),
    OpenCLStdUMadSat(OpOpenCLStdUMadSat),
    OpenCLStdSMadSat(OpOpenCLStdSMadSat),
    OpenCLStdSMax(OpOpenCLStdSMax),
    OpenCLStdUMax(OpOpenCLStdUMax),
    OpenCLStdSMin(OpOpenCLStdSMin),
    OpenCLStdUMin(OpOpenCLStdUMin),
    OpenCLStdSMulHi(OpOpenCLStdSMulHi),
    OpenCLStdRotate(OpOpenCLStdRotate),
    OpenCLStdSSubSat(OpOpenCLStdSSubSat),
    OpenCLStdUSubSat(OpOpenCLStdUSubSat),
    OpenCLStdUUpsample(OpOpenCLStdUUpsample),
    OpenCLStdSUpsample(OpOpenCLStdSUpsample),
    OpenCLStdPopcount(OpOpenCLStdPopcount),
    OpenCLStdSMad24(OpOpenCLStdSMad24),
    OpenCLStdUMad24(OpOpenCLStdUMad24),
    OpenCLStdSMul24(OpOpenCLStdSMul24),
    OpenCLStdUMul24(OpOpenCLStdUMul24),
    OpenCLStdUAbs(OpOpenCLStdUAbs),
    OpenCLStdUAbsDiff(OpOpenCLStdUAbsDiff),
    OpenCLStdUMulHi(OpOpenCLStdUMulHi),
    OpenCLStdUMadHi(OpOpenCLStdUMadHi),
    OpenCLStdFclamp(OpOpenCLStdFclamp),
    OpenCLStdDegrees(OpOpenCLStdDegrees),
    OpenCLStdFmaxCommon(OpOpenCLStdFmaxCommon),
    OpenCLStdFminCommon(OpOpenCLStdFminCommon),
    OpenCLStdMix(OpOpenCLStdMix),
    OpenCLStdRadians(OpOpenCLStdRadians),
    OpenCLStdStep(OpOpenCLStdStep),
    OpenCLStdSmoothstep(OpOpenCLStdSmoothstep),
    OpenCLStdSign(OpOpenCLStdSign),
    OpenCLStdCross(OpOpenCLStdCross),
    OpenCLStdDistance(OpOpenCLStdDistance),
    OpenCLStdLength(OpOpenCLStdLength),
    OpenCLStdNormalize(OpOpenCLStdNormalize),
    OpenCLStdFastDistance(OpOpenCLStdFastDistance),
    OpenCLStdFastLength(OpOpenCLStdFastLength),
    OpenCLStdFastNormalize(OpOpenCLStdFastNormalize),
    OpenCLStdBitselect(OpOpenCLStdBitselect),
    OpenCLStdSelect(OpOpenCLStdSelect),
    OpenCLStdVloadn(OpOpenCLStdVloadn),
    OpenCLStdVstoren(OpOpenCLStdVstoren),
    OpenCLStdVloadHalf(OpOpenCLStdVloadHalf),
    OpenCLStdVloadHalfn(OpOpenCLStdVloadHalfn),
    OpenCLStdVstoreHalf(OpOpenCLStdVstoreHalf),
    OpenCLStdVstoreHalfR(OpOpenCLStdVstoreHalfR),
    OpenCLStdVstoreHalfn(OpOpenCLStdVstoreHalfn),
    OpenCLStdVstoreHalfnR(OpOpenCLStdVstoreHalfnR),
    OpenCLStdVloadaHalfn(OpOpenCLStdVloadaHalfn),
    OpenCLStdVstoreaHalfn(OpOpenCLStdVstoreaHalfn),
    OpenCLStdVstoreaHalfnR(OpOpenCLStdVstoreaHalfnR),
    OpenCLStdShuffle(OpOpenCLStdShuffle),
    OpenCLStdShuffle2(OpOpenCLStdShuffle2),
    OpenCLStdPrintf(OpOpenCLStdPrintf),
    OpenCLStdPrefetch(OpOpenCLStdPrefetch),
}
#[derive(Copy, Clone, Debug)]
pub struct Header {
    pub version: (u32, u32),
    pub generator: u32,
    pub bound: u32,
    pub instruction_schema: u32,
}
impl fmt::Display for Header {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "; SPIR-V")?;
        writeln!(f, "; Version: {}.{}", self.version.0, self.version.1)?;
        writeln!(f, "; Generator: {:#X}", self.generator)?;
        writeln!(f, "; Bound: {}", self.bound)?;
        writeln!(f, "; Schema: {}", self.instruction_schema)
    }
}
struct InstructionIndentAndResult(Option<IdResult>);
impl fmt::Display for InstructionIndentAndResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{:>15}",
            self.0.map(|v| format!("{} = ", v.0)).unwrap_or_default()
        )
    }
}
impl fmt::Display for IdRef {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "%{}", self.0)
    }
}
#[derive(Clone, Debug)]
pub enum Error {
    MissingHeader,
    InvalidHeader,
    BoundTooBig(u32),
    UnsupportedVersion(u32, u32),
    ZeroInstructionLength,
    SourcePrematurelyEnded,
    UnknownOpcode(u16),
    UnknownSpecConstantOpcode(u32),
    UnknownExtensionOpcode(ExtensionInstructionSet, u32),
    Utf8Error(Utf8Error),
    InstructionPrematurelyEnded,
    InvalidStringTermination,
    InstructionTooLong,
    InvalidEnumValue,
    IdOutOfBounds(u32),
    IdAlreadyDefined(IdResult),
    UnsupportedFloatSize,
    UnsupportedIntSize,
    UndefinedType(IdRef),
    SwitchSelectorIsInvalid(IdRef),
    IdIsNotExtInstImport(IdRef),
}
impl From<Utf8Error> for Error {
    fn from(v: Utf8Error) -> Self {
        Error::Utf8Error(v)
    }
}
impl From<FromUtf8Error> for Error {
    fn from(v: FromUtf8Error) -> Self {
        Error::Utf8Error(v.utf8_error())
    }
}
impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Error::MissingHeader => write!(f, "SPIR-V source is missing the file header"),
            Error::InvalidHeader => write!(f, "SPIR-V source has an invalid file header"),
            Error::BoundTooBig(bound) => write !
            (f,
             "SPIR-V source has an invalid file header; the id bound is way bigger than needed: {}",
             bound,),
            Error::UnsupportedVersion(major, minor) => write!(
                f,
                "SPIR-V source has an unsupported version: {}.{}",
                major, minor
            ),
            Error::ZeroInstructionLength => write!(f, "SPIR-V instruction has a length of zero"),
            Error::SourcePrematurelyEnded => write!(f, "SPIR-V source prematurely ended"),
            Error::UnknownOpcode(opcode) => {
                write!(f, "SPIR-V instruction has an unknown opcode: {}", opcode)
            }
            Error::UnknownSpecConstantOpcode(opcode) => write!(
                f,
                "SPIR-V OpSpecConstantOp instruction has an unknown opcode: {}",
                opcode
            ),
            Error::UnknownExtensionOpcode(ref extension_instruction_set, opcode) => write!(
                f,
                "SPIR-V OpExtInst instruction has an unknown opcode: {} in {}",
                opcode, extension_instruction_set
            ),
            Error::Utf8Error(error) => fmt::Display::fmt(&error, f),
            Error::InstructionPrematurelyEnded => write!(f, "SPIR-V instruction prematurely ended"),
            Error::InvalidStringTermination => {
                write!(f, "SPIR-V LiteralString has an invalid termination word")
            }
            Error::InstructionTooLong => write!(f, "SPIR-V instruction is too long"),
            Error::InvalidEnumValue => write!(f, "enum has invalid value"),
            Error::IdOutOfBounds(id) => write!(f, "id is out of bounds: {}", id),
            Error::IdAlreadyDefined(id) => write!(f, "id is already defined: {}", id),
            Error::UnsupportedFloatSize => write!(f, "unsupported float size"),
            Error::UnsupportedIntSize => write!(f, "unsupported int size"),
            Error::UndefinedType(id) => write!(f, "undefined type {}", id),
            Error::SwitchSelectorIsInvalid(id) => write!(f, "Switch selector is invalid: {}", id),
            Error::IdIsNotExtInstImport(id) => write!(
                f,
                "id is not the result of an OpExtInstImport instruction: {}",
                id
            ),
        }
    }
}
pub(crate) type Result<T> = result::Result<T, Error>;
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
enum BitWidth {
    Width32OrLess,
    Width64,
}
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
struct IdStateType(BitWidth);
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
struct IdStateValue(BitWidth);
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
enum IdState {
    Unknown,
    Type(IdStateType),
    Value(IdStateValue),
    ExtensionInstructionSet(ExtensionInstructionSet),
}
#[derive(Clone, Debug)]
struct ParseState {
    id_states: Vec<IdState>,
}
impl ParseState {
    fn define_id(&mut self, id_result: IdResult, new_id_state: IdState) -> Result<()> {
        let id_state = &mut self.id_states[(id_result.0).0 as usize];
        if *id_state != IdState::Unknown {
            return Err(Error::IdAlreadyDefined(id_result));
        }
        *id_state = new_id_state;
        Ok(())
    }
    fn get_type(&self, id: IdRef) -> Result<IdStateType> {
        if let IdState::Type(retval) = self.id_states[id.0 as usize] {
            Ok(retval)
        } else {
            Err(Error::UndefinedType(id))
        }
    }
    fn define_value(&mut self, id_result_type: IdResultType, id_result: IdResult) -> Result<()> {
        if let IdState::Type(IdStateType(bit_width)) = self.id_states[(id_result_type.0).0 as usize]
        {
            self.define_id(id_result, IdState::Value(IdStateValue(bit_width)))?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug)]
pub struct Parser<'a> {
    words: &'a [u32],
    header: Header,
    parse_state: ParseState,
}
fn parse_version(v: u32) -> Result<(u32, u32)> {
    if (v & 0xFF0000FF) != 0 {
        return Err(Error::InvalidHeader);
    }
    let major = (v >> 16) & 0xFF;
    let minor = (v >> 8) & 0xFF;
    Ok((major, minor))
}
impl<'a> Parser<'a> {
    pub fn header(&self) -> &Header {
        &self.header
    }
    pub fn start(mut words: &'a [u32]) -> Result<Self> {
        let header = words.get(0..5).ok_or(Error::MissingHeader)?;
        words = &words[5..];
        let header = match *header {
            [MAGIC_NUMBER, version, generator, bound, instruction_schema @ 0] if bound >= 1 => {
                let version = parse_version(version)?;
                if version.0 != MAJOR_VERSION || version.1 > MINOR_VERSION {
                    return Err(Error::UnsupportedVersion(version.0, version.1));
                }
                Header {
                    version,
                    generator,
                    bound,
                    instruction_schema,
                }
            }
            _ => return Err(Error::InvalidHeader),
        };
        if header.bound as usize > words.len() && header.bound > 0x10000 {
            Err(Error::BoundTooBig(header.bound))
        } else {
            Ok(Self {
                words,
                header,
                parse_state: ParseState {
                    id_states: vec![IdState::Unknown; header.bound as usize],
                },
            })
        }
    }
    fn next_helper(&mut self, length_and_opcode: u32) -> Result<Instruction> {
        let length = (length_and_opcode >> 16) as usize;
        let opcode = length_and_opcode as u16;
        if length == 0 {
            return Err(Error::ZeroInstructionLength);
        }
        let instruction_words = self
            .words
            .get(1..length)
            .ok_or(Error::SourcePrematurelyEnded)?;
        self.words = &self.words[length..];
        parse_instruction(opcode, instruction_words, &mut self.parse_state)
    }
}
impl<'a> Iterator for Parser<'a> {
    type Item = Result<Instruction>;
    fn next(&mut self) -> Option<Result<Instruction>> {
        let length_and_opcode = self.words.get(0)?;
        Some(self.next_helper(*length_and_opcode))
    }
}
fn parse_instruction(
    opcode: u16,
    words: &[u32],
    parse_state: &mut ParseState,
) -> Result<Instruction> {
    match opcode {
        0u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Nop(OpNop {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        1u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Undef(OpUndef {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        2u16 => split_fn!({
            let (continued_source, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SourceContinued(OpSourceContinued {
                    continued_source,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        3u16 => split_fn!({
            let (source_language, words) = SourceLanguage::spirv_parse(words, parse_state)?;
            let (version, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (file, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            let (source, words) = Option::<LiteralString>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Source(OpSource {
                    source_language,
                    version,
                    file,
                    source,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        4u16 => split_fn!({
            let (extension, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SourceExtension(OpSourceExtension {
                    extension,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        5u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Name(OpName { target, name }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        6u16 => split_fn!({
            let (type_, words) = IdRef::spirv_parse(words, parse_state)?;
            let (member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemberName(OpMemberName {
                    type_,
                    member,
                    name,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        7u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (string, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::String(OpString { id_result, string }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        8u16 => split_fn!({
            let (file, words) = IdRef::spirv_parse(words, parse_state)?;
            let (line, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (column, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Line(OpLine { file, line, column }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        10u16 => split_fn!({
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Extension(OpExtension { name }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        11u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            parse_state.define_id(
                id_result,
                IdState::ExtensionInstructionSet(ExtensionInstructionSet::from(&*name)),
            )?;
            if words.is_empty() {
                Ok(Instruction::ExtInstImport(OpExtInstImport {
                    id_result,
                    name,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        12u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            let (set, words) = IdRef::spirv_parse(words, parse_state)?;
            let (instruction, words) = LiteralExtInstInteger::spirv_parse(words, parse_state)?;
            let extension_instruction_set;
            match parse_state.id_states[set.0 as usize].clone() {
                IdState::ExtensionInstructionSet(ExtensionInstructionSet::Other(_)) => {
                    let (operands, words) =
                        Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        return Ok(Instruction::ExtInst(OpExtInst {
                            id_result_type,
                            id_result,
                            set,
                            instruction,
                            operands,
                        }));
                    } else {
                        return Err(Error::InstructionTooLong);
                    }
                }
                IdState::ExtensionInstructionSet(v) => {
                    extension_instruction_set = v;
                }
                _ => return Err(Error::IdIsNotExtInstImport(set)),
            };
            match (extension_instruction_set, instruction) {
                (ExtensionInstructionSet::GLSLStd450, 1u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Round(OpGLSLStd450Round {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 2u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450RoundEven(OpGLSLStd450RoundEven {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 3u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Trunc(OpGLSLStd450Trunc {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 4u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FAbs(OpGLSLStd450FAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 5u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SAbs(OpGLSLStd450SAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 6u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FSign(OpGLSLStd450FSign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 7u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SSign(OpGLSLStd450SSign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 8u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Floor(OpGLSLStd450Floor {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 9u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Ceil(OpGLSLStd450Ceil {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 10u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Fract(OpGLSLStd450Fract {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 11u32) => split_fn!({
                    let (degrees, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Radians(OpGLSLStd450Radians {
                            id_result_type,
                            id_result,
                            set,
                            degrees,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 12u32) => split_fn!({
                    let (radians, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Degrees(OpGLSLStd450Degrees {
                            id_result_type,
                            id_result,
                            set,
                            radians,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 13u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Sin(OpGLSLStd450Sin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 14u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Cos(OpGLSLStd450Cos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 15u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Tan(OpGLSLStd450Tan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 16u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Asin(OpGLSLStd450Asin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 17u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Acos(OpGLSLStd450Acos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 18u32) => split_fn!({
                    let (y_over_x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Atan(OpGLSLStd450Atan {
                            id_result_type,
                            id_result,
                            set,
                            y_over_x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 19u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Sinh(OpGLSLStd450Sinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 20u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Cosh(OpGLSLStd450Cosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 21u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Tanh(OpGLSLStd450Tanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 22u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Asinh(OpGLSLStd450Asinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 23u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Acosh(OpGLSLStd450Acosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 24u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Atanh(OpGLSLStd450Atanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 25u32) => split_fn!({
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Atan2(OpGLSLStd450Atan2 {
                            id_result_type,
                            id_result,
                            set,
                            y,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 26u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Pow(OpGLSLStd450Pow {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 27u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Exp(OpGLSLStd450Exp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 28u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Log(OpGLSLStd450Log {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 29u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Exp2(OpGLSLStd450Exp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 30u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Log2(OpGLSLStd450Log2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 31u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Sqrt(OpGLSLStd450Sqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 32u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InverseSqrt(
                            OpGLSLStd450InverseSqrt {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 33u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Determinant(
                            OpGLSLStd450Determinant {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 34u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450MatrixInverse(
                            OpGLSLStd450MatrixInverse {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 35u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Modf(OpGLSLStd450Modf {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            i,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 36u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450ModfStruct(OpGLSLStd450ModfStruct {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 37u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FMin(OpGLSLStd450FMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 38u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UMin(OpGLSLStd450UMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 39u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SMin(OpGLSLStd450SMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 40u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FMax(OpGLSLStd450FMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 41u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UMax(OpGLSLStd450UMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 42u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SMax(OpGLSLStd450SMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 43u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FClamp(OpGLSLStd450FClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 44u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UClamp(OpGLSLStd450UClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 45u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SClamp(OpGLSLStd450SClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 46u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FMix(OpGLSLStd450FMix {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            a,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 47u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450IMix(OpGLSLStd450IMix {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            a,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 48u32) => split_fn!({
                    let (edge, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Step(OpGLSLStd450Step {
                            id_result_type,
                            id_result,
                            set,
                            edge,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 49u32) => split_fn!({
                    let (edge0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (edge1, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450SmoothStep(OpGLSLStd450SmoothStep {
                            id_result_type,
                            id_result,
                            set,
                            edge0,
                            edge1,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 50u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Fma(OpGLSLStd450Fma {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 51u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (exp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Frexp(OpGLSLStd450Frexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            exp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 52u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FrexpStruct(
                            OpGLSLStd450FrexpStruct {
                                id_result_type,
                                id_result,
                                set,
                                x,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 53u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (exp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Ldexp(OpGLSLStd450Ldexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            exp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 54u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackSnorm4x8(
                            OpGLSLStd450PackSnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 55u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackUnorm4x8(
                            OpGLSLStd450PackUnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 56u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackSnorm2x16(
                            OpGLSLStd450PackSnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 57u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackUnorm2x16(
                            OpGLSLStd450PackUnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 58u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackHalf2x16(
                            OpGLSLStd450PackHalf2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 59u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450PackDouble2x32(
                            OpGLSLStd450PackDouble2x32 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 60u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackSnorm2x16(
                            OpGLSLStd450UnpackSnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 61u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackUnorm2x16(
                            OpGLSLStd450UnpackUnorm2x16 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 62u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackHalf2x16(
                            OpGLSLStd450UnpackHalf2x16 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 63u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackSnorm4x8(
                            OpGLSLStd450UnpackSnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 64u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackUnorm4x8(
                            OpGLSLStd450UnpackUnorm4x8 {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 65u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450UnpackDouble2x32(
                            OpGLSLStd450UnpackDouble2x32 {
                                id_result_type,
                                id_result,
                                set,
                                v,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 66u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Length(OpGLSLStd450Length {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 67u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Distance(OpGLSLStd450Distance {
                            id_result_type,
                            id_result,
                            set,
                            p0,
                            p1,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 68u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Cross(OpGLSLStd450Cross {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 69u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Normalize(OpGLSLStd450Normalize {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 70u32) => split_fn!({
                    let (n, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (nref, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FaceForward(
                            OpGLSLStd450FaceForward {
                                id_result_type,
                                id_result,
                                set,
                                n,
                                i,
                                nref,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 71u32) => split_fn!({
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Reflect(OpGLSLStd450Reflect {
                            id_result_type,
                            id_result,
                            set,
                            i,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 72u32) => split_fn!({
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (eta, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450Refract(OpGLSLStd450Refract {
                            id_result_type,
                            id_result,
                            set,
                            i,
                            n,
                            eta,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 73u32) => split_fn!({
                    let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FindILsb(OpGLSLStd450FindILsb {
                            id_result_type,
                            id_result,
                            set,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 74u32) => split_fn!({
                    let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FindSMsb(OpGLSLStd450FindSMsb {
                            id_result_type,
                            id_result,
                            set,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 75u32) => split_fn!({
                    let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450FindUMsb(OpGLSLStd450FindUMsb {
                            id_result_type,
                            id_result,
                            set,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 76u32) => split_fn!({
                    let (interpolant, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InterpolateAtCentroid(
                            OpGLSLStd450InterpolateAtCentroid {
                                id_result_type,
                                id_result,
                                set,
                                interpolant,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 77u32) => split_fn!({
                    let (interpolant, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (sample, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InterpolateAtSample(
                            OpGLSLStd450InterpolateAtSample {
                                id_result_type,
                                id_result,
                                set,
                                interpolant,
                                sample,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 78u32) => split_fn!({
                    let (interpolant, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450InterpolateAtOffset(
                            OpGLSLStd450InterpolateAtOffset {
                                id_result_type,
                                id_result,
                                set,
                                interpolant,
                                offset,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 79u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450NMin(OpGLSLStd450NMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 80u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450NMax(OpGLSLStd450NMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::GLSLStd450, 81u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (min_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (max_val, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::GLSLStd450NClamp(OpGLSLStd450NClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            min_val,
                            max_val,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 0u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAcos(OpOpenCLStdAcos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 1u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAcosh(OpOpenCLStdAcosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 2u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAcospi(OpOpenCLStdAcospi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 3u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAsin(OpOpenCLStdAsin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 4u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAsinh(OpOpenCLStdAsinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 5u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAsinpi(OpOpenCLStdAsinpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 6u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtan(OpOpenCLStdAtan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 7u32) => split_fn!({
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtan2(OpOpenCLStdAtan2 {
                            id_result_type,
                            id_result,
                            set,
                            y,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 8u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtanh(OpOpenCLStdAtanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 9u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtanpi(OpOpenCLStdAtanpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 10u32) => split_fn!({
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdAtan2pi(OpOpenCLStdAtan2pi {
                            id_result_type,
                            id_result,
                            set,
                            y,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 11u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCbrt(OpOpenCLStdCbrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 12u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCeil(OpOpenCLStdCeil {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 13u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCopysign(OpOpenCLStdCopysign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 14u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCos(OpOpenCLStdCos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 15u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCosh(OpOpenCLStdCosh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 16u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCospi(OpOpenCLStdCospi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 17u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdErfc(OpOpenCLStdErfc {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 18u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdErf(OpOpenCLStdErf {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 19u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExp(OpOpenCLStdExp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 20u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExp2(OpOpenCLStdExp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 21u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExp10(OpOpenCLStdExp10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 22u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdExpm1(OpOpenCLStdExpm1 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 23u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFabs(OpOpenCLStdFabs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 24u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFdim(OpOpenCLStdFdim {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 25u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFloor(OpOpenCLStdFloor {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 26u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFma(OpOpenCLStdFma {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 27u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmax(OpOpenCLStdFmax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 28u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmin(OpOpenCLStdFmin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 29u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmod(OpOpenCLStdFmod {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 30u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (ptr, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFract(OpOpenCLStdFract {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            ptr,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 31u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (exp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFrexp(OpOpenCLStdFrexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            exp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 32u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHypot(OpOpenCLStdHypot {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 33u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdIlogb(OpOpenCLStdIlogb {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 34u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (k, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLdexp(OpOpenCLStdLdexp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            k,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 35u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLgamma(OpOpenCLStdLgamma {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 36u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (signp, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLgammaR(OpOpenCLStdLgammaR {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            signp,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 37u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog(OpOpenCLStdLog {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 38u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog2(OpOpenCLStdLog2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 39u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog10(OpOpenCLStdLog10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 40u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLog1p(OpOpenCLStdLog1p {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 41u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLogb(OpOpenCLStdLogb {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 42u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMad(OpOpenCLStdMad {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 43u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMaxmag(OpOpenCLStdMaxmag {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 44u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMinmag(OpOpenCLStdMinmag {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 45u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (iptr, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdModf(OpOpenCLStdModf {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            iptr,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 46u32) => split_fn!({
                    let (nancode, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNan(OpOpenCLStdNan {
                            id_result_type,
                            id_result,
                            set,
                            nancode,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 47u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNextafter(OpOpenCLStdNextafter {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 48u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPow(OpOpenCLStdPow {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 49u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPown(OpOpenCLStdPown {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 50u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPowr(OpOpenCLStdPowr {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 51u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRemainder(OpOpenCLStdRemainder {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 52u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (quo, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRemquo(OpOpenCLStdRemquo {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            quo,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 53u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRint(OpOpenCLStdRint {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 54u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRootn(OpOpenCLStdRootn {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 55u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRound(OpOpenCLStdRound {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 56u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRsqrt(OpOpenCLStdRsqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 57u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSin(OpOpenCLStdSin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 58u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (cosval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSincos(OpOpenCLStdSincos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            cosval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 59u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSinh(OpOpenCLStdSinh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 60u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSinpi(OpOpenCLStdSinpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 61u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSqrt(OpOpenCLStdSqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 62u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTan(OpOpenCLStdTan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 63u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTanh(OpOpenCLStdTanh {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 64u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTanpi(OpOpenCLStdTanpi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 65u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTgamma(OpOpenCLStdTgamma {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 66u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdTrunc(OpOpenCLStdTrunc {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 67u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfCos(OpOpenCLStdHalfCos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 68u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfDivide(OpOpenCLStdHalfDivide {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 69u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfExp(OpOpenCLStdHalfExp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 70u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfExp2(OpOpenCLStdHalfExp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 71u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfExp10(OpOpenCLStdHalfExp10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 72u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfLog(OpOpenCLStdHalfLog {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 73u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfLog2(OpOpenCLStdHalfLog2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 74u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfLog10(OpOpenCLStdHalfLog10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 75u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfPowr(OpOpenCLStdHalfPowr {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 76u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfRecip(OpOpenCLStdHalfRecip {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 77u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfRsqrt(OpOpenCLStdHalfRsqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 78u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfSin(OpOpenCLStdHalfSin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 79u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfSqrt(OpOpenCLStdHalfSqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 80u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdHalfTan(OpOpenCLStdHalfTan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 81u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeCos(OpOpenCLStdNativeCos {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 82u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeDivide(
                            OpOpenCLStdNativeDivide {
                                id_result_type,
                                id_result,
                                set,
                                x,
                                y,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 83u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeExp(OpOpenCLStdNativeExp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 84u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeExp2(OpOpenCLStdNativeExp2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 85u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeExp10(OpOpenCLStdNativeExp10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 86u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeLog(OpOpenCLStdNativeLog {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 87u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeLog2(OpOpenCLStdNativeLog2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 88u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeLog10(OpOpenCLStdNativeLog10 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 89u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativePowr(OpOpenCLStdNativePowr {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 90u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeRecip(OpOpenCLStdNativeRecip {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 91u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeRsqrt(OpOpenCLStdNativeRsqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 92u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeSin(OpOpenCLStdNativeSin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 93u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeSqrt(OpOpenCLStdNativeSqrt {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 94u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNativeTan(OpOpenCLStdNativeTan {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 141u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSAbs(OpOpenCLStdSAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 142u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSAbsDiff(OpOpenCLStdSAbsDiff {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 143u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSAddSat(OpOpenCLStdSAddSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 144u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUAddSat(OpOpenCLStdUAddSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 145u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSHadd(OpOpenCLStdSHadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 146u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUHadd(OpOpenCLStdUHadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 147u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSRhadd(OpOpenCLStdSRhadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 148u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdURhadd(OpOpenCLStdURhadd {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 149u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (minval, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (maxval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSClamp(OpOpenCLStdSClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            minval,
                            maxval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 150u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (minval, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (maxval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUClamp(OpOpenCLStdUClamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            minval,
                            maxval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 151u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdClz(OpOpenCLStdClz {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 152u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCtz(OpOpenCLStdCtz {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 153u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMadHi(OpOpenCLStdSMadHi {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 154u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMadSat(OpOpenCLStdUMadSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 155u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMadSat(OpOpenCLStdSMadSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 156u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMax(OpOpenCLStdSMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 157u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMax(OpOpenCLStdUMax {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 158u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMin(OpOpenCLStdSMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 159u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMin(OpOpenCLStdUMin {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 160u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMulHi(OpOpenCLStdSMulHi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 161u32) => split_fn!({
                    let (v, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (i, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRotate(OpOpenCLStdRotate {
                            id_result_type,
                            id_result,
                            set,
                            v,
                            i,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 162u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSSubSat(OpOpenCLStdSSubSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 163u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUSubSat(OpOpenCLStdUSubSat {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 164u32) => split_fn!({
                    let (hi, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (lo, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUUpsample(OpOpenCLStdUUpsample {
                            id_result_type,
                            id_result,
                            set,
                            hi,
                            lo,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 165u32) => split_fn!({
                    let (hi, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (lo, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSUpsample(OpOpenCLStdSUpsample {
                            id_result_type,
                            id_result,
                            set,
                            hi,
                            lo,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 166u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPopcount(OpOpenCLStdPopcount {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 167u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMad24(OpOpenCLStdSMad24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 168u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (z, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMad24(OpOpenCLStdUMad24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            z,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 169u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSMul24(OpOpenCLStdSMul24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 170u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMul24(OpOpenCLStdUMul24 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 201u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUAbs(OpOpenCLStdUAbs {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 202u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUAbsDiff(OpOpenCLStdUAbsDiff {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 203u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMulHi(OpOpenCLStdUMulHi {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 204u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdUMadHi(OpOpenCLStdUMadHi {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 95u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (minval, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (maxval, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFclamp(OpOpenCLStdFclamp {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            minval,
                            maxval,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 96u32) => split_fn!({
                    let (radians, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdDegrees(OpOpenCLStdDegrees {
                            id_result_type,
                            id_result,
                            set,
                            radians,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 97u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFmaxCommon(OpOpenCLStdFmaxCommon {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 98u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFminCommon(OpOpenCLStdFminCommon {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 99u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdMix(OpOpenCLStdMix {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            a,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 100u32) => split_fn!({
                    let (degrees, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdRadians(OpOpenCLStdRadians {
                            id_result_type,
                            id_result,
                            set,
                            degrees,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 101u32) => split_fn!({
                    let (edge, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdStep(OpOpenCLStdStep {
                            id_result_type,
                            id_result,
                            set,
                            edge,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 102u32) => split_fn!({
                    let (edge0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (edge1, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSmoothstep(OpOpenCLStdSmoothstep {
                            id_result_type,
                            id_result,
                            set,
                            edge0,
                            edge1,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 103u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSign(OpOpenCLStdSign {
                            id_result_type,
                            id_result,
                            set,
                            x,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 104u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdCross(OpOpenCLStdCross {
                            id_result_type,
                            id_result,
                            set,
                            p0,
                            p1,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 105u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdDistance(OpOpenCLStdDistance {
                            id_result_type,
                            id_result,
                            set,
                            p0,
                            p1,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 106u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdLength(OpOpenCLStdLength {
                            id_result_type,
                            id_result,
                            set,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 107u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdNormalize(OpOpenCLStdNormalize {
                            id_result_type,
                            id_result,
                            set,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 108u32) => split_fn!({
                    let (p0, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p1, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFastDistance(
                            OpOpenCLStdFastDistance {
                                id_result_type,
                                id_result,
                                set,
                                p0,
                                p1,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 109u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFastLength(OpOpenCLStdFastLength {
                            id_result_type,
                            id_result,
                            set,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 110u32) => split_fn!({
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdFastNormalize(
                            OpOpenCLStdFastNormalize {
                                id_result_type,
                                id_result,
                                set,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 186u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdBitselect(OpOpenCLStdBitselect {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 187u32) => split_fn!({
                    let (a, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (b, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (c, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdSelect(OpOpenCLStdSelect {
                            id_result_type,
                            id_result,
                            set,
                            a,
                            b,
                            c,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 171u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadn(OpOpenCLStdVloadn {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 172u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoren(OpOpenCLStdVstoren {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 173u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadHalf(OpOpenCLStdVloadHalf {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 174u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadHalfn(OpOpenCLStdVloadHalfn {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 175u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalf(OpOpenCLStdVstoreHalf {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 176u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (mode, words) = FPRoundingMode::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalfR(OpOpenCLStdVstoreHalfR {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                            mode,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 177u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalfn(OpOpenCLStdVstoreHalfn {
                            id_result_type,
                            id_result,
                            set,
                            data,
                            offset,
                            p,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 178u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (mode, words) = FPRoundingMode::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreHalfnR(
                            OpOpenCLStdVstoreHalfnR {
                                id_result_type,
                                id_result,
                                set,
                                data,
                                offset,
                                p,
                                mode,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 179u32) => split_fn!({
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (n, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVloadaHalfn(OpOpenCLStdVloadaHalfn {
                            id_result_type,
                            id_result,
                            set,
                            offset,
                            p,
                            n,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 180u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreaHalfn(
                            OpOpenCLStdVstoreaHalfn {
                                id_result_type,
                                id_result,
                                set,
                                data,
                                offset,
                                p,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 181u32) => split_fn!({
                    let (data, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (p, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (mode, words) = FPRoundingMode::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdVstoreaHalfnR(
                            OpOpenCLStdVstoreaHalfnR {
                                id_result_type,
                                id_result,
                                set,
                                data,
                                offset,
                                p,
                                mode,
                            },
                        ))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 182u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (shuffle_mask, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdShuffle(OpOpenCLStdShuffle {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            shuffle_mask,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 183u32) => split_fn!({
                    let (x, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (y, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (shuffle_mask, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdShuffle2(OpOpenCLStdShuffle2 {
                            id_result_type,
                            id_result,
                            set,
                            x,
                            y,
                            shuffle_mask,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 184u32) => split_fn!({
                    let (format, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (additional_arguments, words) =
                        Vec::<IdRef>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPrintf(OpOpenCLStdPrintf {
                            id_result_type,
                            id_result,
                            set,
                            format,
                            additional_arguments,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (ExtensionInstructionSet::OpenCLStd, 185u32) => split_fn!({
                    let (ptr, words) = IdRef::spirv_parse(words, parse_state)?;
                    let (num_elements, words) = IdRef::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::OpenCLStdPrefetch(OpOpenCLStdPrefetch {
                            id_result_type,
                            id_result,
                            set,
                            ptr,
                            num_elements,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }),
                (extension_instruction_set, instruction) => Err(Error::UnknownExtensionOpcode(
                    extension_instruction_set,
                    instruction,
                )),
            }
        }),
        14u16 => split_fn!({
            let (addressing_model, words) = AddressingModel::spirv_parse(words, parse_state)?;
            let (memory_model, words) = MemoryModel::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemoryModel(OpMemoryModel {
                    addressing_model,
                    memory_model,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        15u16 => split_fn!({
            let (execution_model, words) = ExecutionModel::spirv_parse(words, parse_state)?;
            let (entry_point, words) = IdRef::spirv_parse(words, parse_state)?;
            let (name, words) = LiteralString::spirv_parse(words, parse_state)?;
            let (interface, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::EntryPoint(OpEntryPoint {
                    execution_model,
                    entry_point,
                    name,
                    interface,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        16u16 => split_fn!({
            let (entry_point, words) = IdRef::spirv_parse(words, parse_state)?;
            let (mode, words) = ExecutionMode::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ExecutionMode(OpExecutionMode {
                    entry_point,
                    mode,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        17u16 => split_fn!({
            let (capability, words) = Capability::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Capability(OpCapability { capability }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        19u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeVoid(OpTypeVoid { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        20u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeBool(OpTypeBool { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        21u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (signedness, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let id_state = match width {
                8 | 16 | 32 => IdState::Type(IdStateType(BitWidth::Width32OrLess)),
                64 => IdState::Type(IdStateType(BitWidth::Width64)),
                _ => return Err(Error::UnsupportedIntSize),
            };
            parse_state.define_id(id_result, id_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeInt(OpTypeInt {
                    id_result,
                    width,
                    signedness,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        22u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (width, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let id_state = match width {
                16 | 32 => IdState::Type(IdStateType(BitWidth::Width32OrLess)),
                64 => IdState::Type(IdStateType(BitWidth::Width64)),
                _ => return Err(Error::UnsupportedFloatSize),
            };
            parse_state.define_id(id_result, id_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeFloat(OpTypeFloat { id_result, width }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        23u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (component_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component_count, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeVector(OpTypeVector {
                    id_result,
                    component_type,
                    component_count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        24u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (column_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (column_count, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeMatrix(OpTypeMatrix {
                    id_result,
                    column_type,
                    column_count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        25u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (dim, words) = Dim::spirv_parse(words, parse_state)?;
            let (depth, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (arrayed, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (ms, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (sampled, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (image_format, words) = ImageFormat::spirv_parse(words, parse_state)?;
            let (access_qualifier, words) =
                Option::<AccessQualifier>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeImage(OpTypeImage {
                    id_result,
                    sampled_type,
                    dim,
                    depth,
                    arrayed,
                    ms,
                    sampled,
                    image_format,
                    access_qualifier,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        26u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeSampler(OpTypeSampler { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        27u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image_type, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeSampledImage(OpTypeSampledImage {
                    id_result,
                    image_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        28u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (element_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (length, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeArray(OpTypeArray {
                    id_result,
                    element_type,
                    length,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        29u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (element_type, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeRuntimeArray(OpTypeRuntimeArray {
                    id_result,
                    element_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        30u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (member_types, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeStruct(OpTypeStruct {
                    id_result,
                    member_types,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        31u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (the_name_of_the_opaque_type, words) =
                LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeOpaque(OpTypeOpaque {
                    id_result,
                    the_name_of_the_opaque_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        32u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (storage_class, words) = StorageClass::spirv_parse(words, parse_state)?;
            let (type_, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypePointer(OpTypePointer {
                    id_result,
                    storage_class,
                    type_,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        33u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (return_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (parameter_types, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeFunction(OpTypeFunction {
                    id_result,
                    return_type,
                    parameter_types,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        34u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeEvent(OpTypeEvent { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        35u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeDeviceEvent(OpTypeDeviceEvent {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        36u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeReserveId(OpTypeReserveId { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        37u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeQueue(OpTypeQueue { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        38u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (qualifier, words) = AccessQualifier::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypePipe(OpTypePipe {
                    id_result,
                    qualifier,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        39u16 => split_fn!({
            let (pointer_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (storage_class, words) = StorageClass::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeForwardPointer(OpTypeForwardPointer {
                    pointer_type,
                    storage_class,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        41u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantTrue(OpConstantTrue {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        42u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantFalse(OpConstantFalse {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        43u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            match parse_state.get_type(id_result_type.0)? {
                IdStateType(BitWidth::Width32OrLess) => {
                    let (value, words) =
                        LiteralContextDependentNumber32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Constant32(OpConstant32 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                IdStateType(BitWidth::Width64) => {
                    let (value, words) =
                        LiteralContextDependentNumber64::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Constant64(OpConstant64 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
            }
        }),
        44u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (constituents, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantComposite(OpConstantComposite {
                    id_result_type,
                    id_result,
                    constituents,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        45u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampler_addressing_mode, words) =
                SamplerAddressingMode::spirv_parse(words, parse_state)?;
            let (param, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (sampler_filter_mode, words) = SamplerFilterMode::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantSampler(OpConstantSampler {
                    id_result_type,
                    id_result,
                    sampler_addressing_mode,
                    param,
                    sampler_filter_mode,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        46u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantNull(OpConstantNull {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        48u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantTrue(OpSpecConstantTrue {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        49u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantFalse(OpSpecConstantFalse {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        50u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            match parse_state.get_type(id_result_type.0)? {
                IdStateType(BitWidth::Width32OrLess) => {
                    let (value, words) =
                        LiteralContextDependentNumber32::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::SpecConstant32(OpSpecConstant32 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                IdStateType(BitWidth::Width64) => {
                    let (value, words) =
                        LiteralContextDependentNumber64::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::SpecConstant64(OpSpecConstant64 {
                            id_result_type,
                            id_result,
                            value,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
            }
        }),
        51u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (constituents, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantComposite(
                    OpSpecConstantComposite {
                        id_result_type,
                        id_result,
                        constituents,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        52u16 => split_fn!({
            let (operation, words) = OpSpecConstantOp::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SpecConstantOp(operation))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        54u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (function_control, words) = FunctionControl::spirv_parse(words, parse_state)?;
            let (function_type, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Function(OpFunction {
                    id_result_type,
                    id_result,
                    function_control,
                    function_type,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        55u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FunctionParameter(OpFunctionParameter {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        56u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::FunctionEnd(OpFunctionEnd {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        57u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (function, words) = IdRef::spirv_parse(words, parse_state)?;
            let (arguments, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FunctionCall(OpFunctionCall {
                    id_result_type,
                    id_result,
                    function,
                    arguments,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        59u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (storage_class, words) = StorageClass::spirv_parse(words, parse_state)?;
            let (initializer, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Variable(OpVariable {
                    id_result_type,
                    id_result,
                    storage_class,
                    initializer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        60u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (sample, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageTexelPointer(OpImageTexelPointer {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    sample,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        61u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Load(OpLoad {
                    id_result_type,
                    id_result,
                    pointer,
                    memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        62u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (object, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Store(OpStore {
                    pointer,
                    object,
                    memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        63u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (source, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            let (source_memory_access, words) =
                Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CopyMemory(OpCopyMemory {
                    target,
                    source,
                    memory_access,
                    source_memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        64u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (source, words) = IdRef::spirv_parse(words, parse_state)?;
            let (size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory_access, words) = Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            let (source_memory_access, words) =
                Option::<MemoryAccess>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CopyMemorySized(OpCopyMemorySized {
                    target,
                    source,
                    size,
                    memory_access,
                    source_memory_access,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        65u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AccessChain(OpAccessChain {
                    id_result_type,
                    id_result,
                    base,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        66u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::InBoundsAccessChain(OpInBoundsAccessChain {
                    id_result_type,
                    id_result,
                    base,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        67u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (element, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrAccessChain(OpPtrAccessChain {
                    id_result_type,
                    id_result,
                    base,
                    element,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        68u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (structure, words) = IdRef::spirv_parse(words, parse_state)?;
            let (array_member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ArrayLength(OpArrayLength {
                    id_result_type,
                    id_result,
                    structure,
                    array_member,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        69u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GenericPtrMemSemantics(
                    OpGenericPtrMemSemantics {
                        id_result_type,
                        id_result,
                        pointer,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        70u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (element, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::InBoundsPtrAccessChain(
                    OpInBoundsPtrAccessChain {
                        id_result_type,
                        id_result,
                        base,
                        element,
                        indexes,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        71u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Decorate(OpDecorate { target, decoration }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        72u16 => split_fn!({
            let (structure_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemberDecorate(OpMemberDecorate {
                    structure_type,
                    member,
                    decoration,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        73u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::DecorationGroup(OpDecorationGroup {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        74u16 => split_fn!({
            let (decoration_group, words) = IdRef::spirv_parse(words, parse_state)?;
            let (targets, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupDecorate(OpGroupDecorate {
                    decoration_group,
                    targets,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        75u16 => split_fn!({
            let (decoration_group, words) = IdRef::spirv_parse(words, parse_state)?;
            let (targets, words) = Vec::<PairIdRefLiteralInteger>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupMemberDecorate(OpGroupMemberDecorate {
                    decoration_group,
                    targets,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        77u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorExtractDynamic(OpVectorExtractDynamic {
                    id_result_type,
                    id_result,
                    vector,
                    index,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        78u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorInsertDynamic(OpVectorInsertDynamic {
                    id_result_type,
                    id_result,
                    vector,
                    component,
                    index,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        79u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
            let (components, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorShuffle(OpVectorShuffle {
                    id_result_type,
                    id_result,
                    vector_1,
                    vector_2,
                    components,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        80u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (constituents, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CompositeConstruct(OpCompositeConstruct {
                    id_result_type,
                    id_result,
                    constituents,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        81u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CompositeExtract(OpCompositeExtract {
                    id_result_type,
                    id_result,
                    composite,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        82u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (object, words) = IdRef::spirv_parse(words, parse_state)?;
            let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
            let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CompositeInsert(OpCompositeInsert {
                    id_result_type,
                    id_result,
                    object,
                    composite,
                    indexes,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        83u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CopyObject(OpCopyObject {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        84u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Transpose(OpTranspose {
                    id_result_type,
                    id_result,
                    matrix,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        86u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (sampler, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SampledImage(OpSampledImage {
                    id_result_type,
                    id_result,
                    image,
                    sampler,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        87u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleImplicitLod(
                    OpImageSampleImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        88u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleExplicitLod(
                    OpImageSampleExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        89u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleDrefImplicitLod(
                    OpImageSampleDrefImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        90u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleDrefExplicitLod(
                    OpImageSampleDrefExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        91u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjImplicitLod(
                    OpImageSampleProjImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        92u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjExplicitLod(
                    OpImageSampleProjExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        93u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjDrefImplicitLod(
                    OpImageSampleProjDrefImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        94u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSampleProjDrefExplicitLod(
                    OpImageSampleProjDrefExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        95u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageFetch(OpImageFetch {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        96u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageGather(OpImageGather {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                    component,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        97u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageDrefGather(OpImageDrefGather {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                    d_ref,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        98u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageRead(OpImageRead {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        99u16 => split_fn!({
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (texel, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ImageWrite(OpImageWrite {
                    image,
                    coordinate,
                    texel,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        100u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Image(OpImage {
                    id_result_type,
                    id_result,
                    sampled_image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        101u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryFormat(OpImageQueryFormat {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        102u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryOrder(OpImageQueryOrder {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        103u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (level_of_detail, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQuerySizeLod(OpImageQuerySizeLod {
                    id_result_type,
                    id_result,
                    image,
                    level_of_detail,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        104u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQuerySize(OpImageQuerySize {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        105u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryLod(OpImageQueryLod {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        106u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQueryLevels(OpImageQueryLevels {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        107u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageQuerySamples(OpImageQuerySamples {
                    id_result_type,
                    id_result,
                    image,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        109u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertFToU(OpConvertFToU {
                    id_result_type,
                    id_result,
                    float_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        110u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertFToS(OpConvertFToS {
                    id_result_type,
                    id_result,
                    float_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        111u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertSToF(OpConvertSToF {
                    id_result_type,
                    id_result,
                    signed_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        112u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertUToF(OpConvertUToF {
                    id_result_type,
                    id_result,
                    unsigned_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        113u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UConvert(OpUConvert {
                    id_result_type,
                    id_result,
                    unsigned_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        114u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SConvert(OpSConvert {
                    id_result_type,
                    id_result,
                    signed_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        115u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FConvert(OpFConvert {
                    id_result_type,
                    id_result,
                    float_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        116u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::QuantizeToF16(OpQuantizeToF16 {
                    id_result_type,
                    id_result,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        117u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertPtrToU(OpConvertPtrToU {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        118u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SatConvertSToU(OpSatConvertSToU {
                    id_result_type,
                    id_result,
                    signed_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        119u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SatConvertUToS(OpSatConvertUToS {
                    id_result_type,
                    id_result,
                    unsigned_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        120u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (integer_value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConvertUToPtr(OpConvertUToPtr {
                    id_result_type,
                    id_result,
                    integer_value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        121u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrCastToGeneric(OpPtrCastToGeneric {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        122u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GenericCastToPtr(OpGenericCastToPtr {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        123u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (storage, words) = StorageClass::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GenericCastToPtrExplicit(
                    OpGenericCastToPtrExplicit {
                        id_result_type,
                        id_result,
                        pointer,
                        storage,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        124u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Bitcast(OpBitcast {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        126u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SNegate(OpSNegate {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        127u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FNegate(OpFNegate {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        128u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IAdd(OpIAdd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        129u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FAdd(OpFAdd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        130u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ISub(OpISub {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        131u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FSub(OpFSub {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        132u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IMul(OpIMul {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        133u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FMul(OpFMul {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        134u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UDiv(OpUDiv {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        135u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SDiv(OpSDiv {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        136u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FDiv(OpFDiv {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        137u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UMod(OpUMod {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        138u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SRem(OpSRem {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        139u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SMod(OpSMod {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        140u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FRem(OpFRem {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        141u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FMod(OpFMod {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        142u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (scalar, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorTimesScalar(OpVectorTimesScalar {
                    id_result_type,
                    id_result,
                    vector,
                    scalar,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        143u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            let (scalar, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::MatrixTimesScalar(OpMatrixTimesScalar {
                    id_result_type,
                    id_result,
                    matrix,
                    scalar,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        144u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::VectorTimesMatrix(OpVectorTimesMatrix {
                    id_result_type,
                    id_result,
                    vector,
                    matrix,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        145u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::MatrixTimesVector(OpMatrixTimesVector {
                    id_result_type,
                    id_result,
                    matrix,
                    vector,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        146u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (left_matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            let (right_matrix, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::MatrixTimesMatrix(OpMatrixTimesMatrix {
                    id_result_type,
                    id_result,
                    left_matrix,
                    right_matrix,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        147u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::OuterProduct(OpOuterProduct {
                    id_result_type,
                    id_result,
                    vector_1,
                    vector_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        148u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Dot(OpDot {
                    id_result_type,
                    id_result,
                    vector_1,
                    vector_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        149u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IAddCarry(OpIAddCarry {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        150u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ISubBorrow(OpISubBorrow {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        151u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UMulExtended(OpUMulExtended {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        152u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SMulExtended(OpSMulExtended {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        154u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Any(OpAny {
                    id_result_type,
                    id_result,
                    vector,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        155u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (vector, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::All(OpAll {
                    id_result_type,
                    id_result,
                    vector,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        156u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsNan(OpIsNan {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        157u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsInf(OpIsInf {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        158u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsFinite(OpIsFinite {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        159u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsNormal(OpIsNormal {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        160u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SignBitSet(OpSignBitSet {
                    id_result_type,
                    id_result,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        161u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            let (y, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LessOrGreater(OpLessOrGreater {
                    id_result_type,
                    id_result,
                    x,
                    y,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        162u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            let (y, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Ordered(OpOrdered {
                    id_result_type,
                    id_result,
                    x,
                    y,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        163u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            let (y, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Unordered(OpUnordered {
                    id_result_type,
                    id_result,
                    x,
                    y,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        164u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalEqual(OpLogicalEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        165u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalNotEqual(OpLogicalNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        166u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalOr(OpLogicalOr {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        167u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalAnd(OpLogicalAnd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        168u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::LogicalNot(OpLogicalNot {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        169u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (condition, words) = IdRef::spirv_parse(words, parse_state)?;
            let (object_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (object_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Select(OpSelect {
                    id_result_type,
                    id_result,
                    condition,
                    object_1,
                    object_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        170u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IEqual(OpIEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        171u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::INotEqual(OpINotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        172u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UGreaterThan(OpUGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        173u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SGreaterThan(OpSGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        174u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::UGreaterThanEqual(OpUGreaterThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        175u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SGreaterThanEqual(OpSGreaterThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        176u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ULessThan(OpULessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        177u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SLessThan(OpSLessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        178u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ULessThanEqual(OpULessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        179u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SLessThanEqual(OpSLessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        180u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdEqual(OpFOrdEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        181u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordEqual(OpFUnordEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        182u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdNotEqual(OpFOrdNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        183u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordNotEqual(OpFUnordNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        184u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdLessThan(OpFOrdLessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        185u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordLessThan(OpFUnordLessThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        186u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdGreaterThan(OpFOrdGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        187u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordGreaterThan(OpFUnordGreaterThan {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        188u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdLessThanEqual(OpFOrdLessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        189u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordLessThanEqual(OpFUnordLessThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        190u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FOrdGreaterThanEqual(OpFOrdGreaterThanEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        191u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FUnordGreaterThanEqual(
                    OpFUnordGreaterThanEqual {
                        id_result_type,
                        id_result,
                        operand_1,
                        operand_2,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        194u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ShiftRightLogical(OpShiftRightLogical {
                    id_result_type,
                    id_result,
                    base,
                    shift,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        195u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ShiftRightArithmetic(OpShiftRightArithmetic {
                    id_result_type,
                    id_result,
                    base,
                    shift,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        196u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ShiftLeftLogical(OpShiftLeftLogical {
                    id_result_type,
                    id_result,
                    base,
                    shift,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        197u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitwiseOr(OpBitwiseOr {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        198u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitwiseXor(OpBitwiseXor {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        199u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitwiseAnd(OpBitwiseAnd {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        200u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Not(OpNot {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        201u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (insert, words) = IdRef::spirv_parse(words, parse_state)?;
            let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
            let (count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitFieldInsert(OpBitFieldInsert {
                    id_result_type,
                    id_result,
                    base,
                    insert,
                    offset,
                    count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        202u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
            let (count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitFieldSExtract(OpBitFieldSExtract {
                    id_result_type,
                    id_result,
                    base,
                    offset,
                    count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        203u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            let (offset, words) = IdRef::spirv_parse(words, parse_state)?;
            let (count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitFieldUExtract(OpBitFieldUExtract {
                    id_result_type,
                    id_result,
                    base,
                    offset,
                    count,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        204u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitReverse(OpBitReverse {
                    id_result_type,
                    id_result,
                    base,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        205u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (base, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BitCount(OpBitCount {
                    id_result_type,
                    id_result,
                    base,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        207u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdx(OpDPdx {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        208u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdy(OpDPdy {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        209u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Fwidth(OpFwidth {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        210u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdxFine(OpDPdxFine {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        211u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdyFine(OpDPdyFine {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        212u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FwidthFine(OpFwidthFine {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        213u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdxCoarse(OpDPdxCoarse {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        214u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::DPdyCoarse(OpDPdyCoarse {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        215u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (p, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::FwidthCoarse(OpFwidthCoarse {
                    id_result_type,
                    id_result,
                    p,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        218u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::EmitVertex(OpEmitVertex {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        219u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::EndPrimitive(OpEndPrimitive {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        220u16 => split_fn!({
            let (stream, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::EmitStreamVertex(OpEmitStreamVertex { stream }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        221u16 => split_fn!({
            let (stream, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::EndStreamPrimitive(OpEndStreamPrimitive {
                    stream,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        224u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ControlBarrier(OpControlBarrier {
                    execution,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        225u16 => split_fn!({
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemoryBarrier(OpMemoryBarrier {
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        227u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicLoad(OpAtomicLoad {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        228u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::AtomicStore(OpAtomicStore {
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        229u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicExchange(OpAtomicExchange {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        230u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (equal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (unequal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (comparator, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicCompareExchange(
                    OpAtomicCompareExchange {
                        id_result_type,
                        id_result,
                        pointer,
                        memory,
                        equal,
                        unequal,
                        value,
                        comparator,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        231u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (equal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (unequal, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (comparator, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicCompareExchangeWeak(
                    OpAtomicCompareExchangeWeak {
                        id_result_type,
                        id_result,
                        pointer,
                        memory,
                        equal,
                        unequal,
                        value,
                        comparator,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        232u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicIIncrement(OpAtomicIIncrement {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        233u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicIDecrement(OpAtomicIDecrement {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        234u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicIAdd(OpAtomicIAdd {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        235u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicISub(OpAtomicISub {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        236u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicSMin(OpAtomicSMin {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        237u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicUMin(OpAtomicUMin {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        238u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicSMax(OpAtomicSMax {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        239u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicUMax(OpAtomicUMax {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        240u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicAnd(OpAtomicAnd {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        241u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicOr(OpAtomicOr {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        242u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicXor(OpAtomicXor {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                    value,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        245u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (variable_parent, words) = Vec::<PairIdRefIdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::Phi(OpPhi {
                    id_result_type,
                    id_result,
                    variable_parent,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        246u16 => split_fn!({
            let (merge_block, words) = IdRef::spirv_parse(words, parse_state)?;
            let (continue_target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (loop_control, words) = LoopControl::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::LoopMerge(OpLoopMerge {
                    merge_block,
                    continue_target,
                    loop_control,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        247u16 => split_fn!({
            let (merge_block, words) = IdRef::spirv_parse(words, parse_state)?;
            let (selection_control, words) = SelectionControl::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SelectionMerge(OpSelectionMerge {
                    merge_block,
                    selection_control,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        248u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Label(OpLabel { id_result }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        249u16 => split_fn!({
            let (target_label, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::Branch(OpBranch { target_label }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        250u16 => split_fn!({
            let (condition, words) = IdRef::spirv_parse(words, parse_state)?;
            let (true_label, words) = IdRef::spirv_parse(words, parse_state)?;
            let (false_label, words) = IdRef::spirv_parse(words, parse_state)?;
            let (branch_weights, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::BranchConditional(OpBranchConditional {
                    condition,
                    true_label,
                    false_label,
                    branch_weights,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        251u16 => split_fn!({
            let (selector, words) = IdRef::spirv_parse(words, parse_state)?;
            let (default, words) = IdRef::spirv_parse(words, parse_state)?;
            match &parse_state.id_states[selector.0 as usize] {
                IdState::Value(IdStateValue(BitWidth::Width32OrLess)) => {
                    let (target, words) =
                        Vec::<PairLiteralInteger32IdRef>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Switch32(OpSwitch32 {
                            selector,
                            default,
                            target,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                IdState::Value(IdStateValue(BitWidth::Width64)) => {
                    let (target, words) =
                        Vec::<PairLiteralInteger64IdRef>::spirv_parse(words, parse_state)?;
                    if words.is_empty() {
                        Ok(Instruction::Switch64(OpSwitch64 {
                            selector,
                            default,
                            target,
                        }))
                    } else {
                        Err(Error::InstructionTooLong)
                    }
                }
                _ => Err(Error::SwitchSelectorIsInvalid(selector)),
            }
        }),
        252u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Kill(OpKill {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        253u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Return(OpReturn {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        254u16 => split_fn!({
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ReturnValue(OpReturnValue { value }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        255u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::Unreachable(OpUnreachable {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        256u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::LifetimeStart(OpLifetimeStart {
                    pointer,
                    size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        257u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::LifetimeStop(OpLifetimeStop { pointer, size }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        259u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (destination, words) = IdRef::spirv_parse(words, parse_state)?;
            let (source, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_elements, words) = IdRef::spirv_parse(words, parse_state)?;
            let (stride, words) = IdRef::spirv_parse(words, parse_state)?;
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupAsyncCopy(OpGroupAsyncCopy {
                    id_result_type,
                    id_result,
                    execution,
                    destination,
                    source,
                    num_elements,
                    stride,
                    event,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        260u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (num_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (events_list, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupWaitEvents(OpGroupWaitEvents {
                    execution,
                    num_events,
                    events_list,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        261u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupAll(OpGroupAll {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        262u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupAny(OpGroupAny {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        263u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (local_id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupBroadcast(OpGroupBroadcast {
                    id_result_type,
                    id_result,
                    execution,
                    value,
                    local_id,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        264u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupIAdd(OpGroupIAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        265u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupFAdd(OpGroupFAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        266u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupFMin(OpGroupFMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        267u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupUMin(OpGroupUMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        268u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupSMin(OpGroupSMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        269u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupFMax(OpGroupFMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        270u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupUMax(OpGroupUMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        271u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (x, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupSMax(OpGroupSMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    x,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        274u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReadPipe(OpReadPipe {
                    id_result_type,
                    id_result,
                    pipe,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        275u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::WritePipe(OpWritePipe {
                    id_result_type,
                    id_result,
                    pipe,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        276u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReservedReadPipe(OpReservedReadPipe {
                    id_result_type,
                    id_result,
                    pipe,
                    reserve_id,
                    index,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        277u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReservedWritePipe(OpReservedWritePipe {
                    id_result_type,
                    id_result,
                    pipe,
                    reserve_id,
                    index,
                    pointer,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        278u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReserveReadPipePackets(
                    OpReserveReadPipePackets {
                        id_result_type,
                        id_result,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        279u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ReserveWritePipePackets(
                    OpReserveWritePipePackets {
                        id_result_type,
                        id_result,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        280u16 => split_fn!({
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CommitReadPipe(OpCommitReadPipe {
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        281u16 => split_fn!({
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CommitWritePipe(OpCommitWritePipe {
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        282u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsValidReserveId(OpIsValidReserveId {
                    id_result_type,
                    id_result,
                    reserve_id,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        283u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetNumPipePackets(OpGetNumPipePackets {
                    id_result_type,
                    id_result,
                    pipe,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        284u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetMaxPipePackets(OpGetMaxPipePackets {
                    id_result_type,
                    id_result,
                    pipe,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        285u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupReserveReadPipePackets(
                    OpGroupReserveReadPipePackets {
                        id_result_type,
                        id_result,
                        execution,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        286u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_packets, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupReserveWritePipePackets(
                    OpGroupReserveWritePipePackets {
                        id_result_type,
                        id_result,
                        execution,
                        pipe,
                        num_packets,
                        packet_size,
                        packet_alignment,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        287u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupCommitReadPipe(OpGroupCommitReadPipe {
                    execution,
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        288u16 => split_fn!({
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (pipe, words) = IdRef::spirv_parse(words, parse_state)?;
            let (reserve_id, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::GroupCommitWritePipe(OpGroupCommitWritePipe {
                    execution,
                    pipe,
                    reserve_id,
                    packet_size,
                    packet_alignment,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        291u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (queue, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (wait_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (ret_event, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::EnqueueMarker(OpEnqueueMarker {
                    id_result_type,
                    id_result,
                    queue,
                    num_events,
                    wait_events,
                    ret_event,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        292u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (queue, words) = IdRef::spirv_parse(words, parse_state)?;
            let (flags, words) = IdRef::spirv_parse(words, parse_state)?;
            let (nd_range, words) = IdRef::spirv_parse(words, parse_state)?;
            let (num_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (wait_events, words) = IdRef::spirv_parse(words, parse_state)?;
            let (ret_event, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            let (local_size, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::EnqueueKernel(OpEnqueueKernel {
                    id_result_type,
                    id_result,
                    queue,
                    flags,
                    nd_range,
                    num_events,
                    wait_events,
                    ret_event,
                    invoke,
                    param,
                    param_size,
                    param_align,
                    local_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        293u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (nd_range, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelNDrangeSubGroupCount(
                    OpGetKernelNDrangeSubGroupCount {
                        id_result_type,
                        id_result,
                        nd_range,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        294u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (nd_range, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelNDrangeMaxSubGroupSize(
                    OpGetKernelNDrangeMaxSubGroupSize {
                        id_result_type,
                        id_result,
                        nd_range,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        295u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelWorkGroupSize(
                    OpGetKernelWorkGroupSize {
                        id_result_type,
                        id_result,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        296u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelPreferredWorkGroupSizeMultiple(
                    OpGetKernelPreferredWorkGroupSizeMultiple {
                        id_result_type,
                        id_result,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        297u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::RetainEvent(OpRetainEvent { event }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        298u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ReleaseEvent(OpReleaseEvent { event }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        299u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CreateUserEvent(OpCreateUserEvent {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        300u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::IsValidEvent(OpIsValidEvent {
                    id_result_type,
                    id_result,
                    event,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        301u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            let (status, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::SetUserEventStatus(OpSetUserEventStatus {
                    event,
                    status,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        302u16 => split_fn!({
            let (event, words) = IdRef::spirv_parse(words, parse_state)?;
            let (profiling_info, words) = IdRef::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::CaptureEventProfilingInfo(
                    OpCaptureEventProfilingInfo {
                        event,
                        profiling_info,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        303u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetDefaultQueue(OpGetDefaultQueue {
                    id_result_type,
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        304u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (global_work_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (local_work_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (global_work_offset, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::BuildNDRange(OpBuildNDRange {
                    id_result_type,
                    id_result,
                    global_work_size,
                    local_work_size,
                    global_work_offset,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        305u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleImplicitLod(
                    OpImageSparseSampleImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        306u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleExplicitLod(
                    OpImageSparseSampleExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        307u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleDrefImplicitLod(
                    OpImageSparseSampleDrefImplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        308u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = ImageOperands::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseSampleDrefExplicitLod(
                    OpImageSparseSampleDrefExplicitLod {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        313u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseFetch(OpImageSparseFetch {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        314u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (component, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseGather(OpImageSparseGather {
                    id_result_type,
                    id_result,
                    sampled_image,
                    coordinate,
                    component,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        315u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (sampled_image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (d_ref, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseDrefGather(
                    OpImageSparseDrefGather {
                        id_result_type,
                        id_result,
                        sampled_image,
                        coordinate,
                        d_ref,
                        image_operands,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        316u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (resident_code, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseTexelsResident(
                    OpImageSparseTexelsResident {
                        id_result_type,
                        id_result,
                        resident_code,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        317u16 => split_fn!({
            if words.is_empty() {
                Ok(Instruction::NoLine(OpNoLine {}))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        318u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::AtomicFlagTestAndSet(OpAtomicFlagTestAndSet {
                    id_result_type,
                    id_result,
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        319u16 => split_fn!({
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::AtomicFlagClear(OpAtomicFlagClear {
                    pointer,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        320u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (image, words) = IdRef::spirv_parse(words, parse_state)?;
            let (coordinate, words) = IdRef::spirv_parse(words, parse_state)?;
            let (image_operands, words) = Option::<ImageOperands>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ImageSparseRead(OpImageSparseRead {
                    id_result_type,
                    id_result,
                    image,
                    coordinate,
                    image_operands,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        321u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::SizeOf(OpSizeOf {
                    id_result_type,
                    id_result,
                    pointer,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        322u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypePipeStorage(OpTypePipeStorage {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        323u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (packet_size, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (packet_alignment, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (capacity, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::ConstantPipeStorage(OpConstantPipeStorage {
                    id_result_type,
                    id_result,
                    packet_size,
                    packet_alignment,
                    capacity,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        324u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (pipe_storage, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CreatePipeFromPipeStorage(
                    OpCreatePipeFromPipeStorage {
                        id_result_type,
                        id_result,
                        pipe_storage,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        325u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (subgroup_count, words) = IdRef::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelLocalSizeForSubgroupCount(
                    OpGetKernelLocalSizeForSubgroupCount {
                        id_result_type,
                        id_result,
                        subgroup_count,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        326u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (invoke, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_size, words) = IdRef::spirv_parse(words, parse_state)?;
            let (param_align, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GetKernelMaxNumSubgroups(
                    OpGetKernelMaxNumSubgroups {
                        id_result_type,
                        id_result,
                        invoke,
                        param,
                        param_size,
                        param_align,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        327u16 => split_fn!({
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::TypeNamedBarrier(OpTypeNamedBarrier {
                    id_result,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        328u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (subgroup_count, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::NamedBarrierInitialize(
                    OpNamedBarrierInitialize {
                        id_result_type,
                        id_result,
                        subgroup_count,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        329u16 => split_fn!({
            let (named_barrier, words) = IdRef::spirv_parse(words, parse_state)?;
            let (memory, words) = IdScope::spirv_parse(words, parse_state)?;
            let (semantics, words) = IdMemorySemantics::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemoryNamedBarrier(OpMemoryNamedBarrier {
                    named_barrier,
                    memory,
                    semantics,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        330u16 => split_fn!({
            let (process, words) = LiteralString::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ModuleProcessed(OpModuleProcessed { process }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        331u16 => split_fn!({
            let (entry_point, words) = IdRef::spirv_parse(words, parse_state)?;
            let (mode, words) = ExecutionMode::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::ExecutionModeId(OpExecutionModeId {
                    entry_point,
                    mode,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        332u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::DecorateId(OpDecorateId { target, decoration }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        333u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformElect(OpGroupNonUniformElect {
                    id_result_type,
                    id_result,
                    execution,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        334u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformAll(OpGroupNonUniformAll {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        335u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformAny(OpGroupNonUniformAny {
                    id_result_type,
                    id_result,
                    execution,
                    predicate,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        336u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformAllEqual(
                    OpGroupNonUniformAllEqual {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        337u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBroadcast(
                    OpGroupNonUniformBroadcast {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        id,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        338u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBroadcastFirst(
                    OpGroupNonUniformBroadcastFirst {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        339u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (predicate, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallot(
                    OpGroupNonUniformBallot {
                        id_result_type,
                        id_result,
                        execution,
                        predicate,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        340u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformInverseBallot(
                    OpGroupNonUniformInverseBallot {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        341u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotBitExtract(
                    OpGroupNonUniformBallotBitExtract {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        index,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        342u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotBitCount(
                    OpGroupNonUniformBallotBitCount {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        343u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotFindLSB(
                    OpGroupNonUniformBallotFindLSB {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        344u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBallotFindMSB(
                    OpGroupNonUniformBallotFindMSB {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        345u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (id, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffle(
                    OpGroupNonUniformShuffle {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        id,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        346u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (mask, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffleXor(
                    OpGroupNonUniformShuffleXor {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        mask,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        347u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (delta, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffleUp(
                    OpGroupNonUniformShuffleUp {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        delta,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        348u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (delta, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformShuffleDown(
                    OpGroupNonUniformShuffleDown {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        delta,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        349u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformIAdd(OpGroupNonUniformIAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        350u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFAdd(OpGroupNonUniformFAdd {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        351u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformIMul(OpGroupNonUniformIMul {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        352u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFMul(OpGroupNonUniformFMul {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        353u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformSMin(OpGroupNonUniformSMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        354u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformUMin(OpGroupNonUniformUMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        355u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFMin(OpGroupNonUniformFMin {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        356u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformSMax(OpGroupNonUniformSMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        357u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformUMax(OpGroupNonUniformUMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        358u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformFMax(OpGroupNonUniformFMax {
                    id_result_type,
                    id_result,
                    execution,
                    operation,
                    value,
                    cluster_size,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        359u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBitwiseAnd(
                    OpGroupNonUniformBitwiseAnd {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        360u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBitwiseOr(
                    OpGroupNonUniformBitwiseOr {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        361u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformBitwiseXor(
                    OpGroupNonUniformBitwiseXor {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        362u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformLogicalAnd(
                    OpGroupNonUniformLogicalAnd {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        363u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformLogicalOr(
                    OpGroupNonUniformLogicalOr {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        364u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (operation, words) = GroupOperation::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (cluster_size, words) = Option::<IdRef>::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformLogicalXor(
                    OpGroupNonUniformLogicalXor {
                        id_result_type,
                        id_result,
                        execution,
                        operation,
                        value,
                        cluster_size,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        365u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (index, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformQuadBroadcast(
                    OpGroupNonUniformQuadBroadcast {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        index,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        366u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (execution, words) = IdScope::spirv_parse(words, parse_state)?;
            let (value, words) = IdRef::spirv_parse(words, parse_state)?;
            let (direction, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::GroupNonUniformQuadSwap(
                    OpGroupNonUniformQuadSwap {
                        id_result_type,
                        id_result,
                        execution,
                        value,
                        direction,
                    },
                ))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        400u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::CopyLogical(OpCopyLogical {
                    id_result_type,
                    id_result,
                    operand,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        401u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrEqual(OpPtrEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        402u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrNotEqual(OpPtrNotEqual {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        403u16 => split_fn!({
            let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
            let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
            let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
            let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
            parse_state.define_value(id_result_type, id_result)?;
            if words.is_empty() {
                Ok(Instruction::PtrDiff(OpPtrDiff {
                    id_result_type,
                    id_result,
                    operand_1,
                    operand_2,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        5632u16 => split_fn!({
            let (target, words) = IdRef::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::DecorateString(OpDecorateString {
                    target,
                    decoration,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        5633u16 => split_fn!({
            let (struct_type, words) = IdRef::spirv_parse(words, parse_state)?;
            let (member, words) = LiteralInteger32::spirv_parse(words, parse_state)?;
            let (decoration, words) = Decoration::spirv_parse(words, parse_state)?;
            if words.is_empty() {
                Ok(Instruction::MemberDecorateString(OpMemberDecorateString {
                    struct_type,
                    member,
                    decoration,
                }))
            } else {
                Err(Error::InstructionTooLong)
            }
        }),
        opcode => Err(Error::UnknownOpcode(opcode)),
    }
}
impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Instruction::Nop(OpNop {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpNop")?;
                writeln!(f)
            }),
            Instruction::Undef(OpUndef {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUndef"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SourceContinued(OpSourceContinued { continued_source }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSourceContinued"
                )?;
                continued_source.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Source(OpSource {
                source_language,
                version,
                file,
                source,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpSource")?;
                source_language.spirv_display(f)?;
                version.spirv_display(f)?;
                file.spirv_display(f)?;
                source.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SourceExtension(OpSourceExtension { extension }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSourceExtension"
                )?;
                extension.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Name(OpName { target, name }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpName")?;
                target.spirv_display(f)?;
                name.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemberName(OpMemberName {
                type_,
                member,
                name,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpMemberName")?;
                type_.spirv_display(f)?;
                member.spirv_display(f)?;
                name.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::String(OpString { id_result, string }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpString"
                )?;
                string.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Line(OpLine { file, line, column }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpLine")?;
                file.spirv_display(f)?;
                line.spirv_display(f)?;
                column.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Extension(OpExtension { name }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpExtension")?;
                name.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ExtInstImport(OpExtInstImport { id_result, name }) => split_fn!({
                writeln!(
                    f,
                    "{}{} {:?}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpExtInstImport",
                    name
                )
            }),
            Instruction::ExtInst(OpExtInst {
                id_result_type,
                id_result,
                set,
                instruction,
                operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpExtInst"
                )?;
                id_result_type.spirv_display(f)?;
                set.spirv_display(f)?;
                instruction.spirv_display(f)?;
                operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemoryModel(OpMemoryModel {
                addressing_model,
                memory_model,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpMemoryModel")?;
                addressing_model.spirv_display(f)?;
                memory_model.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EntryPoint(OpEntryPoint {
                execution_model,
                entry_point,
                name,
                interface,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpEntryPoint")?;
                execution_model.spirv_display(f)?;
                entry_point.spirv_display(f)?;
                name.spirv_display(f)?;
                interface.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ExecutionMode(OpExecutionMode { entry_point, mode }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpExecutionMode"
                )?;
                entry_point.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Capability(OpCapability { capability }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpCapability")?;
                capability.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeVoid(OpTypeVoid { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeVoid"
                )?;
                writeln!(f)
            }),
            Instruction::TypeBool(OpTypeBool { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeBool"
                )?;
                writeln!(f)
            }),
            Instruction::TypeInt(OpTypeInt {
                id_result,
                width,
                signedness,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeInt"
                )?;
                width.spirv_display(f)?;
                signedness.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeFloat(OpTypeFloat { id_result, width }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeFloat"
                )?;
                width.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeVector(OpTypeVector {
                id_result,
                component_type,
                component_count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeVector"
                )?;
                component_type.spirv_display(f)?;
                component_count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeMatrix(OpTypeMatrix {
                id_result,
                column_type,
                column_count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeMatrix"
                )?;
                column_type.spirv_display(f)?;
                column_count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeImage(OpTypeImage {
                id_result,
                sampled_type,
                dim,
                depth,
                arrayed,
                ms,
                sampled,
                image_format,
                access_qualifier,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeImage"
                )?;
                sampled_type.spirv_display(f)?;
                dim.spirv_display(f)?;
                depth.spirv_display(f)?;
                arrayed.spirv_display(f)?;
                ms.spirv_display(f)?;
                sampled.spirv_display(f)?;
                image_format.spirv_display(f)?;
                access_qualifier.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeSampler(OpTypeSampler { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeSampler"
                )?;
                writeln!(f)
            }),
            Instruction::TypeSampledImage(OpTypeSampledImage {
                id_result,
                image_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeSampledImage"
                )?;
                image_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeArray(OpTypeArray {
                id_result,
                element_type,
                length,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeArray"
                )?;
                element_type.spirv_display(f)?;
                length.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeRuntimeArray(OpTypeRuntimeArray {
                id_result,
                element_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeRuntimeArray"
                )?;
                element_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeStruct(OpTypeStruct {
                id_result,
                member_types,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeStruct"
                )?;
                member_types.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeOpaque(OpTypeOpaque {
                id_result,
                the_name_of_the_opaque_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeOpaque"
                )?;
                the_name_of_the_opaque_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypePointer(OpTypePointer {
                id_result,
                storage_class,
                type_,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypePointer"
                )?;
                storage_class.spirv_display(f)?;
                type_.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeFunction(OpTypeFunction {
                id_result,
                return_type,
                parameter_types,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeFunction"
                )?;
                return_type.spirv_display(f)?;
                parameter_types.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeEvent(OpTypeEvent { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeEvent"
                )?;
                writeln!(f)
            }),
            Instruction::TypeDeviceEvent(OpTypeDeviceEvent { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeDeviceEvent"
                )?;
                writeln!(f)
            }),
            Instruction::TypeReserveId(OpTypeReserveId { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeReserveId"
                )?;
                writeln!(f)
            }),
            Instruction::TypeQueue(OpTypeQueue { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeQueue"
                )?;
                writeln!(f)
            }),
            Instruction::TypePipe(OpTypePipe {
                id_result,
                qualifier,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypePipe"
                )?;
                qualifier.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeForwardPointer(OpTypeForwardPointer {
                pointer_type,
                storage_class,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpTypeForwardPointer"
                )?;
                pointer_type.spirv_display(f)?;
                storage_class.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantTrue(OpConstantTrue {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantTrue"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantFalse(OpConstantFalse {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantFalse"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Constant32(OpConstant32 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#010X}", value)
            }),
            Instruction::Constant64(OpConstant64 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#018X}", value)
            }),
            Instruction::ConstantComposite(OpConstantComposite {
                id_result_type,
                id_result,
                constituents,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantComposite"
                )?;
                id_result_type.spirv_display(f)?;
                constituents.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantSampler(OpConstantSampler {
                id_result_type,
                id_result,
                sampler_addressing_mode,
                param,
                sampler_filter_mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantSampler"
                )?;
                id_result_type.spirv_display(f)?;
                sampler_addressing_mode.spirv_display(f)?;
                param.spirv_display(f)?;
                sampler_filter_mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConstantNull(OpConstantNull {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantNull"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstantTrue(OpSpecConstantTrue {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantTrue"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstantFalse(OpSpecConstantFalse {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantFalse"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstant32(OpSpecConstant32 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#010X}", value)
            }),
            Instruction::SpecConstant64(OpSpecConstant64 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstant"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f, " {:#018X}", value)
            }),
            Instruction::SpecConstantComposite(OpSpecConstantComposite {
                id_result_type,
                id_result,
                constituents,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSpecConstantComposite"
                )?;
                id_result_type.spirv_display(f)?;
                constituents.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SpecConstantOp(operation) => fmt::Display::fmt(operation, f),
            Instruction::Function(OpFunction {
                id_result_type,
                id_result,
                function_control,
                function_type,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFunction"
                )?;
                id_result_type.spirv_display(f)?;
                function_control.spirv_display(f)?;
                function_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FunctionParameter(OpFunctionParameter {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFunctionParameter"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FunctionEnd(OpFunctionEnd {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpFunctionEnd")?;
                writeln!(f)
            }),
            Instruction::FunctionCall(OpFunctionCall {
                id_result_type,
                id_result,
                function,
                arguments,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFunctionCall"
                )?;
                id_result_type.spirv_display(f)?;
                function.spirv_display(f)?;
                arguments.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Variable(OpVariable {
                id_result_type,
                id_result,
                storage_class,
                initializer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVariable"
                )?;
                id_result_type.spirv_display(f)?;
                storage_class.spirv_display(f)?;
                initializer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageTexelPointer(OpImageTexelPointer {
                id_result_type,
                id_result,
                image,
                coordinate,
                sample,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageTexelPointer"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                sample.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Load(OpLoad {
                id_result_type,
                id_result,
                pointer,
                memory_access,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLoad"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Store(OpStore {
                pointer,
                object,
                memory_access,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpStore")?;
                pointer.spirv_display(f)?;
                object.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyMemory(OpCopyMemory {
                target,
                source,
                memory_access,
                source_memory_access,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpCopyMemory")?;
                target.spirv_display(f)?;
                source.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                source_memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyMemorySized(OpCopyMemorySized {
                target,
                source,
                size,
                memory_access,
                source_memory_access,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCopyMemorySized"
                )?;
                target.spirv_display(f)?;
                source.spirv_display(f)?;
                size.spirv_display(f)?;
                memory_access.spirv_display(f)?;
                source_memory_access.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AccessChain(OpAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::InBoundsAccessChain(OpInBoundsAccessChain {
                id_result_type,
                id_result,
                base,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpInBoundsAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrAccessChain(OpPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ArrayLength(OpArrayLength {
                id_result_type,
                id_result,
                structure,
                array_member,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpArrayLength"
                )?;
                id_result_type.spirv_display(f)?;
                structure.spirv_display(f)?;
                array_member.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GenericPtrMemSemantics(OpGenericPtrMemSemantics {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGenericPtrMemSemantics"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::InBoundsPtrAccessChain(OpInBoundsPtrAccessChain {
                id_result_type,
                id_result,
                base,
                element,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpInBoundsPtrAccessChain"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                element.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Decorate(OpDecorate { target, decoration }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpDecorate")?;
                target.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemberDecorate(OpMemberDecorate {
                structure_type,
                member,
                decoration,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemberDecorate"
                )?;
                structure_type.spirv_display(f)?;
                member.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DecorationGroup(OpDecorationGroup { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDecorationGroup"
                )?;
                writeln!(f)
            }),
            Instruction::GroupDecorate(OpGroupDecorate {
                decoration_group,
                targets,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupDecorate"
                )?;
                decoration_group.spirv_display(f)?;
                targets.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupMemberDecorate(OpGroupMemberDecorate {
                decoration_group,
                targets,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupMemberDecorate"
                )?;
                decoration_group.spirv_display(f)?;
                targets.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorExtractDynamic(OpVectorExtractDynamic {
                id_result_type,
                id_result,
                vector,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorExtractDynamic"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorInsertDynamic(OpVectorInsertDynamic {
                id_result_type,
                id_result,
                vector,
                component,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorInsertDynamic"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                component.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorShuffle(OpVectorShuffle {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
                components,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorShuffle"
                )?;
                id_result_type.spirv_display(f)?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                components.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CompositeConstruct(OpCompositeConstruct {
                id_result_type,
                id_result,
                constituents,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCompositeConstruct"
                )?;
                id_result_type.spirv_display(f)?;
                constituents.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CompositeExtract(OpCompositeExtract {
                id_result_type,
                id_result,
                composite,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCompositeExtract"
                )?;
                id_result_type.spirv_display(f)?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CompositeInsert(OpCompositeInsert {
                id_result_type,
                id_result,
                object,
                composite,
                indexes,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCompositeInsert"
                )?;
                id_result_type.spirv_display(f)?;
                object.spirv_display(f)?;
                composite.spirv_display(f)?;
                indexes.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyObject(OpCopyObject {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCopyObject"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Transpose(OpTranspose {
                id_result_type,
                id_result,
                matrix,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTranspose"
                )?;
                id_result_type.spirv_display(f)?;
                matrix.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SampledImage(OpSampledImage {
                id_result_type,
                id_result,
                image,
                sampler,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSampledImage"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                sampler.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleImplicitLod(OpImageSampleImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleExplicitLod(OpImageSampleExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleDrefImplicitLod(OpImageSampleDrefImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleDrefImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleDrefExplicitLod(OpImageSampleDrefExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleDrefExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjImplicitLod(OpImageSampleProjImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjExplicitLod(OpImageSampleProjExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjDrefImplicitLod(OpImageSampleProjDrefImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjDrefImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSampleProjDrefExplicitLod(OpImageSampleProjDrefExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSampleProjDrefExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageFetch(OpImageFetch {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageFetch"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageGather(OpImageGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                component,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                component.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageDrefGather(OpImageDrefGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageDrefGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageRead(OpImageRead {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageRead"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageWrite(OpImageWrite {
                image,
                coordinate,
                texel,
                image_operands,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpImageWrite")?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                texel.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Image(OpImage {
                id_result_type,
                id_result,
                sampled_image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImage"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryFormat(OpImageQueryFormat {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryFormat"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryOrder(OpImageQueryOrder {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryOrder"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQuerySizeLod(OpImageQuerySizeLod {
                id_result_type,
                id_result,
                image,
                level_of_detail,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQuerySizeLod"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                level_of_detail.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQuerySize(OpImageQuerySize {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQuerySize"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryLod(OpImageQueryLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQueryLevels(OpImageQueryLevels {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQueryLevels"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageQuerySamples(OpImageQuerySamples {
                id_result_type,
                id_result,
                image,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageQuerySamples"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertFToU(OpConvertFToU {
                id_result_type,
                id_result,
                float_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertFToU"
                )?;
                id_result_type.spirv_display(f)?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertFToS(OpConvertFToS {
                id_result_type,
                id_result,
                float_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertFToS"
                )?;
                id_result_type.spirv_display(f)?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertSToF(OpConvertSToF {
                id_result_type,
                id_result,
                signed_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertSToF"
                )?;
                id_result_type.spirv_display(f)?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertUToF(OpConvertUToF {
                id_result_type,
                id_result,
                unsigned_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertUToF"
                )?;
                id_result_type.spirv_display(f)?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UConvert(OpUConvert {
                id_result_type,
                id_result,
                unsigned_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUConvert"
                )?;
                id_result_type.spirv_display(f)?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SConvert(OpSConvert {
                id_result_type,
                id_result,
                signed_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSConvert"
                )?;
                id_result_type.spirv_display(f)?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FConvert(OpFConvert {
                id_result_type,
                id_result,
                float_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFConvert"
                )?;
                id_result_type.spirv_display(f)?;
                float_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::QuantizeToF16(OpQuantizeToF16 {
                id_result_type,
                id_result,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpQuantizeToF16"
                )?;
                id_result_type.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertPtrToU(OpConvertPtrToU {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertPtrToU"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SatConvertSToU(OpSatConvertSToU {
                id_result_type,
                id_result,
                signed_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSatConvertSToU"
                )?;
                id_result_type.spirv_display(f)?;
                signed_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SatConvertUToS(OpSatConvertUToS {
                id_result_type,
                id_result,
                unsigned_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSatConvertUToS"
                )?;
                id_result_type.spirv_display(f)?;
                unsigned_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ConvertUToPtr(OpConvertUToPtr {
                id_result_type,
                id_result,
                integer_value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConvertUToPtr"
                )?;
                id_result_type.spirv_display(f)?;
                integer_value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrCastToGeneric(OpPtrCastToGeneric {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrCastToGeneric"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GenericCastToPtr(OpGenericCastToPtr {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGenericCastToPtr"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GenericCastToPtrExplicit(OpGenericCastToPtrExplicit {
                id_result_type,
                id_result,
                pointer,
                storage,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGenericCastToPtrExplicit"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                storage.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Bitcast(OpBitcast {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitcast"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SNegate(OpSNegate {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSNegate"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FNegate(OpFNegate {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFNegate"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IAdd(OpIAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FAdd(OpFAdd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFAdd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ISub(OpISub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpISub"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FSub(OpFSub {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFSub"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IMul(OpIMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIMul"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FMul(OpFMul {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFMul"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UDiv(OpUDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUDiv"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SDiv(OpSDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSDiv"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FDiv(OpFDiv {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFDiv"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UMod(OpUMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUMod"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SRem(OpSRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSRem"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SMod(OpSMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSMod"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FRem(OpFRem {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFRem"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FMod(OpFMod {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFMod"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorTimesScalar(OpVectorTimesScalar {
                id_result_type,
                id_result,
                vector,
                scalar,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorTimesScalar"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                scalar.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MatrixTimesScalar(OpMatrixTimesScalar {
                id_result_type,
                id_result,
                matrix,
                scalar,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpMatrixTimesScalar"
                )?;
                id_result_type.spirv_display(f)?;
                matrix.spirv_display(f)?;
                scalar.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::VectorTimesMatrix(OpVectorTimesMatrix {
                id_result_type,
                id_result,
                vector,
                matrix,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpVectorTimesMatrix"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                matrix.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MatrixTimesVector(OpMatrixTimesVector {
                id_result_type,
                id_result,
                matrix,
                vector,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpMatrixTimesVector"
                )?;
                id_result_type.spirv_display(f)?;
                matrix.spirv_display(f)?;
                vector.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MatrixTimesMatrix(OpMatrixTimesMatrix {
                id_result_type,
                id_result,
                left_matrix,
                right_matrix,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpMatrixTimesMatrix"
                )?;
                id_result_type.spirv_display(f)?;
                left_matrix.spirv_display(f)?;
                right_matrix.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OuterProduct(OpOuterProduct {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpOuterProduct"
                )?;
                id_result_type.spirv_display(f)?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Dot(OpDot {
                id_result_type,
                id_result,
                vector_1,
                vector_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDot"
                )?;
                id_result_type.spirv_display(f)?;
                vector_1.spirv_display(f)?;
                vector_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IAddCarry(OpIAddCarry {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIAddCarry"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ISubBorrow(OpISubBorrow {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpISubBorrow"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UMulExtended(OpUMulExtended {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUMulExtended"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SMulExtended(OpSMulExtended {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSMulExtended"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Any(OpAny {
                id_result_type,
                id_result,
                vector,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAny"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::All(OpAll {
                id_result_type,
                id_result,
                vector,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAll"
                )?;
                id_result_type.spirv_display(f)?;
                vector.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsNan(OpIsNan {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsNan"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsInf(OpIsInf {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsInf"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsFinite(OpIsFinite {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsFinite"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsNormal(OpIsNormal {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsNormal"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SignBitSet(OpSignBitSet {
                id_result_type,
                id_result,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSignBitSet"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LessOrGreater(OpLessOrGreater {
                id_result_type,
                id_result,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLessOrGreater"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Ordered(OpOrdered {
                id_result_type,
                id_result,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpOrdered"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Unordered(OpUnordered {
                id_result_type,
                id_result,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUnordered"
                )?;
                id_result_type.spirv_display(f)?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalEqual(OpLogicalEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalNotEqual(OpLogicalNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalOr(OpLogicalOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalOr"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalAnd(OpLogicalAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalAnd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LogicalNot(OpLogicalNot {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLogicalNot"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Select(OpSelect {
                id_result_type,
                id_result,
                condition,
                object_1,
                object_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSelect"
                )?;
                id_result_type.spirv_display(f)?;
                condition.spirv_display(f)?;
                object_1.spirv_display(f)?;
                object_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IEqual(OpIEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::INotEqual(OpINotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpINotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UGreaterThan(OpUGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SGreaterThan(OpSGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::UGreaterThanEqual(OpUGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpUGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SGreaterThanEqual(OpSGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ULessThan(OpULessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpULessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SLessThan(OpSLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSLessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ULessThanEqual(OpULessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpULessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SLessThanEqual(OpSLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSLessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdEqual(OpFOrdEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordEqual(OpFUnordEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdNotEqual(OpFOrdNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordNotEqual(OpFUnordNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdLessThan(OpFOrdLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdLessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordLessThan(OpFUnordLessThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordLessThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdGreaterThan(OpFOrdGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordGreaterThan(OpFUnordGreaterThan {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordGreaterThan"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdLessThanEqual(OpFOrdLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdLessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordLessThanEqual(OpFUnordLessThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordLessThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FOrdGreaterThanEqual(OpFOrdGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFOrdGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FUnordGreaterThanEqual(OpFUnordGreaterThanEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFUnordGreaterThanEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ShiftRightLogical(OpShiftRightLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpShiftRightLogical"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ShiftRightArithmetic(OpShiftRightArithmetic {
                id_result_type,
                id_result,
                base,
                shift,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpShiftRightArithmetic"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ShiftLeftLogical(OpShiftLeftLogical {
                id_result_type,
                id_result,
                base,
                shift,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpShiftLeftLogical"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                shift.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitwiseOr(OpBitwiseOr {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitwiseOr"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitwiseXor(OpBitwiseXor {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitwiseXor"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitwiseAnd(OpBitwiseAnd {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitwiseAnd"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Not(OpNot {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpNot"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitFieldInsert(OpBitFieldInsert {
                id_result_type,
                id_result,
                base,
                insert,
                offset,
                count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitFieldInsert"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                insert.spirv_display(f)?;
                offset.spirv_display(f)?;
                count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitFieldSExtract(OpBitFieldSExtract {
                id_result_type,
                id_result,
                base,
                offset,
                count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitFieldSExtract"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                offset.spirv_display(f)?;
                count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitFieldUExtract(OpBitFieldUExtract {
                id_result_type,
                id_result,
                base,
                offset,
                count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitFieldUExtract"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                offset.spirv_display(f)?;
                count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitReverse(OpBitReverse {
                id_result_type,
                id_result,
                base,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitReverse"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BitCount(OpBitCount {
                id_result_type,
                id_result,
                base,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBitCount"
                )?;
                id_result_type.spirv_display(f)?;
                base.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdx(OpDPdx {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdx"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdy(OpDPdy {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdy"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Fwidth(OpFwidth {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFwidth"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdxFine(OpDPdxFine {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdxFine"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdyFine(OpDPdyFine {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdyFine"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FwidthFine(OpFwidthFine {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFwidthFine"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdxCoarse(OpDPdxCoarse {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdxCoarse"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DPdyCoarse(OpDPdyCoarse {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpDPdyCoarse"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::FwidthCoarse(OpFwidthCoarse {
                id_result_type,
                id_result,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpFwidthCoarse"
                )?;
                id_result_type.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EmitVertex(OpEmitVertex {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpEmitVertex")?;
                writeln!(f)
            }),
            Instruction::EndPrimitive(OpEndPrimitive {}) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpEndPrimitive"
                )?;
                writeln!(f)
            }),
            Instruction::EmitStreamVertex(OpEmitStreamVertex { stream }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpEmitStreamVertex"
                )?;
                stream.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EndStreamPrimitive(OpEndStreamPrimitive { stream }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpEndStreamPrimitive"
                )?;
                stream.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ControlBarrier(OpControlBarrier {
                execution,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpControlBarrier"
                )?;
                execution.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemoryBarrier(OpMemoryBarrier { memory, semantics }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemoryBarrier"
                )?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicLoad(OpAtomicLoad {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicLoad"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicStore(OpAtomicStore {
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpAtomicStore")?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicExchange(OpAtomicExchange {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicExchange"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicCompareExchange(OpAtomicCompareExchange {
                id_result_type,
                id_result,
                pointer,
                memory,
                equal,
                unequal,
                value,
                comparator,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicCompareExchange"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                equal.spirv_display(f)?;
                unequal.spirv_display(f)?;
                value.spirv_display(f)?;
                comparator.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicCompareExchangeWeak(OpAtomicCompareExchangeWeak {
                id_result_type,
                id_result,
                pointer,
                memory,
                equal,
                unequal,
                value,
                comparator,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicCompareExchangeWeak"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                equal.spirv_display(f)?;
                unequal.spirv_display(f)?;
                value.spirv_display(f)?;
                comparator.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicIIncrement(OpAtomicIIncrement {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicIIncrement"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicIDecrement(OpAtomicIDecrement {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicIDecrement"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicIAdd(OpAtomicIAdd {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicISub(OpAtomicISub {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicISub"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicSMin(OpAtomicSMin {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicSMin"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicUMin(OpAtomicUMin {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicUMin"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicSMax(OpAtomicSMax {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicSMax"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicUMax(OpAtomicUMax {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicUMax"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicAnd(OpAtomicAnd {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicAnd"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicOr(OpAtomicOr {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicOr"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicXor(OpAtomicXor {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicXor"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Phi(OpPhi {
                id_result_type,
                id_result,
                variable_parent,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPhi"
                )?;
                id_result_type.spirv_display(f)?;
                variable_parent.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LoopMerge(OpLoopMerge {
                merge_block,
                continue_target,
                loop_control,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpLoopMerge")?;
                merge_block.spirv_display(f)?;
                continue_target.spirv_display(f)?;
                loop_control.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SelectionMerge(OpSelectionMerge {
                merge_block,
                selection_control,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSelectionMerge"
                )?;
                merge_block.spirv_display(f)?;
                selection_control.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Label(OpLabel { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpLabel"
                )?;
                writeln!(f)
            }),
            Instruction::Branch(OpBranch { target_label }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpBranch")?;
                target_label.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BranchConditional(OpBranchConditional {
                condition,
                true_label,
                false_label,
                branch_weights,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpBranchConditional"
                )?;
                condition.spirv_display(f)?;
                true_label.spirv_display(f)?;
                false_label.spirv_display(f)?;
                branch_weights.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Switch32(OpSwitch32 {
                selector,
                default,
                target,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpSwitch")?;
                selector.spirv_display(f)?;
                default.spirv_display(f)?;
                target.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Switch64(OpSwitch64 {
                selector,
                default,
                target,
            }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpSwitch")?;
                selector.spirv_display(f)?;
                default.spirv_display(f)?;
                target.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Kill(OpKill {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpKill")?;
                writeln!(f)
            }),
            Instruction::Return(OpReturn {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpReturn")?;
                writeln!(f)
            }),
            Instruction::ReturnValue(OpReturnValue { value }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpReturnValue")?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::Unreachable(OpUnreachable {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpUnreachable")?;
                writeln!(f)
            }),
            Instruction::LifetimeStart(OpLifetimeStart { pointer, size }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpLifetimeStart"
                )?;
                pointer.spirv_display(f)?;
                size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::LifetimeStop(OpLifetimeStop { pointer, size }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpLifetimeStop"
                )?;
                pointer.spirv_display(f)?;
                size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupAsyncCopy(OpGroupAsyncCopy {
                id_result_type,
                id_result,
                execution,
                destination,
                source,
                num_elements,
                stride,
                event,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupAsyncCopy"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                destination.spirv_display(f)?;
                source.spirv_display(f)?;
                num_elements.spirv_display(f)?;
                stride.spirv_display(f)?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupWaitEvents(OpGroupWaitEvents {
                execution,
                num_events,
                events_list,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupWaitEvents"
                )?;
                execution.spirv_display(f)?;
                num_events.spirv_display(f)?;
                events_list.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupAll(OpGroupAll {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupAll"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupAny(OpGroupAny {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupAny"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupBroadcast(OpGroupBroadcast {
                id_result_type,
                id_result,
                execution,
                value,
                local_id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupBroadcast"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                local_id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupIAdd(OpGroupIAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupFAdd(OpGroupFAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupFAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupFMin(OpGroupFMin {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupFMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupUMin(OpGroupUMin {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupUMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupSMin(OpGroupSMin {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupSMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupFMax(OpGroupFMax {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupFMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupUMax(OpGroupUMax {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupUMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupSMax(OpGroupSMax {
                id_result_type,
                id_result,
                execution,
                operation,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupSMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReadPipe(OpReadPipe {
                id_result_type,
                id_result,
                pipe,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReadPipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::WritePipe(OpWritePipe {
                id_result_type,
                id_result,
                pipe,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpWritePipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReservedReadPipe(OpReservedReadPipe {
                id_result_type,
                id_result,
                pipe,
                reserve_id,
                index,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReservedReadPipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                index.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReservedWritePipe(OpReservedWritePipe {
                id_result_type,
                id_result,
                pipe,
                reserve_id,
                index,
                pointer,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReservedWritePipe"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                index.spirv_display(f)?;
                pointer.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReserveReadPipePackets(OpReserveReadPipePackets {
                id_result_type,
                id_result,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReserveReadPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReserveWritePipePackets(OpReserveWritePipePackets {
                id_result_type,
                id_result,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpReserveWritePipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CommitReadPipe(OpCommitReadPipe {
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCommitReadPipe"
                )?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CommitWritePipe(OpCommitWritePipe {
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCommitWritePipe"
                )?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsValidReserveId(OpIsValidReserveId {
                id_result_type,
                id_result,
                reserve_id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsValidReserveId"
                )?;
                id_result_type.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetNumPipePackets(OpGetNumPipePackets {
                id_result_type,
                id_result,
                pipe,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetNumPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetMaxPipePackets(OpGetMaxPipePackets {
                id_result_type,
                id_result,
                pipe,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetMaxPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                pipe.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupReserveReadPipePackets(OpGroupReserveReadPipePackets {
                id_result_type,
                id_result,
                execution,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupReserveReadPipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupReserveWritePipePackets(OpGroupReserveWritePipePackets {
                id_result_type,
                id_result,
                execution,
                pipe,
                num_packets,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupReserveWritePipePackets"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                num_packets.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupCommitReadPipe(OpGroupCommitReadPipe {
                execution,
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupCommitReadPipe"
                )?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupCommitWritePipe(OpGroupCommitWritePipe {
                execution,
                pipe,
                reserve_id,
                packet_size,
                packet_alignment,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpGroupCommitWritePipe"
                )?;
                execution.spirv_display(f)?;
                pipe.spirv_display(f)?;
                reserve_id.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EnqueueMarker(OpEnqueueMarker {
                id_result_type,
                id_result,
                queue,
                num_events,
                wait_events,
                ret_event,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpEnqueueMarker"
                )?;
                id_result_type.spirv_display(f)?;
                queue.spirv_display(f)?;
                num_events.spirv_display(f)?;
                wait_events.spirv_display(f)?;
                ret_event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::EnqueueKernel(OpEnqueueKernel {
                id_result_type,
                id_result,
                queue,
                flags,
                nd_range,
                num_events,
                wait_events,
                ret_event,
                invoke,
                param,
                param_size,
                param_align,
                local_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpEnqueueKernel"
                )?;
                id_result_type.spirv_display(f)?;
                queue.spirv_display(f)?;
                flags.spirv_display(f)?;
                nd_range.spirv_display(f)?;
                num_events.spirv_display(f)?;
                wait_events.spirv_display(f)?;
                ret_event.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                local_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelNDrangeSubGroupCount(OpGetKernelNDrangeSubGroupCount {
                id_result_type,
                id_result,
                nd_range,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelNDrangeSubGroupCount"
                )?;
                id_result_type.spirv_display(f)?;
                nd_range.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelNDrangeMaxSubGroupSize(OpGetKernelNDrangeMaxSubGroupSize {
                id_result_type,
                id_result,
                nd_range,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelNDrangeMaxSubGroupSize"
                )?;
                id_result_type.spirv_display(f)?;
                nd_range.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelWorkGroupSize(OpGetKernelWorkGroupSize {
                id_result_type,
                id_result,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelWorkGroupSize"
                )?;
                id_result_type.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelPreferredWorkGroupSizeMultiple(
                OpGetKernelPreferredWorkGroupSizeMultiple {
                    id_result_type,
                    id_result,
                    invoke,
                    param,
                    param_size,
                    param_align,
                },
            ) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelPreferredWorkGroupSizeMultiple"
                )?;
                id_result_type.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::RetainEvent(OpRetainEvent { event }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpRetainEvent")?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ReleaseEvent(OpReleaseEvent { event }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpReleaseEvent"
                )?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CreateUserEvent(OpCreateUserEvent {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCreateUserEvent"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::IsValidEvent(OpIsValidEvent {
                id_result_type,
                id_result,
                event,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpIsValidEvent"
                )?;
                id_result_type.spirv_display(f)?;
                event.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SetUserEventStatus(OpSetUserEventStatus { event, status }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpSetUserEventStatus"
                )?;
                event.spirv_display(f)?;
                status.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CaptureEventProfilingInfo(OpCaptureEventProfilingInfo {
                event,
                profiling_info,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpCaptureEventProfilingInfo"
                )?;
                event.spirv_display(f)?;
                profiling_info.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetDefaultQueue(OpGetDefaultQueue {
                id_result_type,
                id_result,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetDefaultQueue"
                )?;
                id_result_type.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::BuildNDRange(OpBuildNDRange {
                id_result_type,
                id_result,
                global_work_size,
                local_work_size,
                global_work_offset,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpBuildNDRange"
                )?;
                id_result_type.spirv_display(f)?;
                global_work_size.spirv_display(f)?;
                local_work_size.spirv_display(f)?;
                global_work_offset.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleImplicitLod(OpImageSparseSampleImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleExplicitLod(OpImageSparseSampleExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleDrefImplicitLod(OpImageSparseSampleDrefImplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleDrefImplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseSampleDrefExplicitLod(OpImageSparseSampleDrefExplicitLod {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseSampleDrefExplicitLod"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseFetch(OpImageSparseFetch {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseFetch"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseGather(OpImageSparseGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                component,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                component.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseDrefGather(OpImageSparseDrefGather {
                id_result_type,
                id_result,
                sampled_image,
                coordinate,
                d_ref,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseDrefGather"
                )?;
                id_result_type.spirv_display(f)?;
                sampled_image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                d_ref.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseTexelsResident(OpImageSparseTexelsResident {
                id_result_type,
                id_result,
                resident_code,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseTexelsResident"
                )?;
                id_result_type.spirv_display(f)?;
                resident_code.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::NoLine(OpNoLine {}) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpNoLine")?;
                writeln!(f)
            }),
            Instruction::AtomicFlagTestAndSet(OpAtomicFlagTestAndSet {
                id_result_type,
                id_result,
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpAtomicFlagTestAndSet"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::AtomicFlagClear(OpAtomicFlagClear {
                pointer,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpAtomicFlagClear"
                )?;
                pointer.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ImageSparseRead(OpImageSparseRead {
                id_result_type,
                id_result,
                image,
                coordinate,
                image_operands,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpImageSparseRead"
                )?;
                id_result_type.spirv_display(f)?;
                image.spirv_display(f)?;
                coordinate.spirv_display(f)?;
                image_operands.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::SizeOf(OpSizeOf {
                id_result_type,
                id_result,
                pointer,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpSizeOf"
                )?;
                id_result_type.spirv_display(f)?;
                pointer.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypePipeStorage(OpTypePipeStorage { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypePipeStorage"
                )?;
                writeln!(f)
            }),
            Instruction::ConstantPipeStorage(OpConstantPipeStorage {
                id_result_type,
                id_result,
                packet_size,
                packet_alignment,
                capacity,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpConstantPipeStorage"
                )?;
                id_result_type.spirv_display(f)?;
                packet_size.spirv_display(f)?;
                packet_alignment.spirv_display(f)?;
                capacity.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CreatePipeFromPipeStorage(OpCreatePipeFromPipeStorage {
                id_result_type,
                id_result,
                pipe_storage,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCreatePipeFromPipeStorage"
                )?;
                id_result_type.spirv_display(f)?;
                pipe_storage.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelLocalSizeForSubgroupCount(
                OpGetKernelLocalSizeForSubgroupCount {
                    id_result_type,
                    id_result,
                    subgroup_count,
                    invoke,
                    param,
                    param_size,
                    param_align,
                },
            ) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelLocalSizeForSubgroupCount"
                )?;
                id_result_type.spirv_display(f)?;
                subgroup_count.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GetKernelMaxNumSubgroups(OpGetKernelMaxNumSubgroups {
                id_result_type,
                id_result,
                invoke,
                param,
                param_size,
                param_align,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGetKernelMaxNumSubgroups"
                )?;
                id_result_type.spirv_display(f)?;
                invoke.spirv_display(f)?;
                param.spirv_display(f)?;
                param_size.spirv_display(f)?;
                param_align.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::TypeNamedBarrier(OpTypeNamedBarrier { id_result }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpTypeNamedBarrier"
                )?;
                writeln!(f)
            }),
            Instruction::NamedBarrierInitialize(OpNamedBarrierInitialize {
                id_result_type,
                id_result,
                subgroup_count,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpNamedBarrierInitialize"
                )?;
                id_result_type.spirv_display(f)?;
                subgroup_count.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemoryNamedBarrier(OpMemoryNamedBarrier {
                named_barrier,
                memory,
                semantics,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemoryNamedBarrier"
                )?;
                named_barrier.spirv_display(f)?;
                memory.spirv_display(f)?;
                semantics.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ModuleProcessed(OpModuleProcessed { process }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpModuleProcessed"
                )?;
                process.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::ExecutionModeId(OpExecutionModeId { entry_point, mode }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpExecutionModeId"
                )?;
                entry_point.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DecorateId(OpDecorateId { target, decoration }) => split_fn!({
                write!(f, "{}{}", InstructionIndentAndResult(None), "OpDecorateId")?;
                target.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformElect(OpGroupNonUniformElect {
                id_result_type,
                id_result,
                execution,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformElect"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformAll(OpGroupNonUniformAll {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformAll"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformAny(OpGroupNonUniformAny {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformAny"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformAllEqual(OpGroupNonUniformAllEqual {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformAllEqual"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBroadcast(OpGroupNonUniformBroadcast {
                id_result_type,
                id_result,
                execution,
                value,
                id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBroadcast"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBroadcastFirst(OpGroupNonUniformBroadcastFirst {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBroadcastFirst"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallot(OpGroupNonUniformBallot {
                id_result_type,
                id_result,
                execution,
                predicate,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallot"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                predicate.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformInverseBallot(OpGroupNonUniformInverseBallot {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformInverseBallot"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotBitExtract(OpGroupNonUniformBallotBitExtract {
                id_result_type,
                id_result,
                execution,
                value,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotBitExtract"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotBitCount(OpGroupNonUniformBallotBitCount {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotBitCount"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotFindLSB(OpGroupNonUniformBallotFindLSB {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotFindLSB"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBallotFindMSB(OpGroupNonUniformBallotFindMSB {
                id_result_type,
                id_result,
                execution,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBallotFindMSB"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffle(OpGroupNonUniformShuffle {
                id_result_type,
                id_result,
                execution,
                value,
                id,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffle"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                id.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffleXor(OpGroupNonUniformShuffleXor {
                id_result_type,
                id_result,
                execution,
                value,
                mask,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffleXor"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                mask.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffleUp(OpGroupNonUniformShuffleUp {
                id_result_type,
                id_result,
                execution,
                value,
                delta,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffleUp"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                delta.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformShuffleDown(OpGroupNonUniformShuffleDown {
                id_result_type,
                id_result,
                execution,
                value,
                delta,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformShuffleDown"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                delta.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformIAdd(OpGroupNonUniformIAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformIAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFAdd(OpGroupNonUniformFAdd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFAdd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformIMul(OpGroupNonUniformIMul {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformIMul"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFMul(OpGroupNonUniformFMul {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFMul"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformSMin(OpGroupNonUniformSMin {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformSMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformUMin(OpGroupNonUniformUMin {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformUMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFMin(OpGroupNonUniformFMin {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFMin"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformSMax(OpGroupNonUniformSMax {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformSMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformUMax(OpGroupNonUniformUMax {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformUMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformFMax(OpGroupNonUniformFMax {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformFMax"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBitwiseAnd(OpGroupNonUniformBitwiseAnd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBitwiseAnd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBitwiseOr(OpGroupNonUniformBitwiseOr {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBitwiseOr"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformBitwiseXor(OpGroupNonUniformBitwiseXor {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformBitwiseXor"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformLogicalAnd(OpGroupNonUniformLogicalAnd {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformLogicalAnd"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformLogicalOr(OpGroupNonUniformLogicalOr {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformLogicalOr"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformLogicalXor(OpGroupNonUniformLogicalXor {
                id_result_type,
                id_result,
                execution,
                operation,
                value,
                cluster_size,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformLogicalXor"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                operation.spirv_display(f)?;
                value.spirv_display(f)?;
                cluster_size.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformQuadBroadcast(OpGroupNonUniformQuadBroadcast {
                id_result_type,
                id_result,
                execution,
                value,
                index,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformQuadBroadcast"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                index.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GroupNonUniformQuadSwap(OpGroupNonUniformQuadSwap {
                id_result_type,
                id_result,
                execution,
                value,
                direction,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpGroupNonUniformQuadSwap"
                )?;
                id_result_type.spirv_display(f)?;
                execution.spirv_display(f)?;
                value.spirv_display(f)?;
                direction.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::CopyLogical(OpCopyLogical {
                id_result_type,
                id_result,
                operand,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpCopyLogical"
                )?;
                id_result_type.spirv_display(f)?;
                operand.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrEqual(OpPtrEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrNotEqual(OpPtrNotEqual {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrNotEqual"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::PtrDiff(OpPtrDiff {
                id_result_type,
                id_result,
                operand_1,
                operand_2,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(Some(*id_result)),
                    "OpPtrDiff"
                )?;
                id_result_type.spirv_display(f)?;
                operand_1.spirv_display(f)?;
                operand_2.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::DecorateString(OpDecorateString { target, decoration }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpDecorateString"
                )?;
                target.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::MemberDecorateString(OpMemberDecorateString {
                struct_type,
                member,
                decoration,
            }) => split_fn!({
                write!(
                    f,
                    "{}{}",
                    InstructionIndentAndResult(None),
                    "OpMemberDecorateString"
                )?;
                struct_type.spirv_display(f)?;
                member.spirv_display(f)?;
                decoration.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Round(OpGLSLStd450Round {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Round",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450RoundEven(OpGLSLStd450RoundEven {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "RoundEven",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Trunc(OpGLSLStd450Trunc {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Trunc",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FAbs(OpGLSLStd450FAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FAbs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SAbs(OpGLSLStd450SAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SAbs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FSign(OpGLSLStd450FSign {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FSign",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SSign(OpGLSLStd450SSign {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SSign",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Floor(OpGLSLStd450Floor {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Floor",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Ceil(OpGLSLStd450Ceil {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Ceil",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Fract(OpGLSLStd450Fract {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Fract",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Radians(OpGLSLStd450Radians {
                id_result_type,
                id_result,
                set,
                degrees,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Radians",
                )?;
                degrees.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Degrees(OpGLSLStd450Degrees {
                id_result_type,
                id_result,
                set,
                radians,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Degrees",
                )?;
                radians.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Sin(OpGLSLStd450Sin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Cos(OpGLSLStd450Cos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Tan(OpGLSLStd450Tan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Asin(OpGLSLStd450Asin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Asin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Acos(OpGLSLStd450Acos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Acos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Atan(OpGLSLStd450Atan {
                id_result_type,
                id_result,
                set,
                y_over_x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Atan",
                )?;
                y_over_x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Sinh(OpGLSLStd450Sinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Sinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Cosh(OpGLSLStd450Cosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Cosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Tanh(OpGLSLStd450Tanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Tanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Asinh(OpGLSLStd450Asinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Asinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Acosh(OpGLSLStd450Acosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Acosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Atanh(OpGLSLStd450Atanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Atanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Atan2(OpGLSLStd450Atan2 {
                id_result_type,
                id_result,
                set,
                y,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Atan2",
                )?;
                y.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Pow(OpGLSLStd450Pow {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Pow",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Exp(OpGLSLStd450Exp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Log(OpGLSLStd450Log {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Exp2(OpGLSLStd450Exp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Log2(OpGLSLStd450Log2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Sqrt(OpGLSLStd450Sqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InverseSqrt(OpGLSLStd450InverseSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InverseSqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Determinant(OpGLSLStd450Determinant {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Determinant",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450MatrixInverse(OpGLSLStd450MatrixInverse {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "MatrixInverse",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Modf(OpGLSLStd450Modf {
                id_result_type,
                id_result,
                set,
                x,
                i,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Modf",
                )?;
                x.spirv_display(f)?;
                i.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450ModfStruct(OpGLSLStd450ModfStruct {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ModfStruct",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FMin(OpGLSLStd450FMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UMin(OpGLSLStd450UMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SMin(OpGLSLStd450SMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FMax(OpGLSLStd450FMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UMax(OpGLSLStd450UMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SMax(OpGLSLStd450SMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FClamp(OpGLSLStd450FClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UClamp(OpGLSLStd450UClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SClamp(OpGLSLStd450SClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FMix(OpGLSLStd450FMix {
                id_result_type,
                id_result,
                set,
                x,
                y,
                a,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FMix",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                a.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450IMix(OpGLSLStd450IMix {
                id_result_type,
                id_result,
                set,
                x,
                y,
                a,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "IMix",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                a.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Step(OpGLSLStd450Step {
                id_result_type,
                id_result,
                set,
                edge,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Step",
                )?;
                edge.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450SmoothStep(OpGLSLStd450SmoothStep {
                id_result_type,
                id_result,
                set,
                edge0,
                edge1,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "SmoothStep",
                )?;
                edge0.spirv_display(f)?;
                edge1.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Fma(OpGLSLStd450Fma {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Fma",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Frexp(OpGLSLStd450Frexp {
                id_result_type,
                id_result,
                set,
                x,
                exp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Frexp",
                )?;
                x.spirv_display(f)?;
                exp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FrexpStruct(OpGLSLStd450FrexpStruct {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FrexpStruct",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Ldexp(OpGLSLStd450Ldexp {
                id_result_type,
                id_result,
                set,
                x,
                exp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Ldexp",
                )?;
                x.spirv_display(f)?;
                exp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackSnorm4x8(OpGLSLStd450PackSnorm4x8 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackSnorm4x8",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackUnorm4x8(OpGLSLStd450PackUnorm4x8 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackUnorm4x8",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackSnorm2x16(OpGLSLStd450PackSnorm2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackSnorm2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackUnorm2x16(OpGLSLStd450PackUnorm2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackUnorm2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackHalf2x16(OpGLSLStd450PackHalf2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackHalf2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450PackDouble2x32(OpGLSLStd450PackDouble2x32 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "PackDouble2x32",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackSnorm2x16(OpGLSLStd450UnpackSnorm2x16 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackSnorm2x16",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackUnorm2x16(OpGLSLStd450UnpackUnorm2x16 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackUnorm2x16",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackHalf2x16(OpGLSLStd450UnpackHalf2x16 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackHalf2x16",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackSnorm4x8(OpGLSLStd450UnpackSnorm4x8 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackSnorm4x8",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackUnorm4x8(OpGLSLStd450UnpackUnorm4x8 {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackUnorm4x8",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450UnpackDouble2x32(OpGLSLStd450UnpackDouble2x32 {
                id_result_type,
                id_result,
                set,
                v,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "UnpackDouble2x32",
                )?;
                v.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Length(OpGLSLStd450Length {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Length",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Distance(OpGLSLStd450Distance {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Distance",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Cross(OpGLSLStd450Cross {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Cross",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Normalize(OpGLSLStd450Normalize {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Normalize",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FaceForward(OpGLSLStd450FaceForward {
                id_result_type,
                id_result,
                set,
                n,
                i,
                nref,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FaceForward",
                )?;
                n.spirv_display(f)?;
                i.spirv_display(f)?;
                nref.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Reflect(OpGLSLStd450Reflect {
                id_result_type,
                id_result,
                set,
                i,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Reflect",
                )?;
                i.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450Refract(OpGLSLStd450Refract {
                id_result_type,
                id_result,
                set,
                i,
                n,
                eta,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "Refract",
                )?;
                i.spirv_display(f)?;
                n.spirv_display(f)?;
                eta.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FindILsb(OpGLSLStd450FindILsb {
                id_result_type,
                id_result,
                set,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FindILsb",
                )?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FindSMsb(OpGLSLStd450FindSMsb {
                id_result_type,
                id_result,
                set,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FindSMsb",
                )?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450FindUMsb(OpGLSLStd450FindUMsb {
                id_result_type,
                id_result,
                set,
                value,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "FindUMsb",
                )?;
                value.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InterpolateAtCentroid(OpGLSLStd450InterpolateAtCentroid {
                id_result_type,
                id_result,
                set,
                interpolant,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InterpolateAtCentroid",
                )?;
                interpolant.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InterpolateAtSample(OpGLSLStd450InterpolateAtSample {
                id_result_type,
                id_result,
                set,
                interpolant,
                sample,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InterpolateAtSample",
                )?;
                interpolant.spirv_display(f)?;
                sample.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450InterpolateAtOffset(OpGLSLStd450InterpolateAtOffset {
                id_result_type,
                id_result,
                set,
                interpolant,
                offset,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "InterpolateAtOffset",
                )?;
                interpolant.spirv_display(f)?;
                offset.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450NMin(OpGLSLStd450NMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "NMin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450NMax(OpGLSLStd450NMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "NMax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::GLSLStd450NClamp(OpGLSLStd450NClamp {
                id_result_type,
                id_result,
                set,
                x,
                min_val,
                max_val,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "NClamp",
                )?;
                x.spirv_display(f)?;
                min_val.spirv_display(f)?;
                max_val.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAcos(OpOpenCLStdAcos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "acos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAcosh(OpOpenCLStdAcosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "acosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAcospi(OpOpenCLStdAcospi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "acospi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAsin(OpOpenCLStdAsin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "asin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAsinh(OpOpenCLStdAsinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "asinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAsinpi(OpOpenCLStdAsinpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "asinpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtan(OpOpenCLStdAtan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtan2(OpOpenCLStdAtan2 {
                id_result_type,
                id_result,
                set,
                y,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atan2",
                )?;
                y.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtanh(OpOpenCLStdAtanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtanpi(OpOpenCLStdAtanpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atanpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdAtan2pi(OpOpenCLStdAtan2pi {
                id_result_type,
                id_result,
                set,
                y,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "atan2pi",
                )?;
                y.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCbrt(OpOpenCLStdCbrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cbrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCeil(OpOpenCLStdCeil {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ceil",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCopysign(OpOpenCLStdCopysign {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "copysign",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCos(OpOpenCLStdCos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCosh(OpOpenCLStdCosh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cosh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCospi(OpOpenCLStdCospi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cospi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdErfc(OpOpenCLStdErfc {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "erfc",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdErf(OpOpenCLStdErf {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "erf",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExp(OpOpenCLStdExp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExp2(OpOpenCLStdExp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExp10(OpOpenCLStdExp10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "exp10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdExpm1(OpOpenCLStdExpm1 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "expm1",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFabs(OpOpenCLStdFabs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fabs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFdim(OpOpenCLStdFdim {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fdim",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFloor(OpOpenCLStdFloor {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "floor",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFma(OpOpenCLStdFma {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fma",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmax(OpOpenCLStdFmax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmax",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmin(OpOpenCLStdFmin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmin",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmod(OpOpenCLStdFmod {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmod",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFract(OpOpenCLStdFract {
                id_result_type,
                id_result,
                set,
                x,
                ptr,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fract",
                )?;
                x.spirv_display(f)?;
                ptr.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFrexp(OpOpenCLStdFrexp {
                id_result_type,
                id_result,
                set,
                x,
                exp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "frexp",
                )?;
                x.spirv_display(f)?;
                exp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHypot(OpOpenCLStdHypot {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "hypot",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdIlogb(OpOpenCLStdIlogb {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ilogb",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLdexp(OpOpenCLStdLdexp {
                id_result_type,
                id_result,
                set,
                x,
                k,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ldexp",
                )?;
                x.spirv_display(f)?;
                k.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLgamma(OpOpenCLStdLgamma {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "lgamma",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLgammaR(OpOpenCLStdLgammaR {
                id_result_type,
                id_result,
                set,
                x,
                signp,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "lgamma_r",
                )?;
                x.spirv_display(f)?;
                signp.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog(OpOpenCLStdLog {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog2(OpOpenCLStdLog2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog10(OpOpenCLStdLog10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLog1p(OpOpenCLStdLog1p {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "log1p",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLogb(OpOpenCLStdLogb {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "logb",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMad(OpOpenCLStdMad {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "mad",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMaxmag(OpOpenCLStdMaxmag {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "maxmag",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMinmag(OpOpenCLStdMinmag {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "minmag",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdModf(OpOpenCLStdModf {
                id_result_type,
                id_result,
                set,
                x,
                iptr,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "modf",
                )?;
                x.spirv_display(f)?;
                iptr.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNan(OpOpenCLStdNan {
                id_result_type,
                id_result,
                set,
                nancode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "nan",
                )?;
                nancode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNextafter(OpOpenCLStdNextafter {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "nextafter",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPow(OpOpenCLStdPow {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "pow",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPown(OpOpenCLStdPown {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "pown",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPowr(OpOpenCLStdPowr {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "powr",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRemainder(OpOpenCLStdRemainder {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "remainder",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRemquo(OpOpenCLStdRemquo {
                id_result_type,
                id_result,
                set,
                x,
                y,
                quo,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "remquo",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                quo.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRint(OpOpenCLStdRint {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rint",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRootn(OpOpenCLStdRootn {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rootn",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRound(OpOpenCLStdRound {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "round",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRsqrt(OpOpenCLStdRsqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rsqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSin(OpOpenCLStdSin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSincos(OpOpenCLStdSincos {
                id_result_type,
                id_result,
                set,
                x,
                cosval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sincos",
                )?;
                x.spirv_display(f)?;
                cosval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSinh(OpOpenCLStdSinh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sinh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSinpi(OpOpenCLStdSinpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sinpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSqrt(OpOpenCLStdSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTan(OpOpenCLStdTan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTanh(OpOpenCLStdTanh {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tanh",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTanpi(OpOpenCLStdTanpi {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tanpi",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTgamma(OpOpenCLStdTgamma {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "tgamma",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdTrunc(OpOpenCLStdTrunc {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "trunc",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfCos(OpOpenCLStdHalfCos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfDivide(OpOpenCLStdHalfDivide {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_divide",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfExp(OpOpenCLStdHalfExp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfExp2(OpOpenCLStdHalfExp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfExp10(OpOpenCLStdHalfExp10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_exp10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfLog(OpOpenCLStdHalfLog {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfLog2(OpOpenCLStdHalfLog2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfLog10(OpOpenCLStdHalfLog10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_log10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfPowr(OpOpenCLStdHalfPowr {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_powr",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfRecip(OpOpenCLStdHalfRecip {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_recip",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfRsqrt(OpOpenCLStdHalfRsqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_rsqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfSin(OpOpenCLStdHalfSin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfSqrt(OpOpenCLStdHalfSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdHalfTan(OpOpenCLStdHalfTan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "half_tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeCos(OpOpenCLStdNativeCos {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_cos",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeDivide(OpOpenCLStdNativeDivide {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_divide",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeExp(OpOpenCLStdNativeExp {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_exp",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeExp2(OpOpenCLStdNativeExp2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_exp2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeExp10(OpOpenCLStdNativeExp10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_exp10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeLog(OpOpenCLStdNativeLog {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_log",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeLog2(OpOpenCLStdNativeLog2 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_log2",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeLog10(OpOpenCLStdNativeLog10 {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_log10",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativePowr(OpOpenCLStdNativePowr {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_powr",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeRecip(OpOpenCLStdNativeRecip {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_recip",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeRsqrt(OpOpenCLStdNativeRsqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_rsqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeSin(OpOpenCLStdNativeSin {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_sin",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeSqrt(OpOpenCLStdNativeSqrt {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_sqrt",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNativeTan(OpOpenCLStdNativeTan {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "native_tan",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSAbs(OpOpenCLStdSAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_abs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSAbsDiff(OpOpenCLStdSAbsDiff {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_abs_diff",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSAddSat(OpOpenCLStdSAddSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_add_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUAddSat(OpOpenCLStdUAddSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_add_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSHadd(OpOpenCLStdSHadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_hadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUHadd(OpOpenCLStdUHadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_hadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSRhadd(OpOpenCLStdSRhadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_rhadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdURhadd(OpOpenCLStdURhadd {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_rhadd",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSClamp(OpOpenCLStdSClamp {
                id_result_type,
                id_result,
                set,
                x,
                minval,
                maxval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_clamp",
                )?;
                x.spirv_display(f)?;
                minval.spirv_display(f)?;
                maxval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUClamp(OpOpenCLStdUClamp {
                id_result_type,
                id_result,
                set,
                x,
                minval,
                maxval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_clamp",
                )?;
                x.spirv_display(f)?;
                minval.spirv_display(f)?;
                maxval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdClz(OpOpenCLStdClz {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "clz",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCtz(OpOpenCLStdCtz {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "ctz",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMadHi(OpOpenCLStdSMadHi {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mad_hi",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMadSat(OpOpenCLStdUMadSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mad_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMadSat(OpOpenCLStdSMadSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mad_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMax(OpOpenCLStdSMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_max",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMax(OpOpenCLStdUMax {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_max",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMin(OpOpenCLStdSMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_min",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMin(OpOpenCLStdUMin {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_min",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMulHi(OpOpenCLStdSMulHi {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mul_hi",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRotate(OpOpenCLStdRotate {
                id_result_type,
                id_result,
                set,
                v,
                i,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "rotate",
                )?;
                v.spirv_display(f)?;
                i.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSSubSat(OpOpenCLStdSSubSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_sub_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUSubSat(OpOpenCLStdUSubSat {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_sub_sat",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUUpsample(OpOpenCLStdUUpsample {
                id_result_type,
                id_result,
                set,
                hi,
                lo,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_upsample",
                )?;
                hi.spirv_display(f)?;
                lo.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSUpsample(OpOpenCLStdSUpsample {
                id_result_type,
                id_result,
                set,
                hi,
                lo,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_upsample",
                )?;
                hi.spirv_display(f)?;
                lo.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPopcount(OpOpenCLStdPopcount {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "popcount",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMad24(OpOpenCLStdSMad24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mad24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMad24(OpOpenCLStdUMad24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
                z,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mad24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                z.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSMul24(OpOpenCLStdSMul24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "s_mul24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMul24(OpOpenCLStdUMul24 {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mul24",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUAbs(OpOpenCLStdUAbs {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_abs",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUAbsDiff(OpOpenCLStdUAbsDiff {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_abs_diff",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMulHi(OpOpenCLStdUMulHi {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mul_hi",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdUMadHi(OpOpenCLStdUMadHi {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "u_mad_hi",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFclamp(OpOpenCLStdFclamp {
                id_result_type,
                id_result,
                set,
                x,
                minval,
                maxval,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fclamp",
                )?;
                x.spirv_display(f)?;
                minval.spirv_display(f)?;
                maxval.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdDegrees(OpOpenCLStdDegrees {
                id_result_type,
                id_result,
                set,
                radians,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "degrees",
                )?;
                radians.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFmaxCommon(OpOpenCLStdFmaxCommon {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmax_common",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFminCommon(OpOpenCLStdFminCommon {
                id_result_type,
                id_result,
                set,
                x,
                y,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fmin_common",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdMix(OpOpenCLStdMix {
                id_result_type,
                id_result,
                set,
                x,
                y,
                a,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "mix",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                a.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdRadians(OpOpenCLStdRadians {
                id_result_type,
                id_result,
                set,
                degrees,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "radians",
                )?;
                degrees.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdStep(OpOpenCLStdStep {
                id_result_type,
                id_result,
                set,
                edge,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "step",
                )?;
                edge.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSmoothstep(OpOpenCLStdSmoothstep {
                id_result_type,
                id_result,
                set,
                edge0,
                edge1,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "smoothstep",
                )?;
                edge0.spirv_display(f)?;
                edge1.spirv_display(f)?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSign(OpOpenCLStdSign {
                id_result_type,
                id_result,
                set,
                x,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "sign",
                )?;
                x.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdCross(OpOpenCLStdCross {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "cross",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdDistance(OpOpenCLStdDistance {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "distance",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdLength(OpOpenCLStdLength {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "length",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdNormalize(OpOpenCLStdNormalize {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "normalize",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFastDistance(OpOpenCLStdFastDistance {
                id_result_type,
                id_result,
                set,
                p0,
                p1,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fast_distance",
                )?;
                p0.spirv_display(f)?;
                p1.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFastLength(OpOpenCLStdFastLength {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fast_length",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdFastNormalize(OpOpenCLStdFastNormalize {
                id_result_type,
                id_result,
                set,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "fast_normalize",
                )?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdBitselect(OpOpenCLStdBitselect {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "bitselect",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdSelect(OpOpenCLStdSelect {
                id_result_type,
                id_result,
                set,
                a,
                b,
                c,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "select",
                )?;
                a.spirv_display(f)?;
                b.spirv_display(f)?;
                c.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadn(OpOpenCLStdVloadn {
                id_result_type,
                id_result,
                set,
                offset,
                p,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vloadn",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoren(OpOpenCLStdVstoren {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstoren",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadHalf(OpOpenCLStdVloadHalf {
                id_result_type,
                id_result,
                set,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vload_half",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadHalfn(OpOpenCLStdVloadHalfn {
                id_result_type,
                id_result,
                set,
                offset,
                p,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vload_halfn",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalf(OpOpenCLStdVstoreHalf {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_half",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalfR(OpOpenCLStdVstoreHalfR {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
                mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_half_r",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalfn(OpOpenCLStdVstoreHalfn {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_halfn",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreHalfnR(OpOpenCLStdVstoreHalfnR {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
                mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstore_halfn_r",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVloadaHalfn(OpOpenCLStdVloadaHalfn {
                id_result_type,
                id_result,
                set,
                offset,
                p,
                n,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vloada_halfn",
                )?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                n.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreaHalfn(OpOpenCLStdVstoreaHalfn {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstorea_halfn",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdVstoreaHalfnR(OpOpenCLStdVstoreaHalfnR {
                id_result_type,
                id_result,
                set,
                data,
                offset,
                p,
                mode,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "vstorea_halfn_r",
                )?;
                data.spirv_display(f)?;
                offset.spirv_display(f)?;
                p.spirv_display(f)?;
                mode.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdShuffle(OpOpenCLStdShuffle {
                id_result_type,
                id_result,
                set,
                x,
                shuffle_mask,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "shuffle",
                )?;
                x.spirv_display(f)?;
                shuffle_mask.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdShuffle2(OpOpenCLStdShuffle2 {
                id_result_type,
                id_result,
                set,
                x,
                y,
                shuffle_mask,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "shuffle2",
                )?;
                x.spirv_display(f)?;
                y.spirv_display(f)?;
                shuffle_mask.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPrintf(OpOpenCLStdPrintf {
                id_result_type,
                id_result,
                set,
                format,
                additional_arguments,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "printf",
                )?;
                format.spirv_display(f)?;
                additional_arguments.spirv_display(f)?;
                writeln!(f)
            }),
            Instruction::OpenCLStdPrefetch(OpOpenCLStdPrefetch {
                id_result_type,
                id_result,
                set,
                ptr,
                num_elements,
            }) => split_fn!({
                write!(
                    f,
                    "{}OpExtInst {} {} {}",
                    InstructionIndentAndResult(Some(*id_result)),
                    id_result_type,
                    set,
                    "prefetch",
                )?;
                ptr.spirv_display(f)?;
                num_elements.spirv_display(f)?;
                writeln!(f)
            }),
        }
    }
}
impl SPIRVParse for OpSpecConstantOp {
    fn spirv_parse<'a>(
        words: &'a [u32],
        parse_state: &mut ParseState,
    ) -> Result<(Self, &'a [u32])> {
        let (id_result_type, words) = IdResultType::spirv_parse(words, parse_state)?;
        let (id_result, words) = IdResult::spirv_parse(words, parse_state)?;
        let (opcode, words) = u32::spirv_parse(words, parse_state)?;
        match opcode {
            65u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::AccessChain(OpAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            66u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::InBoundsAccessChain(OpInBoundsAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            67u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (element, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::PtrAccessChain(OpPtrAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            element,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            70u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (element, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<IdRef>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::InBoundsPtrAccessChain(OpInBoundsPtrAccessChain {
                            id_result_type,
                            id_result,
                            base,
                            element,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            79u32 => {
                let (vector_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (vector_2, words) = IdRef::spirv_parse(words, parse_state)?;
                let (components, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::VectorShuffle(OpVectorShuffle {
                            id_result_type,
                            id_result,
                            vector_1,
                            vector_2,
                            components,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            81u32 => {
                let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::CompositeExtract(OpCompositeExtract {
                            id_result_type,
                            id_result,
                            composite,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            82u32 => {
                let (object, words) = IdRef::spirv_parse(words, parse_state)?;
                let (composite, words) = IdRef::spirv_parse(words, parse_state)?;
                let (indexes, words) = Vec::<LiteralInteger32>::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::CompositeInsert(OpCompositeInsert {
                            id_result_type,
                            id_result,
                            object,
                            composite,
                            indexes,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            109u32 => {
                let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertFToU(OpConvertFToU {
                            id_result_type,
                            id_result,
                            float_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            110u32 => {
                let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertFToS(OpConvertFToS {
                            id_result_type,
                            id_result,
                            float_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            111u32 => {
                let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertSToF(OpConvertSToF {
                            id_result_type,
                            id_result,
                            signed_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            112u32 => {
                let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertUToF(OpConvertUToF {
                            id_result_type,
                            id_result,
                            unsigned_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            113u32 => {
                let (unsigned_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UConvert(OpUConvert {
                            id_result_type,
                            id_result,
                            unsigned_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            114u32 => {
                let (signed_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SConvert(OpSConvert {
                            id_result_type,
                            id_result,
                            signed_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            115u32 => {
                let (float_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FConvert(OpFConvert {
                            id_result_type,
                            id_result,
                            float_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            116u32 => {
                let (value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::QuantizeToF16(OpQuantizeToF16 {
                            id_result_type,
                            id_result,
                            value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            117u32 => {
                let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertPtrToU(OpConvertPtrToU {
                            id_result_type,
                            id_result,
                            pointer,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            120u32 => {
                let (integer_value, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ConvertUToPtr(OpConvertUToPtr {
                            id_result_type,
                            id_result,
                            integer_value,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            121u32 => {
                let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::PtrCastToGeneric(OpPtrCastToGeneric {
                            id_result_type,
                            id_result,
                            pointer,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            122u32 => {
                let (pointer, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::GenericCastToPtr(OpGenericCastToPtr {
                            id_result_type,
                            id_result,
                            pointer,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            124u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::Bitcast(OpBitcast {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            126u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SNegate(OpSNegate {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            127u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FNegate(OpFNegate {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            128u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::IAdd(OpIAdd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            129u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FAdd(OpFAdd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            130u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ISub(OpISub {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            131u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FSub(OpFSub {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            132u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::IMul(OpIMul {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            133u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FMul(OpFMul {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            134u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UDiv(OpUDiv {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            135u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SDiv(OpSDiv {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            136u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FDiv(OpFDiv {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            137u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UMod(OpUMod {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            138u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SRem(OpSRem {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            139u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SMod(OpSMod {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            140u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FRem(OpFRem {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            141u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::FMod(OpFMod {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            164u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalEqual(OpLogicalEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            165u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalNotEqual(OpLogicalNotEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            166u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalOr(OpLogicalOr {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            167u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalAnd(OpLogicalAnd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            168u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::LogicalNot(OpLogicalNot {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            169u32 => {
                let (condition, words) = IdRef::spirv_parse(words, parse_state)?;
                let (object_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (object_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::Select(OpSelect {
                            id_result_type,
                            id_result,
                            condition,
                            object_1,
                            object_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            170u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::IEqual(OpIEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            171u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::INotEqual(OpINotEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            172u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UGreaterThan(OpUGreaterThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            173u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SGreaterThan(OpSGreaterThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            174u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::UGreaterThanEqual(OpUGreaterThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            175u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SGreaterThanEqual(OpSGreaterThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            176u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ULessThan(OpULessThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            177u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SLessThan(OpSLessThan {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            178u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ULessThanEqual(OpULessThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            179u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::SLessThanEqual(OpSLessThanEqual {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            194u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ShiftRightLogical(OpShiftRightLogical {
                            id_result_type,
                            id_result,
                            base,
                            shift,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            195u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ShiftRightArithmetic(OpShiftRightArithmetic {
                            id_result_type,
                            id_result,
                            base,
                            shift,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            196u32 => {
                let (base, words) = IdRef::spirv_parse(words, parse_state)?;
                let (shift, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::ShiftLeftLogical(OpShiftLeftLogical {
                            id_result_type,
                            id_result,
                            base,
                            shift,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            197u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::BitwiseOr(OpBitwiseOr {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            198u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::BitwiseXor(OpBitwiseXor {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            199u32 => {
                let (operand_1, words) = IdRef::spirv_parse(words, parse_state)?;
                let (operand_2, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::BitwiseAnd(OpBitwiseAnd {
                            id_result_type,
                            id_result,
                            operand_1,
                            operand_2,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            200u32 => {
                let (operand, words) = IdRef::spirv_parse(words, parse_state)?;
                parse_state.define_value(id_result_type, id_result)?;
                if words.is_empty() {
                    Ok((
                        OpSpecConstantOp::Not(OpNot {
                            id_result_type,
                            id_result,
                            operand,
                        }),
                        words,
                    ))
                } else {
                    Err(Error::InstructionTooLong)
                }
            }
            opcode => Err(Error::UnknownSpecConstantOpcode(opcode)),
        }
    }
}
pub const GLSL_STD_450_VERSION: u32 = 100u32;
pub const GLSL_STD_450_REVISION: u32 = 2u32;
pub const OPEN_CL_STD_VERSION: u32 = 100u32;
pub const OPEN_CL_STD_REVISION: u32 = 2u32;
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum ExtensionInstructionSet {
    GLSLStd450,
    OpenCLStd,
    Other(String),
}
impl<'a> From<Cow<'a, str>> for ExtensionInstructionSet {
    fn from(s: Cow<'a, str>) -> ExtensionInstructionSet {
        match s.as_ref() {
            "GLSL.std.450" => return ExtensionInstructionSet::GLSLStd450,
            "OpenCL.std" => return ExtensionInstructionSet::OpenCLStd,
            _ => {}
        }
        ExtensionInstructionSet::Other(s.into_owned())
    }
}
impl Deref for ExtensionInstructionSet {
    type Target = str;
    fn deref(&self) -> &str {
        match self {
            ExtensionInstructionSet::GLSLStd450 => "GLSL.std.450",
            ExtensionInstructionSet::OpenCLStd => "OpenCL.std",
            ExtensionInstructionSet::Other(s) => &**s,
        }
    }
}
impl AsRef<str> for ExtensionInstructionSet {
    fn as_ref(&self) -> &str {
        &**self
    }
}
impl From<ExtensionInstructionSet> for String {
    fn from(v: ExtensionInstructionSet) -> String {
        match v {
            ExtensionInstructionSet::Other(v) => v,
            v => String::from(v.as_ref()),
        }
    }
}
impl<'a> From<&'a str> for ExtensionInstructionSet {
    fn from(s: &'a str) -> Self {
        Cow::Borrowed(s).into()
    }
}
impl From<String> for ExtensionInstructionSet {
    fn from(s: String) -> Self {
        Self::from(Cow::Owned(s))
    }
}
impl fmt::Display for ExtensionInstructionSet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let s: &str = &**self;
        fmt::Display::fmt(s, f)
    }
}
#[cfg(test)]
mod input_file_tests {
    use sha2::{Digest, Sha256};
    use std::fs;
    use std::io::{BufRead, BufReader};
    use std::path::Path;
    #[doc = r" note: using lines() to prevent line-endings from affecting hash when checked out on windows vs. unix"]
    fn input_file_test(path: &str, digest: &[u8]) {
        let path = Path::new(env!("CARGO_MANIFEST_DIR")).join(path);
        println!("checking input file: {}", path.display());
        println!(
            "expected hash: {}",
            digest
                .iter()
                .map(|byte| format!("{:02X}", byte))
                .collect::<String>()
        );
        let file = fs::File::open(&path)
            .map_err(|err| format!("can't open file {}: {}", path.display(), err))
            .unwrap();
        let mut hasher = Sha256::new();
        for line in BufReader::new(file).lines() {
            hasher.input(line.unwrap());
            hasher.input(b"\n");
        }
        assert_eq!(digest, hasher.result().as_ref(), "hash doesn't match");
    }
    #[test]
    fn input_file_tests() {
        println!("checking that generated code is up to date -- update by running:");
        println!("cargo build --features=spirv-parser-generator");
        input_file_test ( "../spirv-parser-generator/src/ast.rs" , b"A\xDF\x03\xF41\xF3\xD2\xCB)\xF0\xB3\xB8t\xF9N\x1B\xDB\xAB\xE3\xAFq\x0BDu\x8E\xE1\xEF\xEARf\xEC\xF7" ) ;
        input_file_test ( "../spirv-parser-generator/src/generate.rs" , b"\xF7\xD9$;C\xA6\xE8m\xA9(\x93x\xDFa\xE1.\xDF\xE7\xCF\xED;j\xDAC3H\xC9\xBD\xF7\xF4%\xB3" ) ;
        input_file_test ( "../spirv-parser-generator/src/lib.rs" , b"\xEC\xF6`\xB8\x8C\x90\xE8/\r1\xE3\xE2\xC9\xD8\xBF\x8B?6b\x99{\x9D\xB2Y\xE8H\xF1g\xE9B\xA7\xF2" ) ;
        input_file_test ( "../spirv-parser-generator/src/util.rs" , b"\xB6\x92f\xB0*\x8D\xB4\xA7\xA0\x194\x12\xCC\xCDg\x8B\xDB\xB3\xCA\xF4\xE2)\xDE\xE3\x03Hw]\x13\xB1w\xEB" ) ;
        input_file_test ( "../spirv-parser-generator/Cargo.toml" , b"\xB2\xBB?\xE5\xB5\xB3\xED\x96]\x8Cj\xDDM+\xB0\xFB\xC9\xBB\xAB\xF8\tH\x02\xFF\xA7\x05\xD3\x0E\xDE\x98\r\x02" ) ;
        input_file_test ( "../external/SPIRV-Headers/include/spirv/unified1/spirv.core.grammar.json" , b"\xA0\xE8!\x91\xFBV\x81\x041Ra\xCB\xCE\r6\xBC\xCCD\xAE34\xECT\x82\xC0\x150S\x97\xEF\x06\xA5" ) ;
        input_file_test(
            "../external/SPIRV-Headers/include/spirv/unified1/extinst.opencl.std.100.grammar.json",
            b"\xB6\xBE2H\xAF\x8EaP3.\xC5\xD9\xDF.W\x8B6MX\x8Cv%3\x83\x1BuP\xF6\x07\xA7?\xF8",
        );
        input_file_test ( "../external/SPIRV-Headers/include/spirv/unified1/extinst.glsl.std.450.grammar.json" , b";\xCFx\xC1;q\xA9\xEB\xBAQ\xE8\x90\xC5_A\xA5\xE0\xF4{\xA2\x83\xBC|\x08\xFD~\x13D\xEA_G\xA6" ) ;
    }
}
